diff --git a/.gitignore b/.gitignore
index a03fda3fa4..027a9aade6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -331,4 +331,3 @@ third_party/rust/target/
 # Buckup files that are generated by //tools/metrics/histograms/pretty_print.py in presubmit.
 /*.before.pretty-print.xml
 *.rej
-*.rej
diff --git a/base/BUILD.gn b/base/BUILD.gn
index a3cfd20c85..6e78eca8bf 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -1095,6 +1095,7 @@ component("base") {
     libs += [
       "execinfo",
       "util",
+      "z",
     ]
   }
 
diff --git a/base/process/process_handle_openbsd.cc b/base/process/process_handle_openbsd.cc
index 8c4d037afd..91e59a3fbf 100644
--- a/base/process/process_handle_openbsd.cc
+++ b/base/process/process_handle_openbsd.cc
@@ -60,7 +60,7 @@ FilePath GetProcessExecutablePath(ProcessHandle process) {
   if ((cpath = getenv("CHROME_EXE_PATH")) != NULL)
     result = FilePath(cpath);
   else
-    result = FilePath("@PREFIX@/lib/chromium/chrome");
+    result = FilePath("@PREFIX@/lib/@PKGBASE@/electron");
 
   if (sysctl(mib, std::size(mib), NULL, &len, NULL, 0) != -1) {
     retvalargs = static_cast<char**>(malloc(len));
diff --git a/build/config/ozone.gni b/build/config/ozone.gni
index 4cb5ff43ac..455b0d518a 100644
--- a/build/config/ozone.gni
+++ b/build/config/ozone.gni
@@ -96,6 +96,10 @@ declare_args() {
       ozone_platform = "x11"
       ozone_platform_wayland = false
       ozone_platform_x11 = true
+    } else if (is_netbsd) {
+      ozone_platform = "x11"
+      ozone_platform_wayland = false
+      ozone_platform_x11 = true
     } else if (is_freebsd) {
       ozone_platform = "x11"
       ozone_platform_wayland = true
diff --git a/build/rust/allocator/BUILD.gn b/build/rust/allocator/BUILD.gn
new file mode 100644
index 0000000000..ba3d32618c
--- /dev/null
+++ b/build/rust/allocator/BUILD.gn
@@ -0,0 +1,106 @@
+# Copyright 2025 The Chromium Authors
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/buildflag_header.gni")
+import("//build/config/rust.gni")
+import("//build/rust/rust_static_library.gni")
+
+rust_allocator_uses_partition_alloc = false
+if (build_with_chromium) {
+  import("//base/allocator/partition_allocator/partition_alloc.gni")
+  rust_allocator_uses_partition_alloc = use_partition_alloc_as_malloc
+}
+
+# In ASAN builds, PartitionAlloc-Everywhere is disabled, meaning malloc() and
+# friends in C++ do not go to PartitionAlloc. So we also don't point the Rust
+# allocation functions at PartitionAlloc. Generally, this means we just direct
+# them to the Standard Library's allocator.
+#
+# However, on Windows the Standard Library uses HeapAlloc() and Windows ASAN
+# does *not* hook that method, so ASAN does not get to hear about allocations
+# made in Rust. To resolve this, we redirect allocation to _aligned_malloc
+# which Windows ASAN *does* hook.
+#
+# Note that there is a runtime option to make ASAN hook HeapAlloc() but
+# enabling it breaks Win32 APIs like CreateProcess:
+# https://crbug.com/368070343#comment29
+rust_allocator_uses_aligned_malloc = false
+if (!rust_allocator_uses_partition_alloc && is_win && is_asan) {
+  rust_allocator_uses_aligned_malloc = true
+}
+
+rust_allocator_uses_allocator_impls_h =
+    rust_allocator_uses_partition_alloc || rust_allocator_uses_aligned_malloc
+
+buildflag_header("buildflags") {
+  header = "buildflags.h"
+  flags = [
+    "RUST_ALLOCATOR_USES_PARTITION_ALLOC=$rust_allocator_uses_partition_alloc",
+    "RUST_ALLOCATOR_USES_ALIGNED_MALLOC=$rust_allocator_uses_aligned_malloc",
+  ]
+  visibility = [ ":*" ]
+}
+
+if (toolchain_has_rust) {
+  # All targets which depend on Rust code but are not linked by rustc must
+  # depend on this. Usually, this dependency will come from the rust_target() GN
+  # template. However, cargo_crate() does *not* include this dependency so any
+  # C++ targets which directly depend on a cargo_crate() must depend on this.
+  rust_static_library("allocator") {
+    sources = [ "lib.rs" ]
+    crate_root = "lib.rs"
+    cxx_bindings = [ "lib.rs" ]
+
+    deps = [ ":alloc_error_handler_impl" ]
+    if (rust_allocator_uses_allocator_impls_h) {
+      deps += [ ":allocator_impls" ]
+    }
+
+    no_chromium_prelude = true
+    no_allocator_crate = true
+    allow_unsafe = true
+
+    rustflags = []
+    if (rust_allocator_uses_allocator_impls_h) {
+      rustflags += [ "--cfg=rust_allocator_uses_allocator_impls_h" ]
+      cxx_bindings += [ "allocator_impls_ffi.rs" ]
+      sources += [ "allocator_impls_ffi.rs" ]
+    }
+
+    # TODO(https://crbug.com/410596442): Stop using unstable features here.
+    configs -= [ "//build/config/compiler:disallow_unstable_features" ]
+  }
+
+  if (rust_allocator_uses_allocator_impls_h) {
+    static_library("allocator_impls") {
+      public_deps = []
+      if (rust_allocator_uses_partition_alloc) {
+        public_deps +=
+            [ "//base/allocator/partition_allocator:partition_alloc" ]
+      }
+
+      sources = [
+        "allocator_impls.cc",
+        "allocator_impls.h",
+      ]
+      deps = [ ":buildflags" ]
+      visibility = [ ":*" ]
+    }
+  }
+
+  static_library("alloc_error_handler_impl") {
+    sources = [
+      # `alias.*`, `compiler_specific.h`, and `immediate_crash.*` have been
+      # copied from `//base`.
+      # TODO(crbug.com/40279749): Avoid duplication / reuse code.
+      "alias.cc",
+      "alias.h",
+      "alloc_error_handler_impl.cc",
+      "alloc_error_handler_impl.h",
+      "compiler_specific.h",
+      "immediate_crash.h",
+    ]
+    visibility = [ ":*" ]
+  }
+}
diff --git a/build/rust/allocator/DEPS b/build/rust/allocator/DEPS
new file mode 100644
index 0000000000..923a2e07c8
--- /dev/null
+++ b/build/rust/allocator/DEPS
@@ -0,0 +1,9 @@
+include_rules = [
+  "-base",
+]
+
+specific_include_rules = {
+  "allocator_impls.cc" : [
+    "+partition_alloc"
+  ]
+}
diff --git a/build/rust/allocator/alias.cc b/build/rust/allocator/alias.cc
new file mode 100644
index 0000000000..ca20986f8e
--- /dev/null
+++ b/build/rust/allocator/alias.cc
@@ -0,0 +1,22 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// This file has been copied from //base/debug/alias.cc ( additionally the APIs
+// were moved into the `build_rust_std` namespace).
+//
+// TODO(crbug.com/40279749): Avoid code duplication / reuse code.
+
+#include "build/rust/allocator/alias.h"
+
+#include "build/rust/allocator/compiler_specific.h"
+
+namespace build_rust_std {
+namespace debug {
+
+// This file/function should be excluded from LTO/LTCG to ensure that the
+// compiler can't see this function's implementation when compiling calls to it.
+NOINLINE void Alias(const void* var) {}
+
+}  // namespace debug
+}  // namespace build_rust_std
diff --git a/build/rust/allocator/alias.h b/build/rust/allocator/alias.h
new file mode 100644
index 0000000000..80995ecfb0
--- /dev/null
+++ b/build/rust/allocator/alias.h
@@ -0,0 +1,37 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// This file has been copied from //base/debug/alias.h (and then trimmed to just
+// the APIs / macros needed by //build/rust/std;  additionally the APIs were
+// moved into the `build_rust_std` namespace).
+//
+// TODO(crbug.com/40279749): Avoid code duplication / reuse code.
+
+#ifndef BUILD_RUST_ALLOCATOR_ALIAS_H_
+#define BUILD_RUST_ALLOCATOR_ALIAS_H_
+
+#include <stddef.h>
+
+namespace build_rust_std {
+namespace debug {
+
+// Make the optimizer think that |var| is aliased. This can be used to prevent a
+// local variable from being optimized out (which is something that
+// `NO_CODE_FOLDING` macro definition below depends on).  See
+// //base/debug/alias.h for more details.
+void Alias(const void* var);
+
+}  // namespace debug
+
+}  // namespace build_rust_std
+
+// Prevent code folding (where a linker identifies functions that are
+// bit-identical and overlays them, which saves space but it leads to confusing
+// call stacks because multiple symbols are at the same address).  See
+// //base/debug/alias.h for more details.
+#define NO_CODE_FOLDING()           \
+  const int line_number = __LINE__; \
+  build_rust_std::debug::Alias(&line_number)
+
+#endif  // BUILD_RUST_ALLOCATOR_ALIAS_H_
diff --git a/build/rust/allocator/alloc_error_handler_impl.cc b/build/rust/allocator/alloc_error_handler_impl.cc
new file mode 100644
index 0000000000..6373efd356
--- /dev/null
+++ b/build/rust/allocator/alloc_error_handler_impl.cc
@@ -0,0 +1,17 @@
+// Copyright 2025 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "build/rust/allocator/alloc_error_handler_impl.h"
+
+#include "build/rust/allocator/alias.h"
+#include "build/rust/allocator/immediate_crash.h"
+
+namespace rust_allocator_internal {
+
+void alloc_error_handler_impl() {
+  NO_CODE_FOLDING();
+  IMMEDIATE_CRASH();
+}
+
+}  // namespace rust_allocator_internal
diff --git a/build/rust/allocator/alloc_error_handler_impl.h b/build/rust/allocator/alloc_error_handler_impl.h
new file mode 100644
index 0000000000..d4af2eb3d6
--- /dev/null
+++ b/build/rust/allocator/alloc_error_handler_impl.h
@@ -0,0 +1,21 @@
+// Copyright 2025 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BUILD_RUST_ALLOCATOR_ALLOC_ERROR_HANDLER_IMPL_H_
+#define BUILD_RUST_ALLOCATOR_ALLOC_ERROR_HANDLER_IMPL_H_
+
+// This header exposes to Rust a C++ implementation of quickly crashing after an
+// allocation error.  (The API below is called from `__rust_alloc_error_handler`
+// in `lib.rs`.)
+//
+// TODO(lukasza): Investigate if we can delete this `.h` / `.cc` and just call
+// `std::process::abort()` (or something else?) directly from `.rs`.  The main
+// open question is how much we care about `NO_CODE_FOLDING`.
+namespace rust_allocator_internal {
+
+void alloc_error_handler_impl();
+
+}  // namespace rust_allocator_internal
+
+#endif  // BUILD_RUST_ALLOCATOR_ALLOC_ERROR_HANDLER_IMPL_H_
diff --git a/build/rust/allocator/allocator_impls.cc b/build/rust/allocator/allocator_impls.cc
new file mode 100644
index 0000000000..a546f3af69
--- /dev/null
+++ b/build/rust/allocator/allocator_impls.cc
@@ -0,0 +1,105 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "build/rust/allocator/allocator_impls.h"
+
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
+#pragma allow_unsafe_libc_calls
+#endif
+
+#include <cstddef>
+#include <cstring>
+
+#include "build/build_config.h"
+#include "build/rust/allocator/buildflags.h"
+
+#if BUILDFLAG(RUST_ALLOCATOR_USES_PARTITION_ALLOC)
+#include "partition_alloc/partition_alloc_constants.h"  // nogncheck
+#include "partition_alloc/shim/allocator_shim.h"        // nogncheck
+#elif BUILDFLAG(RUST_ALLOCATOR_USES_ALIGNED_MALLOC)
+#include <cstdlib>
+#endif
+
+namespace rust_allocator_internal {
+
+unsigned char* alloc(size_t size, size_t align) {
+#if BUILDFLAG(RUST_ALLOCATOR_USES_PARTITION_ALLOC)
+  // PartitionAlloc will crash if given an alignment larger than this.
+  if (align > partition_alloc::internal::kMaxSupportedAlignment) {
+    return nullptr;
+  }
+
+  // We use unchecked allocation paths in PartitionAlloc rather than going
+  // through its shims in `malloc()` etc so that we can support fallible
+  // allocation paths such as Vec::try_reserve without crashing on allocation
+  // failure.
+  if (align <= alignof(std::max_align_t)) {
+    return static_cast<unsigned char*>(allocator_shim::UncheckedAlloc(size));
+  } else {
+    return static_cast<unsigned char*>(
+        allocator_shim::UncheckedAlignedAlloc(size, align));
+  }
+#elif BUILDFLAG(RUST_ALLOCATOR_USES_ALIGNED_MALLOC)
+  return static_cast<unsigned char*>(_aligned_malloc(size, align));
+#else
+#error This configuration is not supported.
+#endif
+}
+
+void dealloc(unsigned char* p, size_t size, size_t align) {
+#if BUILDFLAG(RUST_ALLOCATOR_USES_PARTITION_ALLOC)
+  if (align <= alignof(std::max_align_t)) {
+    allocator_shim::UncheckedFree(p);
+  } else {
+    allocator_shim::UncheckedAlignedFree(p);
+  }
+#elif BUILDFLAG(RUST_ALLOCATOR_USES_ALIGNED_MALLOC)
+  return _aligned_free(p);
+#else
+#error This configuration is not supported.
+#endif
+}
+
+unsigned char* realloc(unsigned char* p,
+                       size_t old_size,
+                       size_t align,
+                       size_t new_size) {
+#if BUILDFLAG(RUST_ALLOCATOR_USES_PARTITION_ALLOC)
+  // We use unchecked allocation paths in PartitionAlloc rather than going
+  // through its shims in `malloc()` etc so that we can support fallible
+  // allocation paths such as Vec::try_reserve without crashing on allocation
+  // failure.
+  if (align <= alignof(std::max_align_t)) {
+    return static_cast<unsigned char*>(
+        allocator_shim::UncheckedRealloc(p, new_size));
+  } else {
+    return static_cast<unsigned char*>(
+        allocator_shim::UncheckedAlignedRealloc(p, new_size, align));
+  }
+#elif BUILDFLAG(RUST_ALLOCATOR_USES_ALIGNED_MALLOC)
+  return static_cast<unsigned char*>(_aligned_realloc(p, new_size, align));
+#else
+#error This configuration is not supported.
+#endif
+}
+
+unsigned char* alloc_zeroed(size_t size, size_t align) {
+#if BUILDFLAG(RUST_ALLOCATOR_USES_PARTITION_ALLOC) || \
+    BUILDFLAG(RUST_ALLOCATOR_USES_ALIGNED_MALLOC)
+  // TODO(danakj): When RUST_ALLOCATOR_USES_PARTITION_ALLOC is true, it's
+  // possible that a partition_alloc::UncheckedAllocZeroed() call would perform
+  // better than partition_alloc::UncheckedAlloc() + memset. But there is no
+  // such API today. See b/342251590.
+  unsigned char* p = alloc(size, align);
+  if (p) {
+    memset(p, 0, size);
+  }
+  return p;
+#else
+#error This configuration is not supported.
+#endif
+}
+
+}  // namespace rust_allocator_internal
diff --git a/build/rust/allocator/allocator_impls.h b/build/rust/allocator/allocator_impls.h
new file mode 100644
index 0000000000..3ccd5f07a6
--- /dev/null
+++ b/build/rust/allocator/allocator_impls.h
@@ -0,0 +1,24 @@
+// Copyright 2025 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef BUILD_RUST_ALLOCATOR_ALLOCATOR_IMPLS_H_
+#define BUILD_RUST_ALLOCATOR_ALLOCATOR_IMPLS_H_
+
+#include <cstddef>
+
+// This header exposes a C++ allocator (e.g. PartitionAlloc) to Rust.
+// The APIs below are called from `impl GlobalAlloc` in `lib.rs`.
+namespace rust_allocator_internal {
+
+unsigned char* alloc(size_t size, size_t align);
+void dealloc(unsigned char* p, size_t size, size_t align);
+unsigned char* realloc(unsigned char* p,
+                       size_t old_size,
+                       size_t align,
+                       size_t new_size);
+unsigned char* alloc_zeroed(size_t size, size_t align);
+
+}  // namespace rust_allocator_internal
+
+#endif  // BUILD_RUST_ALLOCATOR_ALLOCATOR_IMPLS_H_
diff --git a/build/rust/allocator/allocator_impls_ffi.rs b/build/rust/allocator/allocator_impls_ffi.rs
new file mode 100644
index 0000000000..3b5e2220a2
--- /dev/null
+++ b/build/rust/allocator/allocator_impls_ffi.rs
@@ -0,0 +1,19 @@
+// Copyright 2025 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+//! FFI for `allocator_impls.h` is in a separate `.rs` file/module to
+//! better support conditional compilation (these functions are only
+//! used under `#[cfg(rust_allocator_uses_allocator_impls_h)]`.
+
+#[cxx::bridge(namespace = "rust_allocator_internal")]
+pub mod ffi {
+    extern "C++" {
+        include!("build/rust/allocator/allocator_impls.h");
+
+        unsafe fn alloc(size: usize, align: usize) -> *mut u8;
+        unsafe fn dealloc(p: *mut u8, size: usize, align: usize);
+        unsafe fn realloc(p: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;
+        unsafe fn alloc_zeroed(size: usize, align: usize) -> *mut u8;
+    }
+}
diff --git a/build/rust/allocator/compiler_specific.h b/build/rust/allocator/compiler_specific.h
new file mode 100644
index 0000000000..f9079679a3
--- /dev/null
+++ b/build/rust/allocator/compiler_specific.h
@@ -0,0 +1,38 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// This file has been copied from //base/compiler_specific.h (and then
+// significantly trimmed to just the APIs / macros needed by //build/rust/std).
+//
+// TODO(crbug.com/40279749): Avoid code duplication / reuse code.
+
+#ifndef BUILD_RUST_ALLOCATOR_COMPILER_SPECIFIC_H_
+#define BUILD_RUST_ALLOCATOR_COMPILER_SPECIFIC_H_
+
+#include "build/build_config.h"
+
+#if defined(COMPILER_MSVC) && !defined(__clang__)
+#error "Only clang-cl is supported on Windows, see https://crbug.com/988071"
+#endif
+
+#if defined(__has_attribute)
+#define HAS_ATTRIBUTE(x) __has_attribute(x)
+#else
+#define HAS_ATTRIBUTE(x) 0
+#endif
+
+// Annotate a function indicating it should not be inlined.
+// Use like:
+//   NOINLINE void DoStuff() { ... }
+#if defined(__clang__) && HAS_ATTRIBUTE(noinline)
+#define NOINLINE [[clang::noinline]]
+#elif defined(COMPILER_GCC) && HAS_ATTRIBUTE(noinline)
+#define NOINLINE __attribute__((noinline))
+#elif defined(COMPILER_MSVC)
+#define NOINLINE __declspec(noinline)
+#else
+#define NOINLINE
+#endif
+
+#endif  // BUILD_RUST_ALLOCATOR_COMPILER_SPECIFIC_H_
diff --git a/build/rust/allocator/immediate_crash.h b/build/rust/allocator/immediate_crash.h
new file mode 100644
index 0000000000..9cbf9fd65f
--- /dev/null
+++ b/build/rust/allocator/immediate_crash.h
@@ -0,0 +1,171 @@
+// Copyright 2021 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// This file has been copied from //base/immediate_crash.h.
+// TODO(crbug.com/40279749): Avoid code duplication / reuse code.
+
+#ifndef BUILD_RUST_ALLOCATOR_IMMEDIATE_CRASH_H_
+#define BUILD_RUST_ALLOCATOR_IMMEDIATE_CRASH_H_
+
+#include "build/build_config.h"
+
+// Crashes in the fastest possible way with no attempt at logging.
+// There are several constraints; see http://crbug.com/664209 for more context.
+//
+// - TRAP_SEQUENCE_() must be fatal. It should not be possible to ignore the
+//   resulting exception or simply hit 'continue' to skip over it in a debugger.
+// - Different instances of TRAP_SEQUENCE_() must not be folded together, to
+//   ensure crash reports are debuggable. Unlike __builtin_trap(), asm volatile
+//   blocks will not be folded together.
+//   Note: TRAP_SEQUENCE_() previously required an instruction with a unique
+//   nonce since unlike clang, GCC folds together identical asm volatile
+//   blocks.
+// - TRAP_SEQUENCE_() must produce a signal that is distinct from an invalid
+//   memory access.
+// - TRAP_SEQUENCE_() must be treated as a set of noreturn instructions.
+//   __builtin_unreachable() is used to provide that hint here. clang also uses
+//   this as a heuristic to pack the instructions in the function epilogue to
+//   improve code density.
+//
+// Additional properties that are nice to have:
+// - TRAP_SEQUENCE_() should be as compact as possible.
+// - The first instruction of TRAP_SEQUENCE_() should not change, to avoid
+//   shifting crash reporting clusters. As a consequence of this, explicit
+//   assembly is preferred over intrinsics.
+//   Note: this last bullet point may no longer be true, and may be removed in
+//   the future.
+
+// Note: TRAP_SEQUENCE Is currently split into two macro helpers due to the fact
+// that clang emits an actual instruction for __builtin_unreachable() on certain
+// platforms (see https://crbug.com/958675). In addition, the int3/bkpt/brk will
+// be removed in followups, so splitting it up like this now makes it easy to
+// land the followups.
+
+#if defined(COMPILER_GCC)
+
+#if BUILDFLAG(IS_NACL)
+
+// Crash report accuracy is not guaranteed on NaCl.
+#define TRAP_SEQUENCE1_() __builtin_trap()
+#define TRAP_SEQUENCE2_() asm volatile("")
+
+#elif defined(ARCH_CPU_X86_FAMILY)
+
+// TODO(crbug.com/40625592): In theory, it should be possible to use just
+// int3. However, there are a number of crashes with SIGILL as the exception
+// code, so it seems likely that there's a signal handler that allows execution
+// to continue after SIGTRAP.
+#define TRAP_SEQUENCE1_() asm volatile("int3")
+
+#if BUILDFLAG(IS_APPLE)
+// Intentionally empty: __builtin_unreachable() is always part of the sequence
+// (see IMMEDIATE_CRASH below) and already emits a ud2 on Mac.
+#define TRAP_SEQUENCE2_() asm volatile("")
+#else
+#define TRAP_SEQUENCE2_() asm volatile("ud2")
+#endif  // BUILDFLAG(IS_APPLE)
+
+#elif defined(ARCH_CPU_ARMEL)
+
+// bkpt will generate a SIGBUS when running on armv7 and a SIGTRAP when running
+// as a 32 bit userspace app on arm64. There doesn't seem to be any way to
+// cause a SIGTRAP from userspace without using a syscall (which would be a
+// problem for sandboxing).
+// TODO(crbug.com/40625592): Remove bkpt from this sequence.
+#define TRAP_SEQUENCE1_() asm volatile("bkpt #0")
+#define TRAP_SEQUENCE2_() asm volatile("udf #0")
+
+#elif defined(ARCH_CPU_ARM64)
+
+// This will always generate a SIGTRAP on arm64.
+// TODO(crbug.com/40625592): Remove brk from this sequence.
+#define TRAP_SEQUENCE1_() asm volatile("brk #0")
+#define TRAP_SEQUENCE2_() asm volatile("hlt #0")
+
+#else
+
+// Crash report accuracy will not be guaranteed on other architectures, but at
+// least this will crash as expected.
+#define TRAP_SEQUENCE1_() __builtin_trap()
+#define TRAP_SEQUENCE2_() asm volatile("")
+
+#endif  // ARCH_CPU_*
+
+#elif defined(COMPILER_MSVC)
+
+#if !defined(__clang__)
+
+// MSVC x64 doesn't support inline asm, so use the MSVC intrinsic.
+#define TRAP_SEQUENCE1_() __debugbreak()
+#define TRAP_SEQUENCE2_()
+
+#elif defined(ARCH_CPU_ARM64)
+
+// Windows ARM64 uses "BRK #F000" as its breakpoint instruction, and
+// __debugbreak() generates that in both VC++ and clang.
+#define TRAP_SEQUENCE1_() __debugbreak()
+// Intentionally empty: __builtin_unreachable() is always part of the sequence
+// (see IMMEDIATE_CRASH below) and already emits a ud2 on Win64,
+// https://crbug.com/958373
+#define TRAP_SEQUENCE2_() __asm volatile("")
+
+#else
+
+#define TRAP_SEQUENCE1_() asm volatile("int3")
+#define TRAP_SEQUENCE2_() asm volatile("ud2")
+
+#endif  // __clang__
+
+#else
+
+#error No supported trap sequence!
+
+#endif  // COMPILER_GCC
+
+#define TRAP_SEQUENCE_() \
+  do {                   \
+    TRAP_SEQUENCE1_();   \
+    TRAP_SEQUENCE2_();   \
+  } while (false)
+
+// CHECK() and the trap sequence can be invoked from a constexpr function.
+// This could make compilation fail on GCC, as it forbids directly using inline
+// asm inside a constexpr function. However, it allows calling a lambda
+// expression including the same asm.
+// The side effect is that the top of the stacktrace will not point to the
+// calling function, but to this anonymous lambda. This is still useful as the
+// full name of the lambda will typically include the name of the function that
+// calls CHECK() and the debugger will still break at the right line of code.
+#if !defined(COMPILER_GCC) || defined(__clang__)
+
+#define WRAPPED_TRAP_SEQUENCE_() TRAP_SEQUENCE_()
+
+#else
+
+#define WRAPPED_TRAP_SEQUENCE_() \
+  do {                           \
+    [] { TRAP_SEQUENCE_(); }();  \
+  } while (false)
+
+#endif  // !defined(COMPILER_GCC) || defined(__clang__)
+
+#if defined(__clang__) || defined(COMPILER_GCC)
+
+// __builtin_unreachable() hints to the compiler that this is noreturn and can
+// be packed in the function epilogue.
+#define IMMEDIATE_CRASH()     \
+  ({                          \
+    WRAPPED_TRAP_SEQUENCE_(); \
+    __builtin_unreachable();  \
+  })
+
+#else
+
+// This is supporting non-chromium user of logging.h to build with MSVC, like
+// pdfium. On MSVC there is no __builtin_unreachable().
+#define IMMEDIATE_CRASH() WRAPPED_TRAP_SEQUENCE_()
+
+#endif  // defined(__clang__) || defined(COMPILER_GCC)
+
+#endif  // BUILD_RUST_ALLOCATOR_IMMEDIATE_CRASH_H_
diff --git a/build/rust/allocator/lib.rs b/build/rust/allocator/lib.rs
new file mode 100644
index 0000000000..e61671f6ed
--- /dev/null
+++ b/build/rust/allocator/lib.rs
@@ -0,0 +1,119 @@
+// Copyright 2025 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+//! Define the allocator that Rust code in Chrome should use.
+//!
+//! Any final artifact that depends on this crate, even transitively, will use
+//! the allocator defined here.
+//!
+//! List of known issues:
+//!
+//! 1. We'd like to use PartitionAlloc on Windows, but the stdlib uses Windows
+//!    heap functions directly that PartitionAlloc can not intercept.
+//! 2. We'd like `Vec::try_reserve` to fail at runtime on Linux instead of
+//!    crashing in malloc() where PartitionAlloc replaces that function.
+
+// Required to apply weak linkage to symbols.
+//
+// TODO(https://crbug.com/410596442): Stop using unstable features here.
+// https://github.com/rust-lang/rust/issues/29603 tracks stabilization of the `linkage` feature.
+#![feature(linkage)]
+// Required to apply `#[rustc_std_internal_symbol]` to our alloc error handler
+// so the name is correctly mangled as rustc expects.
+//
+// TODO(https://crbug.com/410596442): Stop using internal features here.
+#![allow(internal_features)]
+#![feature(rustc_attrs)]
+
+// This module is in a separate source file to avoid having to teach `cxxbridge`
+// about conditional compilation.
+#[cfg(rust_allocator_uses_allocator_impls_h)]
+mod allocator_impls_ffi;
+
+/// Module that provides `#[global_allocator]` / `GlobalAlloc` interface for
+/// using an allocator from C++.
+#[cfg(rust_allocator_uses_allocator_impls_h)]
+mod cpp_allocator {
+    use super::allocator_impls_ffi::ffi;
+    use std::alloc::{GlobalAlloc, Layout};
+
+    struct Allocator;
+
+    unsafe impl GlobalAlloc for Allocator {
+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
+            unsafe { ffi::alloc(layout.size(), layout.align()) }
+        }
+
+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
+            unsafe {
+                ffi::dealloc(ptr, layout.size(), layout.align());
+            }
+        }
+
+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
+            unsafe { ffi::alloc_zeroed(layout.size(), layout.align()) }
+        }
+
+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
+            unsafe { ffi::realloc(ptr, layout.size(), layout.align(), new_size) }
+        }
+    }
+
+    #[global_allocator]
+    static GLOBAL: Allocator = Allocator;
+}
+
+/// Module that provides `#[global_allocator]` / `GlobalAlloc` interface for
+/// using the default Rust allocator.
+#[cfg(not(rust_allocator_uses_allocator_impls_h))]
+mod rust_allocator {
+    #[global_allocator]
+    static GLOBAL: std::alloc::System = std::alloc::System;
+}
+
+/// Module that provides global symbols that are needed both by `cpp_allocator`
+/// and `rust_allocator`.
+///
+/// When `rustc` drives linking, then it will define the symbols below.  But
+/// Chromium only uses `rustc` to link Rust-only executables (e.g. `build.rs`
+/// scripts) and otherwise uses a non-Rust linker.  This is why we have to
+/// manually define a few symbols below.  We define those symbols
+/// as "weak" symbols, so that Rust-provided symbols "win" in case where Rust
+/// actually does drive the linking.  This hack works (not only for Chromium,
+/// but also for google3 and other projects), but isn't officially supported by
+/// `rustc`.
+///
+/// TODO(https://crbug.com/410596442): Stop using internal features here.
+mod both_allocators {
+    /// As part of rustc's contract for using `#[global_allocator]` without
+    /// rustc-generated shims we must define this symbol, since we are opting in
+    /// to unstable functionality. See https://github.com/rust-lang/rust/issues/123015
+    #[no_mangle]
+    #[linkage = "weak"]
+    static __rust_no_alloc_shim_is_unstable: u8 = 0;
+
+    // Mangle the symbol name as rustc expects.
+    #[rustc_std_internal_symbol]
+    #[allow(non_upper_case_globals)]
+    #[linkage = "weak"]
+    static __rust_alloc_error_handler_should_panic: u8 = 0;
+
+    // Mangle the symbol name as rustc expects.
+    #[rustc_std_internal_symbol]
+    #[allow(non_upper_case_globals)]
+    #[linkage = "weak"]
+    fn __rust_alloc_error_handler(_size: usize, _align: usize) {
+        // TODO(lukasza): Investigate if we can just call `std::process::abort()` here.
+        // (Not really _needed_, but it could simplify code a little bit.)
+        unsafe { ffi::alloc_error_handler_impl() }
+    }
+
+    #[cxx::bridge(namespace = "rust_allocator_internal")]
+    mod ffi {
+        extern "C++" {
+            include!("build/rust/allocator/alloc_error_handler_impl.h");
+            unsafe fn alloc_error_handler_impl();
+        }
+    }
+}
diff --git a/build/rust/cargo_crate.gni b/build/rust/cargo_crate.gni
index 8266c44cbd..d69e29874d 100644
--- a/build/rust/cargo_crate.gni
+++ b/build/rust/cargo_crate.gni
@@ -267,6 +267,12 @@ template("cargo_crate") {
     # Don't import the `chromium` crate into third-party code.
     no_chromium_prelude = true
 
+    # Don't depend on the chrome-specific #[global_allocator] crate from
+    # third-party code. This avoids some dependency cycle issues. The allocator
+    # crate will still be used if it exists anywhere in the dependency graph for
+    # a given linked artifact.
+    no_allocator_crate = true
+
     rustc_metadata = _rustc_metadata
 
     # TODO(crbug.com/40259764): don't default to true. This requires changes to
@@ -505,6 +511,9 @@ template("cargo_crate") {
         # Don't import the `chromium` crate into third-party code.
         no_chromium_prelude = true
 
+        # Build scripts do not need to link to chrome's allocator.
+        no_allocator_crate = true
+
         # The ${_build_script_name}_output target looks for the exe in this
         # location. Due to how the Windows component build works, this has to
         # be $root_out_dir for all EXEs. In component build, C++ links to the
diff --git a/build/rust/rust_macro.gni b/build/rust/rust_macro.gni
index bcbb30ed44..41d857632c 100644
--- a/build/rust/rust_macro.gni
+++ b/build/rust/rust_macro.gni
@@ -16,6 +16,9 @@ template("rust_macro") {
     forward_variables_from(invoker, TESTONLY_AND_VISIBILITY)
     proc_macro_configs = invoker.configs
     target_type = "rust_proc_macro"
+
+    # Macros are loaded by rustc and shouldn't use chrome's allocation routines.
+    no_allocator_crate = true
   }
 }
 
diff --git a/build/rust/rust_target.gni b/build/rust/rust_target.gni
index 1a2f96337d..1003a7b678 100644
--- a/build/rust/rust_target.gni
+++ b/build/rust/rust_target.gni
@@ -339,6 +339,10 @@ template("rust_target") {
       _rust_deps += [ "//build/rust/std" ]
     }
 
+    if (!defined(invoker.no_allocator_crate) || !invoker.no_allocator_crate) {
+      _rust_deps += [ "//build/rust/allocator" ]
+    }
+
     if (_build_unit_tests) {
       _unit_test_target = "${_target_name}_unittests"
       if (defined(invoker.unit_test_target)) {
diff --git a/build/rust/std/BUILD.gn b/build/rust/std/BUILD.gn
index b5f5291283..1b94e18745 100644
--- a/build/rust/std/BUILD.gn
+++ b/build/rust/std/BUILD.gn
@@ -22,29 +22,6 @@ import("//build/config/rust.gni")
 import("//build/config/sanitizers/sanitizers.gni")
 
 if (toolchain_has_rust) {
-  # If clang performs the link step, we need to provide the allocator symbols
-  # that are normally injected by rustc during linking.
-  #
-  # We also "happen to" use this to redirect allocations to PartitionAlloc,
-  # though that would be better done through a #[global_allocator] crate (see
-  # above).
-  source_set("remap_alloc") {
-    public_deps = [ "//base/allocator/partition_allocator:buildflags" ]
-    if (use_partition_alloc_as_malloc) {
-      public_deps += [ "//base/allocator/partition_allocator:partition_alloc" ]
-    }
-    sources = [
-      # `alias.*`, `compiler_specific.h`, and `immediate_crash.*` have been
-      # copied from `//base`.
-      # TODO(crbug.com/40279749): Avoid duplication / reuse code.
-      "alias.cc",
-      "alias.h",
-      "compiler_specific.h",
-      "immediate_crash.h",
-      "remap_alloc.cc",
-    ]
-  }
-
   # List of Rust stdlib rlibs which are present in the official Rust toolchain
   # we are using from the Android team. This is usually a version or two behind
   # nightly. Generally this matches the toolchain we build ourselves, but if
@@ -74,13 +51,20 @@ if (toolchain_has_rust) {
     # These are no longer present in the Windows toolchain.
     stdlib_files += [
       "addr2line",
-      "adler",
       "gimli",
       "libc",
       "memchr",
       "miniz_oxide",
       "object",
     ]
+
+    rust_revision_pieces = string_split(rustc_revision, " ")
+    rust_version_pieces = string_split(rust_revision_pieces[1], ".")
+    if (rust_version_pieces[1] == "85") {
+      stdlib_files += [ "adler" ]
+    } else {
+      stdlib_files += [ "adler2" ]
+    }
   }
 
   if (toolchain_for_rust_host_build_tools) {
@@ -253,8 +237,6 @@ if (toolchain_has_rust) {
       foreach(libname, stdlib_files + skip_stdlib_files) {
         deps += [ "rules:$libname" ]
       }
-
-      public_deps = [ ":remap_alloc" ]
     }
   } else {
     action("find_stdlib") {
@@ -380,12 +362,6 @@ if (toolchain_has_rust) {
         ":stdlib_public_dependent_libs",
       ]
       deps = [ ":prebuilt_rustc_copy_to_sysroot" ]
-
-      # The host builds tools toolchain supports Rust only and does not use
-      # the allocator remapping to point it to PartitionAlloc.
-      if (!toolchain_for_rust_host_build_tools) {
-        deps += [ ":remap_alloc" ]
-      }
     }
   }
 }
diff --git a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
index 4b0140f611..07fe508e45 100644
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
@@ -251,128 +251,10 @@ bool MaybeIsLocalUNCPath(const base::FilePath& path) {
 }
 #endif
 
-// Sentinel used to indicate that no PathService key is specified for a path in
-// the struct below.
-constexpr const int kNoBasePathKey = -1;
-
-enum BlockType {
-  kBlockAllChildren,
-  kBlockNestedDirectories,
-  kDontBlockChildren
-};
-
-const struct {
-  // base::BasePathKey value (or one of the platform specific extensions to it)
-  // for a path that should be blocked. Specify kNoBasePathKey if |path| should
-  // be used instead.
-  int base_path_key;
-
-  // Explicit path to block instead of using |base_path_key|. Set to nullptr to
-  // use |base_path_key| on its own. If both |base_path_key| and |path| are set,
-  // |path| is treated relative to the path |base_path_key| resolves to.
-  const base::FilePath::CharType* path;
-
-  // If this is set to kDontBlockChildren, only the given path and its parents
-  // are blocked. If this is set to kBlockAllChildren, all children of the given
-  // path are blocked as well. Finally if this is set to kBlockNestedDirectories
-  // access is allowed to individual files in the directory, but nested
-  // directories are still blocked.
-  // The BlockType of the nearest ancestor of a path to check is what ultimately
-  // determines if a path is blocked or not. If a blocked path is a descendent
-  // of another blocked path, then it may override the child-blocking policy of
-  // its ancestor. For example, if /home blocks all children, but
-  // /home/downloads does not, then /home/downloads/file.ext will *not* be
-  // blocked.
-  BlockType type;
-} kBlockedPaths[] = {
-    // Don't allow users to share their entire home directory, entire desktop or
-    // entire documents folder, but do allow sharing anything inside those
-    // directories not otherwise blocked.
-    {base::DIR_HOME, nullptr, kDontBlockChildren},
-    {base::DIR_USER_DESKTOP, nullptr, kDontBlockChildren},
-    {chrome::DIR_USER_DOCUMENTS, nullptr, kDontBlockChildren},
-    // Similar restrictions for the downloads directory.
-    {chrome::DIR_DEFAULT_DOWNLOADS, nullptr, kDontBlockChildren},
-    {chrome::DIR_DEFAULT_DOWNLOADS_SAFE, nullptr, kDontBlockChildren},
-    // The Chrome installation itself should not be modified by the web.
-    {base::DIR_EXE, nullptr, kBlockAllChildren},
-    {base::DIR_MODULE, nullptr, kBlockAllChildren},
-    {base::DIR_ASSETS, nullptr, kBlockAllChildren},
-    // And neither should the configuration of at least the currently running
-    // Chrome instance (note that this does not take --user-data-dir command
-    // line overrides into account).
-    {chrome::DIR_USER_DATA, nullptr, kBlockAllChildren},
-    // ~/.ssh is pretty sensitive on all platforms, so block access to that.
-    {base::DIR_HOME, FILE_PATH_LITERAL(".ssh"), kBlockAllChildren},
-    // And limit access to ~/.gnupg as well.
-    {base::DIR_HOME, FILE_PATH_LITERAL(".gnupg"), kBlockAllChildren},
-#if BUILDFLAG(IS_WIN)
-    // Some Windows specific directories to block, basically all apps, the
-    // operating system itself, as well as configuration data for apps.
-    {base::DIR_PROGRAM_FILES, nullptr, kBlockAllChildren},
-    {base::DIR_PROGRAM_FILESX86, nullptr, kBlockAllChildren},
-    {base::DIR_PROGRAM_FILES6432, nullptr, kBlockAllChildren},
-    {base::DIR_WINDOWS, nullptr, kBlockAllChildren},
-    {base::DIR_ROAMING_APP_DATA, nullptr, kBlockAllChildren},
-    {base::DIR_LOCAL_APP_DATA, nullptr, kBlockAllChildren},
-    {base::DIR_COMMON_APP_DATA, nullptr, kBlockAllChildren},
-    // Opening a file from an MTP device, such as a smartphone or a camera, is
-    // implemented by Windows as opening a file in the temporary internet files
-    // directory. To support that, allow opening files in that directory, but
-    // not whole directories.
-    {base::DIR_IE_INTERNET_CACHE, nullptr, kBlockNestedDirectories},
-#endif
-#if BUILDFLAG(IS_MAC)
-    // Similar Mac specific blocks.
-    {base::DIR_APP_DATA, nullptr, kBlockAllChildren},
-    // Block access to the current bundle directory.
-    {chrome::DIR_OUTER_BUNDLE, nullptr, kBlockAllChildren},
-    // Block access to the user's Applications directory.
-    {base::DIR_HOME, FILE_PATH_LITERAL("Applications"), kBlockAllChildren},
-    // Block access to the root Applications directory.
-    {kNoBasePathKey, FILE_PATH_LITERAL("/Applications"), kBlockAllChildren},
-    {base::DIR_HOME, FILE_PATH_LITERAL("Library"), kBlockAllChildren},
-    // Allow access to other cloud files, such as Google Drive.
-    {base::DIR_HOME, FILE_PATH_LITERAL("Library/CloudStorage"),
-     kDontBlockChildren},
-    // Allow the site to interact with data from its corresponding natively
-    // installed (sandboxed) application. It would be nice to limit a site to
-    // access only _its_ corresponding natively installed application,
-    // but unfortunately there's no straightforward way to do that. See
-    // https://crbug.com/984641#c22.
-    {base::DIR_HOME, FILE_PATH_LITERAL("Library/Containers"),
-     kDontBlockChildren},
-    // Allow access to iCloud files...
-    {base::DIR_HOME, FILE_PATH_LITERAL("Library/Mobile Documents"),
-     kDontBlockChildren},
-    // ... which may also appear at this directory.
-    {base::DIR_HOME,
-     FILE_PATH_LITERAL("Library/Mobile Documents/com~apple~CloudDocs"),
-     kDontBlockChildren},
-#endif
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_BSD)
-    // On Linux also block access to devices via /dev.
-    {kNoBasePathKey, FILE_PATH_LITERAL("/dev"), kBlockAllChildren},
-    // And security sensitive data in /proc and /sys.
-    {kNoBasePathKey, FILE_PATH_LITERAL("/proc"), kBlockAllChildren},
-    {kNoBasePathKey, FILE_PATH_LITERAL("/sys"), kBlockAllChildren},
-    // And system files in /boot and /etc.
-    {kNoBasePathKey, FILE_PATH_LITERAL("/boot"), kBlockAllChildren},
-    {kNoBasePathKey, FILE_PATH_LITERAL("/etc"), kBlockAllChildren},
-    // And block all of ~/.config, matching the similar restrictions on mac
-    // and windows.
-    {base::DIR_HOME, FILE_PATH_LITERAL(".config"), kBlockAllChildren},
-    // Block ~/.dbus as well, just in case, although there probably isn't much a
-    // website can do with access to that directory and its contents.
-    {base::DIR_HOME, FILE_PATH_LITERAL(".dbus"), kBlockAllChildren},
-#endif
-#if BUILDFLAG(IS_ANDROID)
-    {base::DIR_ANDROID_APP_DATA, nullptr, kBlockAllChildren},
-    {base::DIR_CACHE, nullptr, kBlockAllChildren},
-#endif
-    // TODO(crbug.com/40095723): Refine this list, for example add
-    // XDG_CONFIG_HOME when it is not set ~/.config?
-};
+// This patch moves the deleted content from this file over to
+// chrome/browser/file_system_access/chrome_file_system_access_permission_context.h.
+// NOTE IF THERE IS A CONFLICT ABOVE, you will need to copy the changes in the
+// removed block over to chrome_file_system_access_permission_context.h.
 
 // Describes a rule for blocking a directory, which can be constructed
 // dynamically (based on state) or statically (from kBlockedPaths).
diff --git a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
index d46119d9a7..1ad3c41709 100644
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
@@ -439,7 +439,7 @@ class ChromeFileSystemAccessPermissionContext
        FILE_PATH_LITERAL("Library/Mobile Documents/com~apple~CloudDocs"),
        kDontBlockChildren},
   #endif
-  #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID)
+  #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_BSD)
       // On Linux also block access to devices via /dev.
       {kNoBasePathKey, FILE_PATH_LITERAL("/dev"), kBlockAllChildren},
       // And security sensitive data in /proc and /sys.
@@ -447,7 +447,7 @@ class ChromeFileSystemAccessPermissionContext
       {kNoBasePathKey, FILE_PATH_LITERAL("/sys"), kBlockAllChildren},
       // And system files in /boot and /etc.
       {kNoBasePathKey, FILE_PATH_LITERAL("/boot"), kBlockAllChildren},
-      {kNoBasePathKey, FILE_PATH_LITERAL("/etc"), kBlockAllChildren},
+      {kNoBasePathKey, FILE_PATH_LITERAL("@PKG_SYSCONFBASE@"), kBlockAllChildren},
       // And block all of ~/.config, matching the similar restrictions on mac
       // and windows.
       {base::DIR_HOME, FILE_PATH_LITERAL(".config"), kBlockAllChildren},
diff --git a/chrome/browser/process_singleton.h b/chrome/browser/process_singleton.h
index 81c41f4608..4305ba61d2 100644
--- a/chrome/browser/process_singleton.h
+++ b/chrome/browser/process_singleton.h
@@ -102,21 +102,24 @@ class ProcessSingleton {
   // should handle it (i.e., because the current process is shutting down).
   using NotificationCallback =
       base::RepeatingCallback<bool(base::CommandLine command_line,
-                                   const base::FilePath& current_directory)>;
+                                   const base::FilePath& current_directory,
+                                   const std::vector<uint8_t> additional_data)>;
 
 #if BUILDFLAG(IS_WIN)
   ProcessSingleton(const std::string& program_name,
                    const base::FilePath& user_data_dir,
+                   const base::raw_span<const uint8_t> additional_data,
                    bool is_sandboxed,
                    const NotificationCallback& notification_callback);
 #else
   ProcessSingleton(const base::FilePath& user_data_dir,
+                   const base::raw_span<const uint8_t> additional_data,
                    const NotificationCallback& notification_callback);
+#endif
 
   ProcessSingleton(const ProcessSingleton&) = delete;
   ProcessSingleton& operator=(const ProcessSingleton&) = delete;
 
-#endif
   ~ProcessSingleton();
 
   // Notify another process, if available. Otherwise sets ourselves as the
diff --git a/chrome/browser/process_singleton_posix.cc b/chrome/browser/process_singleton_posix.cc
index 871d526051..24da450f2b 100644
--- a/chrome/browser/process_singleton_posix.cc
+++ b/chrome/browser/process_singleton_posix.cc
@@ -104,7 +104,7 @@
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/resource/scoped_startup_resource_bundle.h"
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_BSD)
+#if 0
 #include "chrome/browser/ui/process_singleton_dialog_linux.h"
 #endif
 
diff --git a/chrome/browser/process_singleton_win.cc b/chrome/browser/process_singleton_win.cc
index dc4b352c93..255160d6bd 100644
--- a/chrome/browser/process_singleton_win.cc
+++ b/chrome/browser/process_singleton_win.cc
@@ -299,9 +299,11 @@ bool ProcessSingleton::EscapeVirtualization(
 ProcessSingleton::ProcessSingleton(
     const std::string& program_name,
     const base::FilePath& user_data_dir,
+    const base::raw_span<const uint8_t> additional_data,
     bool is_app_sandboxed,
     const NotificationCallback& notification_callback)
     : notification_callback_(notification_callback),
+      additional_data_(additional_data),
       program_name_(program_name),
       is_app_sandboxed_(is_app_sandboxed),
       is_virtualized_(false),
diff --git a/content/browser/child_process_launcher_helper_linux.cc b/content/browser/child_process_launcher_helper_linux.cc
index 471cf161c6..8760579d61 100644
--- a/content/browser/child_process_launcher_helper_linux.cc
+++ b/content/browser/child_process_launcher_helper_linux.cc
@@ -72,7 +72,25 @@ bool ChildProcessLauncherHelper::BeforeLaunchOnLauncherThread(
       options->fds_to_remap.emplace_back(sandbox_fd, GetSandboxFD());
     }
 
+    for (const auto& remapped_fd : file_data_->additional_remapped_fds) {
+      options->fds_to_remap.emplace_back(remapped_fd.second.get(),
+                                         remapped_fd.first);
+    }
+
+#if !BUILDFLAG(IS_BSD)
+    // (For Electron), if we're launching without zygote, that means we're
+    // launching an unsandboxed process (since all sandboxed processes are
+    // forked from the zygote). Relax the allow_new_privs option to permit
+    // launching suid processes from unsandboxed child processes.
+    if (!base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kNoZygote) &&
+        delegate_->GetZygote() == nullptr) {
+      options->allow_new_privs = true;
+    }
+#endif
+
+    options->current_directory = delegate_->GetCurrentDirectory();
     options->environment = delegate_->GetEnvironment();
+    options->clear_environment = !delegate_->ShouldInheritEnvironment();
   } else {
 #if !BUILDFLAG(IS_BSD)
     DCHECK(GetZygoteForLaunch());
diff --git a/electron/BUILD.gn b/electron/BUILD.gn
index f125cf662c..a7562fcd5e 100644
--- a/electron/BUILD.gn
+++ b/electron/BUILD.gn
@@ -529,7 +529,7 @@ source_set("electron_lib") {
     defines += [ "GDK_DISABLE_DEPRECATION_WARNINGS" ]
   }
 
-  if (!is_mas_build) {
+  if (!is_mas_build && !is_bsd) {
     deps += [
       "//components/crash/core/app",
       "//components/crash/core/browser",
@@ -622,6 +622,12 @@ source_set("electron_lib") {
       cflags_objcc = [ "-fobjc-weak" ]
     }
   }
+  if (is_bsd) {
+    sources -= [
+      "shell/common/crash_keys.cc",
+      "shell/common/crash_keys.h",
+    ]
+  }
   if (is_linux) {
     libs = [ "xshmfence" ]
     deps += [
@@ -1190,7 +1196,7 @@ if (is_mac) {
       ":electron_lib",
       ":electron_win32_resources",
       ":packed_resources",
-      "//components/crash/core/app",
+      # "//components/crash/core/app",
       "//content:sandbox_helper_win",
       "//electron/buildflags",
       "//ui/strings",
@@ -1216,7 +1222,7 @@ if (is_mac) {
       public_deps = [ "//tools/v8_context_snapshot:v8_context_snapshot" ]
     }
 
-    if (is_linux) {
+    if (is_linux && !is_bsd) {
       data_deps += [ "//components/crash/core/app:chrome_crashpad_handler" ]
     }
 
@@ -1283,7 +1289,7 @@ if (is_mac) {
         configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
       }
 
-      if (is_linux) {
+      if (is_linux && !is_bsd) {
         deps += [ "//sandbox/linux:chrome_sandbox" ]
       }
     }
@@ -1391,7 +1397,7 @@ dist_zip("electron_dist_zip") {
     ":electron_version_file",
     ":licenses",
   ]
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     data_deps += [ "//sandbox/linux:chrome_sandbox" ]
   }
   deps = data_deps
diff --git a/electron/build/args/all.gn b/electron/build/args/all.gn
index d982726bc3..816a1655aa 100644
--- a/electron/build/args/all.gn
+++ b/electron/build/args/all.gn
@@ -14,8 +14,8 @@ v8_enable_snapshot_native_code_counters = false
 v8_enable_javascript_promise_hooks = true
 
 enable_cdm_host_verification = false
-proprietary_codecs = true
-ffmpeg_branding = "Chrome"
+# proprietary_codecs = true
+# ffmpeg_branding = "Chrome"
 
 enable_printing = true
 
diff --git a/electron/build/args/release.gn b/electron/build/args/release.gn
index e5017f6e16..36a2c4bac0 100644
--- a/electron/build/args/release.gn
+++ b/electron/build/args/release.gn
@@ -7,7 +7,7 @@ is_official_build = true
 # explicitly override here to build OpenH264 encoder/FFmpeg decoder.
 # The initialization of the decoder depends on whether ffmpeg has
 # been built with H.264 support.
-rtc_use_h264 = proprietary_codecs
+# rtc_use_h264 = proprietary_codecs
 
 # By default, Electron builds ffmpeg with proprietary codecs enabled. In order
 # to facilitate users who don't want to ship proprietary codecs in ffmpeg, or
diff --git a/electron/default_app/default_app.ts b/electron/default_app/default_app.ts
index 6cd280bb55..f727995454 100644
--- a/electron/default_app/default_app.ts
+++ b/electron/default_app/default_app.ts
@@ -61,7 +61,7 @@ async function createWindow (backgroundColor?: string) {
     show: false
   };
 
-  if (process.platform === 'linux') {
+  if (process.platform === 'linux' || process.platform === 'freebsd'|| process.platform === 'netbsd') {
     options.icon = url.fileURLToPath(new URL('icon.png', import.meta.url));
   }
 
diff --git a/electron/filenames.gni b/electron/filenames.gni
index c4fc805d9d..de570bfddb 100644
--- a/electron/filenames.gni
+++ b/electron/filenames.gni
@@ -245,8 +245,8 @@ filenames = {
     "shell/app/command_line_args.h",
     "shell/app/electron_content_client.cc",
     "shell/app/electron_content_client.h",
-    "shell/app/electron_crash_reporter_client.cc",
-    "shell/app/electron_crash_reporter_client.h",
+    # "shell/app/electron_crash_reporter_client.cc",
+    # "shell/app/electron_crash_reporter_client.h",
     "shell/app/electron_main_delegate.cc",
     "shell/app/electron_main_delegate.h",
     "shell/app/node_main.cc",
diff --git a/electron/lib/browser/api/app.ts b/electron/lib/browser/api/app.ts
index ff024def5e..7ea549ec01 100644
--- a/electron/lib/browser/api/app.ts
+++ b/electron/lib/browser/api/app.ts
@@ -67,7 +67,7 @@ if (process.platform === 'darwin') {
   app.dock!.getMenu = () => dockMenu;
 }
 
-if (process.platform === 'linux') {
+if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
   const patternVmRSS = /^VmRSS:\s*(\d+) kB$/m;
   const patternVmHWM = /^VmHWM:\s*(\d+) kB$/m;
 
diff --git a/electron/lib/browser/api/dialog.ts b/electron/lib/browser/api/dialog.ts
index 04d95238c8..316fc69244 100644
--- a/electron/lib/browser/api/dialog.ts
+++ b/electron/lib/browser/api/dialog.ts
@@ -41,7 +41,7 @@ const normalizeAccessKey = (text: string) => {
   // existing single underscores with a second underscore, replace double
   // ampersands with a single ampersand, and replace a single ampersand with
   // a single underscore
-  if (process.platform === 'linux') {
+  if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
     return text.replaceAll('_', '__').replaceAll(/&(.?)/g, (match, after) => {
       if (after === '&') return after;
       return `_${after}`;
diff --git a/electron/lib/browser/api/menu-item-roles.ts b/electron/lib/browser/api/menu-item-roles.ts
index 1bb48b636e..a7d5617235 100644
--- a/electron/lib/browser/api/menu-item-roles.ts
+++ b/electron/lib/browser/api/menu-item-roles.ts
@@ -2,7 +2,7 @@ import { app, BaseWindow, BrowserWindow, session, webContents, WebContents, Menu
 
 const isMac = process.platform === 'darwin';
 const isWindows = process.platform === 'win32';
-const isLinux = process.platform === 'linux';
+const isLinux = (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd');
 
 type RoleId = 'about' | 'close' | 'copy' | 'cut' | 'delete' | 'forcereload' | 'front' | 'help' | 'hide' | 'hideothers' | 'minimize' |
   'paste' | 'pasteandmatchstyle' | 'quit' | 'redo' | 'reload' | 'resetzoom' | 'selectall' | 'services' | 'recentdocuments' | 'clearrecentdocuments' |
diff --git a/electron/lib/browser/api/power-monitor.ts b/electron/lib/browser/api/power-monitor.ts
index 4e07dd6a5b..30a57a9b98 100644
--- a/electron/lib/browser/api/power-monitor.ts
+++ b/electron/lib/browser/api/power-monitor.ts
@@ -17,7 +17,7 @@ class PowerMonitor extends EventEmitter implements Electron.PowerMonitor {
       const pm = createPowerMonitor();
       pm.emit = this.emit.bind(this);
 
-      if (process.platform === 'linux') {
+      if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
         // On Linux, we inhibit shutdown in order to give the app a chance to
         // decide whether or not it wants to prevent the shutdown. We don't
         // inhibit the shutdown event unless there's a listener for it. This
diff --git a/electron/lib/browser/init.ts b/electron/lib/browser/init.ts
index 50327911aa..744b27fa00 100644
--- a/electron/lib/browser/init.ts
+++ b/electron/lib/browser/init.ts
@@ -162,7 +162,7 @@ const mainStartupScript = packageJson.main || 'index.js';
 const KNOWN_XDG_DESKTOP_VALUES = new Set(['Pantheon', 'Unity:Unity7', 'pop:GNOME']);
 
 function currentPlatformSupportsAppIndicator () {
-  if (process.platform !== 'linux') return false;
+  if (process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') return false;
   const currentDesktop = process.env.XDG_CURRENT_DESKTOP;
 
   if (!currentDesktop) return false;
diff --git a/electron/lib/browser/rpc-server.ts b/electron/lib/browser/rpc-server.ts
index 4eef7baa1f..2813d48153 100644
--- a/electron/lib/browser/rpc-server.ts
+++ b/electron/lib/browser/rpc-server.ts
@@ -28,7 +28,7 @@ const allowedClipboardMethods = (() => {
   switch (process.platform) {
     case 'darwin':
       return new Set(['readFindText', 'writeFindText']);
-    case 'linux':
+    case 'linux': case 'freebsd': case 'netbsd':
       return new Set(Object.keys(clipboard));
     default:
       return new Set();
diff --git a/electron/lib/renderer/api/clipboard.ts b/electron/lib/renderer/api/clipboard.ts
index 96e77b2871..d4b8be6076 100644
--- a/electron/lib/renderer/api/clipboard.ts
+++ b/electron/lib/renderer/api/clipboard.ts
@@ -7,7 +7,7 @@ const makeRemoteMethod = function (method: keyof Electron.Clipboard): any {
   return (...args: any[]) => ipcRendererUtils.invokeSync(IPC_MESSAGES.BROWSER_CLIPBOARD_SYNC, method, ...args);
 };
 
-if (process.platform === 'linux') {
+if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
   // On Linux we could not access clipboard in renderer process.
   for (const method of Object.keys(clipboard) as (keyof Electron.Clipboard)[]) {
     clipboard[method] = makeRemoteMethod(method);
diff --git a/electron/script/lib/config.py b/electron/script/lib/config.py
index 6d60db6a21..4092992256 100644
--- a/electron/script/lib/config.py
+++ b/electron/script/lib/config.py
@@ -7,6 +7,10 @@ PLATFORM = {
   'cygwin': 'win32',
   'msys': 'win32',
   'darwin': 'darwin',
+  'freebsd13': 'freebsd',
+  'freebsd14': 'freebsd',
+  'freebsd15': 'freebsd',
+  'netbsd': 'netbsd',
   'linux': 'linux',
   'linux2': 'linux',
   'win32': 'win32',
diff --git a/electron/script/lib/utils.js b/electron/script/lib/utils.js
index 25521af9b4..e17121c259 100644
--- a/electron/script/lib/utils.js
+++ b/electron/script/lib/utils.js
@@ -19,7 +19,7 @@ function getElectronExec () {
       return `out/${OUT_DIR}/Electron.app/Contents/MacOS/Electron`;
     case 'win32':
       return `out/${OUT_DIR}/electron.exe`;
-    case 'linux':
+    case 'linux': case 'freebsd': case 'netbsd':
       return `out/${OUT_DIR}/electron`;
     default:
       throw new Error('Unknown platform');
diff --git a/electron/script/spec-runner.js b/electron/script/spec-runner.js
index 3457fdb34a..f70abb27c9 100755
--- a/electron/script/spec-runner.js
+++ b/electron/script/spec-runner.js
@@ -200,7 +200,7 @@ async function runTestUsingElectron (specDir, testName) {
     exe = path.resolve(BASE, utils.getElectronExec());
   }
   const runnerArgs = [`electron/${specDir}`, ...unknownArgs.slice(2)];
-  if (process.platform === 'linux') {
+  if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
     runnerArgs.unshift(path.resolve(__dirname, 'dbus_mock.py'), exe);
     exe = 'python3';
   }
diff --git a/electron/shell/app/electron_crash_reporter_client.cc b/electron/shell/app/electron_crash_reporter_client.cc
index 12451eda83..2d7e0eeb7b 100644
--- a/electron/shell/app/electron_crash_reporter_client.cc
+++ b/electron/shell/app/electron_crash_reporter_client.cc
@@ -91,7 +91,7 @@ ElectronCrashReporterClient::ElectronCrashReporterClient() = default;
 
 ElectronCrashReporterClient::~ElectronCrashReporterClient() = default;
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 void ElectronCrashReporterClient::SetCrashReporterClientIdFromGUID(
     const std::string& client_guid) {
   crash_keys::SetMetricsClientIdFromGUID(client_guid);
@@ -192,7 +192,7 @@ void ElectronCrashReporterClient::GetProcessSimpleAnnotations(
   (*annotations)["ver"] = ELECTRON_VERSION_STRING;
 }
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_BSD)
 bool ElectronCrashReporterClient::ShouldMonitorCrashHandlerExpensively() {
   return false;
 }
diff --git a/electron/shell/app/electron_crash_reporter_client.h b/electron/shell/app/electron_crash_reporter_client.h
index 81228ea821..fe24e1908f 100644
--- a/electron/shell/app/electron_crash_reporter_client.h
+++ b/electron/shell/app/electron_crash_reporter_client.h
@@ -30,7 +30,7 @@ class ElectronCrashReporterClient : public crash_reporter::CrashReporterClient {
       const std::map<std::string, std::string>& annotations);
 
   // crash_reporter::CrashReporterClient implementation.
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   void SetCrashReporterClientIdFromGUID(
       const std::string& client_guid) override;
   void GetProductNameAndVersion(const char** product_name,
@@ -69,7 +69,7 @@ class ElectronCrashReporterClient : public crash_reporter::CrashReporterClient {
   bool ReportingIsEnforcedByPolicy(bool* breakpad_enabled) override;
 #endif
 
-#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   bool ShouldMonitorCrashHandlerExpensively() override;
 #endif
 
diff --git a/electron/shell/app/electron_main_delegate.cc b/electron/shell/app/electron_main_delegate.cc
index a66e140a1e..8600bb0419 100644
--- a/electron/shell/app/electron_main_delegate.cc
+++ b/electron/shell/app/electron_main_delegate.cc
@@ -59,13 +59,13 @@
 #include "chrome/child/v8_crashpad_support_win.h"
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "base/nix/xdg_util.h"
 #include "v8/include/v8-wasm-trap-handler-posix.h"
 #include "v8/include/v8.h"
 #endif
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
 #include "components/crash/core/app/crash_switches.h"  // nogncheck
 #include "components/crash/core/app/crashpad.h"        // nogncheck
 #include "components/crash/core/common/crash_key.h"
@@ -156,7 +156,7 @@ bool ElectronPathProvider(int key, base::FilePath* result) {
       create_dir = true;
       break;
     }
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
     case DIR_APP_DATA: {
       auto env = base::Environment::Create();
       cur = base::nix::GetXDGDirectory(
@@ -282,7 +282,7 @@ std::optional<int> ElectronMainDelegate::BasicStartupComplete() {
     base::win::PinUser32();
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Check for --no-sandbox parameter when running as root.
   if (getuid() == 0 && IsSandboxEnabled(command_line))
     LOG(FATAL) << "Running as root without --"
@@ -332,7 +332,7 @@ void ElectronMainDelegate::PreSandboxStartup() {
       /* is_preinit = */ IsBrowserProcess() || IsZygoteProcess());
 #endif
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   crash_reporter::InitializeCrashKeys();
 #endif
 
@@ -367,7 +367,7 @@ void ElectronMainDelegate::PreSandboxStartup() {
   }
 #endif
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   crash_keys::SetCrashKeysFromCommandLine(*command_line);
   crash_keys::SetPlatformCrashKey();
 #endif
@@ -402,7 +402,7 @@ std::optional<int> ElectronMainDelegate::PreBrowserMain() {
 #if BUILDFLAG(IS_MAC)
   RegisterAtomCrApp();
 #endif
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Set the global activation token sent as an environment variable.
   auto env = base::Environment::Create();
   base::nix::ExtractXdgActivationTokenFromEnv(*env);
diff --git a/electron/shell/app/node_main.cc b/electron/shell/app/node_main.cc
index 88e2a8d6e5..691ad55358 100644
--- a/electron/shell/app/node_main.cc
+++ b/electron/shell/app/node_main.cc
@@ -47,7 +47,7 @@
 #include "shell/common/mac/codesign_util.h"
 #endif
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
 #include "components/crash/core/app/crashpad.h"  // nogncheck
 #include "shell/app/electron_crash_reporter_client.h"
 #include "shell/common/crash_keys.h"
@@ -98,14 +98,14 @@ bool UnsetHijackableEnvs(base::Environment* env) {
 }
 #endif
 
-#if IS_MAS_BUILD()
+#if IS_MAS_BUILD() || BUILDFLAG(IS_BSD)
 void SetCrashKeyStub(const std::string& key, const std::string& value) {}
 void ClearCrashKeyStub(const std::string& key) {}
 #endif
 
 v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {
   std::map<std::string, std::string> keys;
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   electron::crash_keys::GetCrashKeys(&keys);
 #endif
   return gin::ConvertToV8(isolate, keys);
@@ -270,7 +270,7 @@ int NodeMain(int argc, char* argv[]) {
       // Setup process.crashReporter in child node processes
       auto reporter = gin_helper::Dictionary::CreateEmpty(isolate);
       reporter.SetMethod("getParameters", &GetParameters);
-#if IS_MAS_BUILD()
+#if IS_MAS_BUILD() || BUILDFLAG(IS_BSD)
       reporter.SetMethod("addExtraParameter", &SetCrashKeyStub);
       reporter.SetMethod("removeExtraParameter", &ClearCrashKeyStub);
 #else
diff --git a/electron/shell/browser/api/electron_api_app.cc b/electron/shell/browser/api/electron_api_app.cc
index e7774c42ee..848bf47bde 100644
--- a/electron/shell/browser/api/electron_api_app.cc
+++ b/electron/shell/browser/api/electron_api_app.cc
@@ -96,7 +96,7 @@
 #include "shell/common/process_util.h"
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "base/nix/scoped_xdg_activation_token_injector.h"
 #include "base/nix/xdg_util.h"
 #endif
@@ -420,7 +420,7 @@ bool NotificationCallbackWrapper(
     base::CommandLine cmd,
     const base::FilePath& cwd,
     const std::vector<uint8_t> additional_data) {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Set the global activation token sent as a command line switch by another
   // electron app instance. This also removes the switch after use to prevent
   // any side effects of leaving it in the command line after this point.
@@ -606,7 +606,7 @@ void App::OnWillFinishLaunching() {
 }
 
 void App::OnFinishLaunching(base::Value::Dict launch_info) {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Set the application name for audio streams shown in external
   // applications. Only affects pulseaudio currently.
   media::AudioManager::SetGlobalAppName(Browser::Get()->GetName());
@@ -947,7 +947,7 @@ void App::SetPath(gin_helper::ErrorThrower thrower,
 }
 
 void App::SetDesktopName(const std::string& desktop_name) {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   auto env = base::Environment::Create();
   env->SetVar("CHROME_DESKTOP", desktop_name);
 #endif
@@ -1051,7 +1051,7 @@ bool App::RequestSingleInstanceLock(gin::Arguments* args) {
       base::BindRepeating(NotificationCallbackWrapper, cb));
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Read the xdg-activation token and set it in the command line for the
   // duration of the notification in order to ensure this is propagated to an
   // already running electron app instance if it exists.
@@ -1346,7 +1346,7 @@ std::vector<gin_helper::Dictionary> App::GetAppMetrics(v8::Isolate* isolate) {
       pid_dict.Set("name", process_metric.second->name);
     }
 
-#if !BUILDFLAG(IS_LINUX)
+#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_BSD)
     auto memory_info = process_metric.second->GetMemoryInfo();
 
     auto memory_dict = gin_helper::Dictionary::CreateEmpty(isolate);
@@ -1720,7 +1720,7 @@ gin::ObjectTemplateBuilder App::GetObjectTemplateBuilder(v8::Isolate* isolate) {
       .SetMethod(
           "removeAsDefaultProtocolClient",
           base::BindRepeating(&Browser::RemoveAsDefaultProtocolClient, browser))
-#if !BUILDFLAG(IS_LINUX)
+#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_BSD)
       .SetMethod(
           "getApplicationInfoForProtocol",
           base::BindRepeating(&Browser::GetApplicationInfoForProtocol, browser))
@@ -1778,7 +1778,7 @@ gin::ObjectTemplateBuilder App::GetObjectTemplateBuilder(v8::Isolate* isolate) {
       .SetMethod("getJumpListSettings", &App::GetJumpListSettings)
       .SetMethod("setJumpList", &App::SetJumpList)
 #endif
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
       .SetMethod("isUnityRunning",
                  base::BindRepeating(&Browser::IsUnityRunning, browser))
 #endif
diff --git a/electron/shell/browser/api/electron_api_base_window.cc b/electron/shell/browser/api/electron_api_base_window.cc
index 663b7d72c7..41a2ed3ae8 100644
--- a/electron/shell/browser/api/electron_api_base_window.cc
+++ b/electron/shell/browser/api/electron_api_base_window.cc
@@ -41,7 +41,7 @@
 #include "shell/browser/ui/views/win_frame_view.h"
 #include "shell/browser/ui/win/taskbar_host.h"
 #include "ui/base/win/shell.h"
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "shell/browser/ui/views/opaque_frame_view.h"
 #endif
 
@@ -986,7 +986,7 @@ void BaseWindow::SetIconImpl(v8::Isolate* isolate,
   static_cast<NativeWindowViews*>(window_.get())
       ->SetIcon(native_image->GetHICON(GetSystemMetrics(SM_CXSMICON)),
                 native_image->GetHICON(GetSystemMetrics(SM_CXICON)));
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   static_cast<NativeWindowViews*>(window_.get())
       ->SetIcon(native_image->image().AsImageSkia());
 #endif
@@ -1043,7 +1043,7 @@ void BaseWindow::SetAppDetails(const gin_helper::Dictionary& options) {
 }
 #endif
 
-#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 void BaseWindow::SetTitleBarOverlay(const gin_helper::Dictionary& options,
                                     gin_helper::Arguments* args) {
   // Ensure WCO is already enabled on this window
@@ -1296,7 +1296,7 @@ void BaseWindow::BuildPrototype(v8::Isolate* isolate,
       .SetMethod("setThumbnailToolTip", &BaseWindow::SetThumbnailToolTip)
       .SetMethod("setAppDetails", &BaseWindow::SetAppDetails)
 #endif
-#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
       .SetMethod("setTitleBarOverlay", &BaseWindow::SetTitleBarOverlay)
 #endif
       .SetProperty("id", &BaseWindow::GetID);
diff --git a/electron/shell/browser/api/electron_api_base_window.h b/electron/shell/browser/api/electron_api_base_window.h
index 3b582891f5..94d3b9022a 100644
--- a/electron/shell/browser/api/electron_api_base_window.h
+++ b/electron/shell/browser/api/electron_api_base_window.h
@@ -251,7 +251,7 @@ class BaseWindow : public gin_helper::TrackableObject<BaseWindow>,
   void SetAppDetails(const gin_helper::Dictionary& options);
 #endif
 
-#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   void SetTitleBarOverlay(const gin_helper::Dictionary& options,
                           gin_helper::Arguments* args);
 #endif
diff --git a/electron/shell/browser/api/electron_api_crash_reporter.cc b/electron/shell/browser/api/electron_api_crash_reporter.cc
index 7ded05d461..5a1a67542d 100644
--- a/electron/shell/browser/api/electron_api_crash_reporter.cc
+++ b/electron/shell/browser/api/electron_api_crash_reporter.cc
@@ -30,7 +30,7 @@
 #include "shell/common/process_util.h"
 #include "shell/common/thread_restrictions.h"
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
 #include "components/crash/core/app/crashpad.h"  // nogncheck
 #include "components/crash/core/browser/crash_upload_list_crashpad.h"  // nogncheck
 #include "components/crash/core/common/crash_key.h"
@@ -64,7 +64,7 @@ bool g_crash_reporter_initialized = false;
 
 namespace electron::api::crash_reporter {
 
-#if IS_MAS_BUILD()
+#if IS_MAS_BUILD() || BUILDFLAG(IS_BSD)
 namespace {
 
 void NoOp() {}
@@ -135,7 +135,7 @@ void Start(const std::string& submit_url,
            const std::map<std::string, std::string>& extra,
            bool is_node_process) {
   TRACE_EVENT0("electron", "crash_reporter::Start");
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   if (g_crash_reporter_initialized)
     return;
   g_crash_reporter_initialized = true;
@@ -181,7 +181,7 @@ void Start(const std::string& submit_url,
 
 namespace {
 
-#if IS_MAS_BUILD()
+#if IS_MAS_BUILD() || BUILDFLAG(IS_BSD)
 void GetUploadedReports(
     v8::Isolate* isolate,
     base::OnceCallback<void(v8::Local<v8::Value>)> callback) {
@@ -236,13 +236,13 @@ v8::Local<v8::Value> GetUploadedReports(v8::Isolate* isolate) {
 #endif
 
 void SetUploadToServer(bool upload) {
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   ElectronCrashReporterClient::Get()->SetCollectStatsConsent(upload);
 #endif
 }
 
 bool GetUploadToServer() {
-#if IS_MAS_BUILD()
+#if IS_MAS_BUILD() || BUILDFLAG(IS_BSD)
   return false;
 #else
   return ElectronCrashReporterClient::Get()->GetCollectStatsConsent();
@@ -251,7 +251,7 @@ bool GetUploadToServer() {
 
 v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {
   std::map<std::string, std::string> keys;
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   electron::crash_keys::GetCrashKeys(&keys);
 #endif
   return gin::ConvertToV8(isolate, keys);
@@ -263,7 +263,7 @@ void Initialize(v8::Local<v8::Object> exports,
                 void* priv) {
   gin_helper::Dictionary dict(context->GetIsolate(), exports);
   dict.SetMethod("start", &electron::api::crash_reporter::Start);
-#if IS_MAS_BUILD()
+#if IS_MAS_BUILD() || BUILDFLAG(IS_BSD)
   dict.SetMethod("addExtraParameter", &electron::api::crash_reporter::NoOp);
   dict.SetMethod("removeExtraParameter", &electron::api::crash_reporter::NoOp);
 #else
diff --git a/electron/shell/browser/api/electron_api_desktop_capturer.cc b/electron/shell/browser/api/electron_api_desktop_capturer.cc
index acd9763836..19cbda048a 100644
--- a/electron/shell/browser/api/electron_api_desktop_capturer.cc
+++ b/electron/shell/browser/api/electron_api_desktop_capturer.cc
@@ -47,7 +47,7 @@
 #endif
 
 namespace {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 // Private function in ui/base/x/x11_display_util.cc
 base::flat_map<x11::RandR::Output, int> GetMonitors(
     std::pair<uint32_t, uint32_t> version,
diff --git a/electron/shell/browser/api/electron_api_power_monitor.cc b/electron/shell/browser/api/electron_api_power_monitor.cc
index b0b9b560c4..5829b3a5fa 100644
--- a/electron/shell/browser/api/electron_api_power_monitor.cc
+++ b/electron/shell/browser/api/electron_api_power_monitor.cc
@@ -128,6 +128,11 @@ void PowerMonitor::OnSpeedLimitChange(int speed_limit) {
       gin::DataObjectBuilder(isolate).Set("limit", speed_limit).Build());
 }
 
+#if BUILDFLAG(IS_BSD)
+void PowerMonitor::SetListeningForShutdown(bool is_listening) {
+}
+#endif
+
 #if BUILDFLAG(IS_LINUX)
 void PowerMonitor::SetListeningForShutdown(bool is_listening) {
   if (is_listening) {
@@ -153,7 +158,7 @@ gin::ObjectTemplateBuilder PowerMonitor::GetObjectTemplateBuilder(
   auto builder =
       gin_helper::EventEmitterMixin<PowerMonitor>::GetObjectTemplateBuilder(
           isolate);
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   builder.SetMethod("setListeningForShutdown",
                     &PowerMonitor::SetListeningForShutdown);
 #endif
diff --git a/electron/shell/browser/api/electron_api_power_monitor.h b/electron/shell/browser/api/electron_api_power_monitor.h
index 5fb31504e2..80a6e22161 100644
--- a/electron/shell/browser/api/electron_api_power_monitor.h
+++ b/electron/shell/browser/api/electron_api_power_monitor.h
@@ -40,7 +40,7 @@ class PowerMonitor final : public gin::Wrappable<PowerMonitor>,
   explicit PowerMonitor(v8::Isolate* isolate);
   ~PowerMonitor() override;
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   void SetListeningForShutdown(bool);
 #endif
 
diff --git a/electron/shell/browser/api/electron_api_safe_storage.cc b/electron/shell/browser/api/electron_api_safe_storage.cc
index f9ecdd0734..f9c4dc389a 100644
--- a/electron/shell/browser/api/electron_api_safe_storage.cc
+++ b/electron/shell/browser/api/electron_api_safe_storage.cc
@@ -19,7 +19,7 @@ const char* kEncryptionVersionPrefixV11 = "v11";
 bool use_password_v10 = false;
 
 bool IsEncryptionAvailable() {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Calling IsEncryptionAvailable() before the app is ready results in a crash
   // on Linux.
   // Refs: https://github.com/electron/electron/issues/32206.
@@ -38,7 +38,7 @@ void SetUsePasswordV10(bool use) {
   use_password_v10 = use;
 }
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 std::string GetSelectedLinuxBackend() {
   if (!electron::Browser::Get()->is_ready())
     return "unknown";
@@ -135,7 +135,7 @@ void Initialize(v8::Local<v8::Object> exports,
   gin_helper::Dictionary dict(isolate, exports);
   dict.SetMethod("decryptString", &DecryptString);
   dict.SetMethod("encryptString", &EncryptString);
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   dict.SetMethod("getSelectedStorageBackend", &GetSelectedLinuxBackend);
 #endif
   dict.SetMethod("isEncryptionAvailable", &IsEncryptionAvailable);
diff --git a/electron/shell/browser/api/electron_api_web_contents.cc b/electron/shell/browser/api/electron_api_web_contents.cc
index 66fa93620d..d9e7af7400 100644
--- a/electron/shell/browser/api/electron_api_web_contents.cc
+++ b/electron/shell/browser/api/electron_api_web_contents.cc
@@ -157,11 +157,11 @@
 #include "ui/base/cocoa/defaults_utils.h"
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "ui/linux/linux_ui.h"
 #endif
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_WIN)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_WIN) || BUILDFLAG(IS_BSD)
 #include "ui/aura/window.h"
 #include "ui/gfx/font_render_params.h"
 #endif
@@ -193,7 +193,7 @@
 #include "content/public/browser/plugin_service.h"
 #endif
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
 #include "chrome/browser/hang_monitor/hang_crash_dump.h"  // nogncheck
 #endif
 
@@ -567,7 +567,7 @@ std::optional<base::TimeDelta> GetCursorBlinkInterval() {
       ui::TextInsertionCaretBlinkPeriodFromDefaults());
   if (system_value)
     return *system_value;
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (auto* linux_ui = ui::LinuxUi::instance())
     return linux_ui->GetCursorBlinkInterval();
 #elif BUILDFLAG(IS_WIN)
@@ -928,7 +928,7 @@ void WebContents::InitWithSessionAndOptions(
   accept_languages.pop_back();
   prefs->accept_languages = accept_languages;
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_WIN)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_WIN) || BUILDFLAG(IS_BSD)
   // Update font settings.
   static const gfx::FontRenderParams params(
       gfx::GetFontRenderParams(gfx::FontRenderParamsQuery(), nullptr));
@@ -2787,13 +2787,13 @@ void WebContents::ForcefullyCrashRenderer() {
 
   content::RenderProcessHost* rph = rwh->GetProcess();
   if (rph) {
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_BSD)
     // A generic |CrashDumpHungChildProcess()| is not implemented for Linux.
     // Instead we send an explicit IPC to crash on the renderer's IO thread.
     rph->ForceCrash();
 #else
     // Try to generate a crash report for the hung process.
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
     CrashDumpHungChildProcess(rph->GetProcess().Handle());
 #endif
     rph->Shutdown(content::RESULT_CODE_HUNG);
@@ -3476,7 +3476,7 @@ void WebContents::CopyImageAt(int x, int y) {
 void WebContents::Focus() {
   // Focusing on WebContents does not automatically focus the window on macOS
   // and Linux, do it manually to match the behavior on Windows.
-#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (owner_window())
     owner_window()->Focus(true);
 #endif
@@ -4353,7 +4353,7 @@ ui::ImageModel WebContents::GetDevToolsWindowIcon() {
 }
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 void WebContents::GetDevToolsWindowWMClass(std::string* name,
                                            std::string* class_name) {
   *class_name = Browser::Get()->GetName();
diff --git a/electron/shell/browser/api/electron_api_web_contents.h b/electron/shell/browser/api/electron_api_web_contents.h
index e7d3374646..01d57e258f 100644
--- a/electron/shell/browser/api/electron_api_web_contents.h
+++ b/electron/shell/browser/api/electron_api_web_contents.h
@@ -782,7 +782,7 @@ class WebContents final : public ExclusiveAccessContext,
 #if defined(TOOLKIT_VIEWS) && !BUILDFLAG(IS_MAC)
   ui::ImageModel GetDevToolsWindowIcon() override;
 #endif
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   void GetDevToolsWindowWMClass(std::string* name,
                                 std::string* class_name) override;
 #endif
diff --git a/electron/shell/browser/api/process_metric.h b/electron/shell/browser/api/process_metric.h
index 07978f1c38..6ee1cfe830 100644
--- a/electron/shell/browser/api/process_metric.h
+++ b/electron/shell/browser/api/process_metric.h
@@ -14,7 +14,7 @@
 
 namespace electron {
 
-#if !BUILDFLAG(IS_LINUX)
+#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_BSD)
 struct ProcessMemoryInfo {
   size_t working_set_size = 0;
   size_t peak_working_set_size = 0;
@@ -48,7 +48,7 @@ struct ProcessMetric {
                 const std::string& name = std::string());
   ~ProcessMetric();
 
-#if !BUILDFLAG(IS_LINUX)
+#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_BSD)
   ProcessMemoryInfo GetMemoryInfo() const;
 #endif
 
diff --git a/electron/shell/browser/browser.cc b/electron/shell/browser/browser.cc
index 711aa4c2b9..e89d1dc7d9 100644
--- a/electron/shell/browser/browser.cc
+++ b/electron/shell/browser/browser.cc
@@ -71,7 +71,7 @@ Browser* Browser::Get() {
   return ElectronBrowserMainParts::Get()->browser();
 }
 
-#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 void Browser::Focus(gin::Arguments* args) {
   // Focus on the first visible window.
   for (auto* const window : WindowList::GetWindows()) {
diff --git a/electron/shell/browser/browser.h b/electron/shell/browser/browser.h
index d341d42efe..68b375a464 100644
--- a/electron/shell/browser/browser.h
+++ b/electron/shell/browser/browser.h
@@ -144,7 +144,7 @@ class Browser : private WindowListObserver {
 
   std::u16string GetApplicationNameForProtocol(const GURL& url);
 
-#if !BUILDFLAG(IS_LINUX)
+#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_BSD)
   // get the name, icon and path for an application
   v8::Local<v8::Promise> GetApplicationInfoForProtocol(v8::Isolate* isolate,
                                                        const GURL& url);
@@ -272,10 +272,10 @@ class Browser : private WindowListObserver {
   PCWSTR GetAppUserModelID();
 #endif  // BUILDFLAG(IS_WIN)
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Whether Unity launcher is running.
   bool IsUnityRunning();
-#endif  // BUILDFLAG(IS_LINUX)
+#endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 
   // Tell the application to open a file.
   bool OpenFile(const std::string& file_path);
diff --git a/electron/shell/browser/browser_linux.cc b/electron/shell/browser/browser_linux.cc
index 99804abe37..645be36bc4 100644
--- a/electron/shell/browser/browser_linux.cc
+++ b/electron/shell/browser/browser_linux.cc
@@ -7,7 +7,7 @@
 #include <fcntl.h>
 #include <stdlib.h>
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include <gtk/gtk.h>
 #endif
 
@@ -23,7 +23,7 @@
 #include "shell/common/gin_converters/login_item_settings_converter.h"
 #include "shell/common/thread_restrictions.h"
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "shell/browser/linux/unity_service.h"
 #endif
 
diff --git a/electron/shell/browser/browser_process_impl.cc b/electron/shell/browser/browser_process_impl.cc
index fd7616ac17..4ea24b2f7f 100644
--- a/electron/shell/browser/browser_process_impl.cc
+++ b/electron/shell/browser/browser_process_impl.cc
@@ -338,7 +338,7 @@ electron::ResolveProxyHelper* BrowserProcessImpl::GetResolveProxyHelper() {
   return resolve_proxy_helper_.get();
 }
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 void BrowserProcessImpl::SetLinuxStorageBackend(
     os_crypt::SelectedLinuxBackend selected_backend) {
   switch (selected_backend) {
@@ -361,7 +361,7 @@ void BrowserProcessImpl::SetLinuxStorageBackend(
       NOTREACHED();
   }
 }
-#endif  // BUILDFLAG(IS_LINUX)
+#endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 
 void BrowserProcessImpl::SetApplicationLocale(const std::string& locale) {
   locale_ = locale;
diff --git a/electron/shell/browser/browser_process_impl.h b/electron/shell/browser/browser_process_impl.h
index ef663f7c95..24288325a7 100644
--- a/electron/shell/browser/browser_process_impl.h
+++ b/electron/shell/browser/browser_process_impl.h
@@ -21,7 +21,7 @@
 #include "services/network/public/cpp/shared_url_loader_factory.h"
 #include "shell/browser/net/system_network_context_manager.h"
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "components/os_crypt/sync/key_storage_util_linux.h"
 #endif
 
@@ -60,7 +60,7 @@ class BrowserProcessImpl : public BrowserProcess {
   const std::string& GetSystemLocale() const;
   electron::ResolveProxyHelper* GetResolveProxyHelper();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   void SetLinuxStorageBackend(os_crypt::SelectedLinuxBackend selected_backend);
   [[nodiscard]] const std::string& linux_storage_backend() const {
     return selected_linux_storage_backend_;
@@ -150,7 +150,7 @@ class BrowserProcessImpl : public BrowserProcess {
   std::unique_ptr<PrefService> local_state_;
   std::string locale_;
   std::string system_locale_;
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   std::string selected_linux_storage_backend_;
 #endif
   embedder_support::OriginTrialsSettingsStorage origin_trials_settings_storage_;
diff --git a/electron/shell/browser/electron_browser_main_parts.cc b/electron/shell/browser/electron_browser_main_parts.cc
index 1603230fbb..720081f1d0 100644
--- a/electron/shell/browser/electron_browser_main_parts.cc
+++ b/electron/shell/browser/electron_browser_main_parts.cc
@@ -76,7 +76,7 @@
 #include "ui/wm/core/wm_state.h"
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "base/environment.h"
 #include "chrome/browser/ui/views/dark_mode_manager_linux.h"
 #include "device/bluetooth/bluetooth_adapter_factory.h"
@@ -129,7 +129,7 @@ namespace electron {
 
 namespace {
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 class LinuxUiGetterImpl : public ui::LinuxUiGetter {
  public:
   LinuxUiGetterImpl() = default;
@@ -209,7 +209,7 @@ int ElectronBrowserMainParts::PreEarlyInitialization() {
 #if BUILDFLAG(IS_POSIX)
   HandleSIGCHLD();
 #endif
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   DetectOzonePlatform();
   ui::OzonePlatform::PreEarlyInitialization();
 #endif
@@ -300,7 +300,7 @@ int ElectronBrowserMainParts::PreCreateThreads() {
   // happen before the ResourceBundle is loaded
   if (locale.empty())
     l10n_util::OverrideLocaleWithCocoaLocale();
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // l10n_util::GetApplicationLocaleInternal uses g_get_language_names(),
   // which keys off of getenv("LC_ALL").
   // We must set this env first to make ui::ResourceBundle accept the custom
@@ -331,7 +331,7 @@ int ElectronBrowserMainParts::PreCreateThreads() {
   ElectronBrowserClient::SetApplicationLocale(app_locale);
   fake_browser_process_->SetApplicationLocale(app_locale);
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Reset to the original LC_ALL since we should not be changing it.
   if (!locale.empty()) {
     if (lc_all)
@@ -388,7 +388,7 @@ void ElectronBrowserMainParts::PostDestroyThreads() {
 }
 
 void ElectronBrowserMainParts::ToolkitInitialized() {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   auto* linux_ui = ui::GetDefaultLinuxUi();
   CHECK(linux_ui);
   linux_ui_getter_ = std::make_unique<LinuxUiGetterImpl>();
@@ -494,7 +494,7 @@ void ElectronBrowserMainParts::WillRunMainMessageLoop(
 }
 
 void ElectronBrowserMainParts::PostCreateMainMessageLoop() {
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_MAC)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_MAC) || BUILDFLAG(IS_BSD)
   std::string app_name = electron::Browser::Get()->GetName();
 #endif
 #if BUILDFLAG(IS_LINUX)
@@ -506,7 +506,9 @@ void ElectronBrowserMainParts::PostCreateMainMessageLoop() {
 
   if (!bluez::BluezDBusManager::IsInitialized())
     bluez::DBusBluezManagerWrapperLinux::Initialize();
+#endif
 
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Set up crypt config. This needs to be done before anything starts the
   // network service, as the raw encryption key needs to be shared with the
   // network service for encrypted cookie storage.
@@ -601,7 +603,7 @@ void ElectronBrowserMainParts::PostMainMessageLoopRun() {
   fake_browser_process_->PostMainMessageLoopRun();
   content::DevToolsAgentHost::StopRemoteDebuggingPipeHandler();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   ui::OzonePlatform::GetInstance()->PostMainMessageLoopRun();
 #endif
 }
diff --git a/electron/shell/browser/electron_browser_main_parts.h b/electron/shell/browser/electron_browser_main_parts.h
index ebf3e10ff1..c06a4c387b 100644
--- a/electron/shell/browser/electron_browser_main_parts.h
+++ b/electron/shell/browser/electron_browser_main_parts.h
@@ -124,7 +124,7 @@ class ElectronBrowserMainParts : public content::BrowserMainParts {
       const scoped_refptr<base::SingleThreadTaskRunner>& task_runner);
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   void DetectOzonePlatform();
 #endif
 
@@ -146,7 +146,7 @@ class ElectronBrowserMainParts : public content::BrowserMainParts {
   std::unique_ptr<display::Screen> screen_;
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   std::unique_ptr<ui::DarkModeManagerLinux> dark_mode_manager_;
   std::unique_ptr<ui::LinuxUiGetter> linux_ui_getter_;
 #endif
diff --git a/electron/shell/browser/electron_browser_main_parts_posix.cc b/electron/shell/browser/electron_browser_main_parts_posix.cc
index ce0433f843..5926f25c89 100644
--- a/electron/shell/browser/electron_browser_main_parts_posix.cc
+++ b/electron/shell/browser/electron_browser_main_parts_posix.cc
@@ -210,12 +210,16 @@ void ElectronBrowserMainParts::InstallShutdownSignalHandlers(
   g_pipe_pid = getpid();
   g_shutdown_pipe_read_fd = pipefd[0];
   g_shutdown_pipe_write_fd = pipefd[1];
+#if defined(OS_BSD)
+  const size_t kShutdownDetectorThreadStackSize = 0;
+#else
 #if !defined(ADDRESS_SANITIZER)
   const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 2;
 #else
   // ASan instrumentation bloats the stack frames, so we need to increase the
   // stack size to avoid hitting the guard page.
   const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 4;
+#endif
 #endif
   ShutdownDetector* detector = new ShutdownDetector(
       g_shutdown_pipe_read_fd, std::move(shutdown_callback), task_runner);
diff --git a/electron/shell/browser/extensions/api/runtime/electron_runtime_api_delegate.cc b/electron/shell/browser/extensions/api/runtime/electron_runtime_api_delegate.cc
index d41b2acc27..6d456c7d61 100644
--- a/electron/shell/browser/extensions/api/runtime/electron_runtime_api_delegate.cc
+++ b/electron/shell/browser/extensions/api/runtime/electron_runtime_api_delegate.cc
@@ -54,6 +54,10 @@ bool ElectronRuntimeAPIDelegate::GetPlatformInfo(PlatformInfo* info) {
     info->os = extensions::api::runtime::PlatformOs::kLinux;
   } else if (strcmp(os, "openbsd") == 0) {
     info->os = extensions::api::runtime::PlatformOs::kOpenbsd;
+  } else if (strcmp(os, "freebsd") == 0) {
+    info->os = extensions::api::runtime::PlatformOs::kFreebsd;
+  } else if (strcmp(os, "netbsd") == 0) {
+    info->os = extensions::api::runtime::PlatformOs::kNetbsd;
   } else {
     NOTREACHED();
   }
diff --git a/electron/shell/browser/native_window.cc b/electron/shell/browser/native_window.cc
index c554743a66..3e145c44ed 100644
--- a/electron/shell/browser/native_window.cc
+++ b/electron/shell/browser/native_window.cc
@@ -200,7 +200,7 @@ void NativeWindow::InitFromOptions(const gin_helper::Dictionary& options) {
   } else {
     SetSizeConstraints(size_constraints);
   }
-#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   bool closable;
   if (options.Get(options::kClosable, &closable)) {
     SetClosable(closable);
diff --git a/electron/shell/browser/native_window_views.cc b/electron/shell/browser/native_window_views.cc
index 9f0e19bf3b..489627c3a0 100644
--- a/electron/shell/browser/native_window_views.cc
+++ b/electron/shell/browser/native_window_views.cc
@@ -49,7 +49,7 @@
 #include "ui/wm/core/shadow_types.h"
 #include "ui/wm/core/window_util.h"
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "base/strings/string_util.h"
 #include "shell/browser/browser.h"
 #include "shell/browser/linux/unity_service.h"
@@ -294,7 +294,7 @@ NativeWindowViews::NativeWindowViews(const gin_helper::Dictionary& options,
     params.parent = parent->GetNativeWindow();
 
   params.native_widget = new ElectronDesktopNativeWidgetAura(this);
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   std::string name = Browser::Get()->GetName();
   // Set WM_WINDOW_ROLE.
   params.wm_role_name = "browser-window";
@@ -320,7 +320,7 @@ NativeWindowViews::NativeWindowViews(const gin_helper::Dictionary& options,
   std::string window_type;
   options.Get(options::kType, &window_type);
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Set _GTK_THEME_VARIANT to dark if we have "dark-theme" option set.
   bool use_dark_theme = false;
   if (options.Get(options::kDarkTheme, &use_dark_theme) && use_dark_theme) {
@@ -427,7 +427,7 @@ NativeWindowViews::NativeWindowViews(const gin_helper::Dictionary& options,
   if (window)
     window->AddPreTargetHandler(this);
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // On linux after the widget is initialized we might have to force set the
   // bounds if the bounds are smaller than the current display
   SetBounds(gfx::Rect(GetPosition(), bounds.size()), false);
@@ -463,7 +463,7 @@ NativeWindowViews::~NativeWindowViews() {
 }
 
 void NativeWindowViews::SetGTKDarkThemeEnabled(bool use_dark_theme) {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (IsX11()) {
     const std::string color = use_dark_theme ? "dark" : "light";
     auto* connection = x11::Connection::Get();
@@ -525,7 +525,7 @@ void NativeWindowViews::Show() {
 
   NotifyWindowShow();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (global_menu_bar_)
     global_menu_bar_->OnWindowMapped();
 
@@ -541,7 +541,7 @@ void NativeWindowViews::ShowInactive() {
 
   NotifyWindowShow();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (global_menu_bar_)
     global_menu_bar_->OnWindowMapped();
 
@@ -560,7 +560,7 @@ void NativeWindowViews::Hide() {
 
   NotifyWindowHide();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (global_menu_bar_)
     global_menu_bar_->OnWindowUnmapped();
 #endif
@@ -591,7 +591,7 @@ bool NativeWindowViews::IsVisible() const {
 bool NativeWindowViews::IsEnabled() const {
 #if BUILDFLAG(IS_WIN)
   return ::IsWindowEnabled(GetAcceleratedWidget());
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (IsX11())
     return !event_disabler_.get();
   NOTIMPLEMENTED();
@@ -831,7 +831,7 @@ void NativeWindowViews::SetBounds(const gfx::Rect& bounds, bool animate) {
   }
 #endif
 
-#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // On Linux and Windows the minimum and maximum size should be updated with
   // window size when window is not resizable.
   if (!resizable_) {
@@ -1089,7 +1089,7 @@ bool NativeWindowViews::IsClosable() const {
     return false;
   }
   return !(info.fState & MFS_DISABLED);
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   return true;
 #endif
 }
@@ -1129,7 +1129,7 @@ ui::ZOrderLevel NativeWindowViews::GetZOrderLevel() const {
 // for now to avoid breaking API contract, but should consider the long
 // term plan for this aligning with upstream.
 void NativeWindowViews::Center() {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   auto display =
       display::Screen::GetScreen()->GetDisplayNearestWindow(GetNativeWindow());
   gfx::Rect window_bounds_in_screen = display.work_area();
@@ -1350,7 +1350,7 @@ bool NativeWindowViews::IsFocusable() const {
 }
 
 void NativeWindowViews::SetMenu(ElectronMenuModel* menu_model) {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Remove global menu bar.
   if (global_menu_bar_ && menu_model == nullptr) {
     global_menu_bar_.reset();
@@ -1405,7 +1405,7 @@ void NativeWindowViews::SetMenu(ElectronMenuModel* menu_model) {
 void NativeWindowViews::SetParentWindow(NativeWindow* parent) {
   NativeWindow::SetParentWindow(parent);
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (IsX11()) {
     auto* connection = x11::Connection::Get();
     connection->SetProperty(
@@ -1451,7 +1451,7 @@ void NativeWindowViews::SetProgressBar(double progress,
                                        NativeWindow::ProgressState state) {
 #if BUILDFLAG(IS_WIN)
   taskbar_host_.SetProgressBar(GetAcceleratedWidget(), progress, state);
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (unity::IsRunning()) {
     unity::SetProgressFraction(progress);
   }
@@ -1529,7 +1529,7 @@ bool NativeWindowViews::IsVisibleOnAllWorkspaces() const {
   if (const auto* view_native_widget = widget()->native_widget_private())
     return view_native_widget->IsVisibleOnAllWorkspaces();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (IsX11()) {
     // Use the presence/absence of _NET_WM_STATE_STICKY in _NET_WM_STATE to
     // determine whether the current window is visible on all workspaces.
@@ -1552,7 +1552,7 @@ content::DesktopMediaID NativeWindowViews::GetDesktopMediaID() const {
 #if BUILDFLAG(IS_WIN)
   window_handle =
       reinterpret_cast<content::DesktopMediaID::Id>(accelerated_widget);
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   window_handle = static_cast<uint32_t>(accelerated_widget);
 #endif
   aura::WindowTreeHost* const host =
@@ -1650,7 +1650,7 @@ void NativeWindowViews::SetIcon(HICON window_icon, HICON app_icon) {
   SendMessage(hwnd, WM_SETICON, ICON_BIG,
               reinterpret_cast<LPARAM>(app_icon_.get()));
 }
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 void NativeWindowViews::SetIcon(const gfx::ImageSkia& icon) {
   auto* tree_host = views::DesktopWindowTreeHostLinux::GetHostForWidget(
       GetAcceleratedWidget());
@@ -1746,7 +1746,7 @@ bool NativeWindowViews::CanMaximize() const {
 bool NativeWindowViews::CanMinimize() const {
 #if BUILDFLAG(IS_WIN)
   return minimizable_;
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   return true;
 #endif
 }
@@ -1802,7 +1802,7 @@ void NativeWindowViews::HandleKeyboardEvent(
   if (widget_destroyed_)
     return;
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (event.windows_key_code == ui::VKEY_BROWSER_BACK)
     NotifyWindowExecuteAppCommand(kBrowserBackward);
   else if (event.windows_key_code == ui::VKEY_BROWSER_FORWARD)
@@ -1821,7 +1821,7 @@ void NativeWindowViews::OnMouseEvent(ui::MouseEvent* event) {
   // Alt+Click should not toggle menu bar.
   root_view_.ResetAltState();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (event->changed_button_flags() == ui::EF_BACK_MOUSE_BUTTON)
     NotifyWindowExecuteAppCommand(kBrowserBackward);
   else if (event->changed_button_flags() == ui::EF_FORWARD_MOUSE_BUTTON)
diff --git a/electron/shell/browser/native_window_views.h b/electron/shell/browser/native_window_views.h
index 8ed31adab8..cc7b72bd48 100644
--- a/electron/shell/browser/native_window_views.h
+++ b/electron/shell/browser/native_window_views.h
@@ -25,7 +25,7 @@
 
 namespace electron {
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 class GlobalMenuBarX11;
 #endif
 
@@ -162,7 +162,7 @@ class NativeWindowViews : public NativeWindow,
                     LPARAM l_param,
                     LRESULT* result);
   void SetIcon(HICON small_icon, HICON app_icon);
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   void SetIcon(const gfx::ImageSkia& icon);
 #endif
 
@@ -246,7 +246,7 @@ class NativeWindowViews : public NativeWindow,
   // events from resizing the window.
   extensions::SizeConstraints old_size_constraints_;
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   std::unique_ptr<GlobalMenuBarX11> global_menu_bar_;
 #endif
 
diff --git a/electron/shell/browser/net/system_network_context_manager.cc b/electron/shell/browser/net/system_network_context_manager.cc
index 68862a5435..66044c98f7 100644
--- a/electron/shell/browser/net/system_network_context_manager.cc
+++ b/electron/shell/browser/net/system_network_context_manager.cc
@@ -39,7 +39,7 @@
 #include "shell/common/options_switches.h"
 #include "url/gurl.h"
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "components/os_crypt/sync/key_storage_config_linux.h"
 #endif
 
diff --git a/electron/shell/browser/osr/osr_host_display_client.cc b/electron/shell/browser/osr/osr_host_display_client.cc
index 6189efbe8e..b042f2a56e 100644
--- a/electron/shell/browser/osr/osr_host_display_client.cc
+++ b/electron/shell/browser/osr/osr_host_display_client.cc
@@ -95,7 +95,7 @@ void OffScreenHostDisplayClient::CreateLayeredWindowUpdater(
   layered_window_updater_->SetActive(active_);
 }
 
-#if BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)
+#if (BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)) || BUILDFLAG(IS_BSD)
 void OffScreenHostDisplayClient::DidCompleteSwapWithNewSize(
     const gfx::Size& size) {}
 #endif
diff --git a/electron/shell/browser/osr/osr_host_display_client.h b/electron/shell/browser/osr/osr_host_display_client.h
index e95eb43bd1..7ad5b631f7 100644
--- a/electron/shell/browser/osr/osr_host_display_client.h
+++ b/electron/shell/browser/osr/osr_host_display_client.h
@@ -74,7 +74,7 @@ class OffScreenHostDisplayClient : public viz::HostDisplayClient {
       mojo::PendingReceiver<viz::mojom::LayeredWindowUpdater> receiver)
       override;
 
-#if BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)
+#if (BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)) || BUILDFLAG(IS_BSD)
   void DidCompleteSwapWithNewSize(const gfx::Size& size) override;
 #endif
 
diff --git a/electron/shell/browser/osr/osr_paint_event.h b/electron/shell/browser/osr/osr_paint_event.h
index 70985418fc..efe899a415 100644
--- a/electron/shell/browser/osr/osr_paint_event.h
+++ b/electron/shell/browser/osr/osr_paint_event.h
@@ -96,7 +96,7 @@ struct OffscreenSharedTextureValue {
   // On Windows it is a HANDLE to the shared D3D11 texture.
   // On macOS it is a IOSurface* to the shared IOSurface.
   uintptr_t shared_texture_handle;
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   std::vector<OffscreenNativePixmapPlaneInfo> planes;
   uint64_t modifier;
 #endif
diff --git a/electron/shell/browser/osr/osr_video_consumer.cc b/electron/shell/browser/osr/osr_video_consumer.cc
index 62efaf6261..d7fdb08288 100644
--- a/electron/shell/browser/osr/osr_video_consumer.cc
+++ b/electron/shell/browser/osr/osr_video_consumer.cc
@@ -103,7 +103,7 @@ void OffScreenVideoConsumer::OnFrameCaptured(
 #elif BUILDFLAG(IS_APPLE)
     texture.shared_texture_handle =
         reinterpret_cast<uintptr_t>(gmb_handle.io_surface.get());
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
     const auto& native_pixmap = gmb_handle.native_pixmap_handle;
     texture.modifier = native_pixmap.modifier;
     for (const auto& plane : native_pixmap.planes) {
diff --git a/electron/shell/browser/printing/printing_utils.cc b/electron/shell/browser/printing/printing_utils.cc
index 852a0c6dba..5a7d05569b 100644
--- a/electron/shell/browser/printing/printing_utils.cc
+++ b/electron/shell/browser/printing/printing_utils.cc
@@ -31,7 +31,7 @@
 #include <ApplicationServices/ApplicationServices.h>
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include <gtk/gtk.h>
 #endif
 
diff --git a/electron/shell/browser/relauncher_linux.cc b/electron/shell/browser/relauncher_linux.cc
index ee4e7b1c27..a9c079d137 100644
--- a/electron/shell/browser/relauncher_linux.cc
+++ b/electron/shell/browser/relauncher_linux.cc
@@ -6,8 +6,10 @@
 
 #include <fcntl.h>
 #include <signal.h>
+#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
 #include <sys/prctl.h>
 #include <sys/signalfd.h>
+#endif
 
 #include "base/files/scoped_file.h"
 #include "base/logging.h"
@@ -24,6 +26,10 @@ void RelauncherSynchronizeWithParent() {
   base::ScopedFD relauncher_sync_fd(kRelauncherSyncFD);
   static const auto signum = SIGUSR2;
 
+#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
+  PLOG(ERROR) << "signalfd & prctl";
+  fprintf(stderr, "Not Implemented signalfd & prctl in atom/browser/relauncher_linux.cc");
+#else
   // send signum to current process when parent process ends.
   if (HANDLE_EINTR(prctl(PR_SET_PDEATHSIG, signum)) != 0) {
     PLOG(ERROR) << "prctl";
@@ -48,6 +54,7 @@ void RelauncherSynchronizeWithParent() {
 
   // Wait for the parent to exit
   parentWaiter.Wait();
+#endif
 }
 
 int LaunchProgram(const StringVector& relauncher_args,
diff --git a/electron/shell/browser/ui/inspectable_web_contents.cc b/electron/shell/browser/ui/inspectable_web_contents.cc
index 82b64f66e8..28af5c9fe7 100644
--- a/electron/shell/browser/ui/inspectable_web_contents.cc
+++ b/electron/shell/browser/ui/inspectable_web_contents.cc
@@ -552,7 +552,7 @@ void InspectableWebContents::LoadCompleted() {
           prefs.FindString("currentDockState");
       base::RemoveChars(*current_dock_state, "\"", &dock_state_);
     }
-#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
     auto* api_web_contents = api::WebContents::From(GetWebContents());
     if (api_web_contents) {
       auto* win =
diff --git a/electron/shell/browser/ui/inspectable_web_contents_view_delegate.h b/electron/shell/browser/ui/inspectable_web_contents_view_delegate.h
index 46593888c4..62ad739447 100644
--- a/electron/shell/browser/ui/inspectable_web_contents_view_delegate.h
+++ b/electron/shell/browser/ui/inspectable_web_contents_view_delegate.h
@@ -24,7 +24,7 @@ class InspectableWebContentsViewDelegate {
   // Returns the icon of devtools window.
   virtual ui::ImageModel GetDevToolsWindowIcon();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Called when creating devtools window.
   virtual void GetDevToolsWindowWMClass(std::string* name,
                                         std::string* class_name) {}
diff --git a/electron/shell/browser/ui/views/electron_views_delegate.cc b/electron/shell/browser/ui/views/electron_views_delegate.cc
index eff63f089d..e8850e448b 100644
--- a/electron/shell/browser/ui/views/electron_views_delegate.cc
+++ b/electron/shell/browser/ui/views/electron_views_delegate.cc
@@ -9,7 +9,7 @@
 #include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
 #include "ui/views/widget/native_widget_aura.h"
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "base/environment.h"
 #include "base/nix/xdg_util.h"
 #include "ui/linux/linux_ui.h"
@@ -17,7 +17,7 @@
 
 namespace {
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 bool IsDesktopEnvironmentUnity() {
   auto env = base::Environment::Create();
   base::nix::DesktopEnvironment desktop_env =
@@ -54,7 +54,7 @@ void ViewsDelegate::NotifyMenuItemFocused(const std::u16string& menu_name,
                                           int item_count,
                                           bool has_submenu) {}
 
-#if BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)
+#if (BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)) || BUILDFLAG(IS_BSD)
 gfx::ImageSkia* ViewsDelegate::GetDefaultWindowIcon() const {
   return nullptr;
 }
@@ -82,7 +82,7 @@ void ViewsDelegate::OnBeforeWidgetInit(
 }
 
 bool ViewsDelegate::WindowManagerProvidesTitleBar(bool maximized) {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // On Ubuntu Unity, the system always provides a title bar for maximized
   // windows.
   if (!maximized)
diff --git a/electron/shell/browser/ui/views/electron_views_delegate.h b/electron/shell/browser/ui/views/electron_views_delegate.h
index 62298e240d..dfac551cc8 100644
--- a/electron/shell/browser/ui/views/electron_views_delegate.h
+++ b/electron/shell/browser/ui/views/electron_views_delegate.h
@@ -44,7 +44,7 @@ class ViewsDelegate : public views::ViewsDelegate {
   HICON GetSmallWindowIcon() const override;
   int GetAppbarAutohideEdges(HMONITOR monitor,
                              base::OnceClosure callback) override;
-#elif BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)
+#elif (BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_CHROMEOS)) || BUILDFLAG(IS_BSD)
   gfx::ImageSkia* GetDefaultWindowIcon() const override;
 #endif
   std::unique_ptr<views::NonClientFrameView> CreateDefaultNonClientFrameView(
diff --git a/electron/shell/browser/ui/views/inspectable_web_contents_view_views.cc b/electron/shell/browser/ui/views/inspectable_web_contents_view_views.cc
index 61a5b013ec..13ab9af420 100644
--- a/electron/shell/browser/ui/views/inspectable_web_contents_view_views.cc
+++ b/electron/shell/browser/ui/views/inspectable_web_contents_view_views.cc
@@ -193,7 +193,7 @@ void InspectableWebContentsViewViews::SetIsDocked(bool docked, bool activate) {
     params.delegate = devtools_window_delegate_;
     params.bounds = inspectable_web_contents()->dev_tools_bounds();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
     params.wm_role_name = "devtools";
     if (GetDelegate())
       GetDelegate()->GetDevToolsWindowWMClass(&params.wm_class_name,
diff --git a/electron/shell/browser/ui/views/menu_bar.cc b/electron/shell/browser/ui/views/menu_bar.cc
index 970d79da3c..6eef2255e3 100644
--- a/electron/shell/browser/ui/views/menu_bar.cc
+++ b/electron/shell/browser/ui/views/menu_bar.cc
@@ -14,7 +14,7 @@
 #include "ui/views/background.h"
 #include "ui/views/layout/box_layout.h"
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 #include "ui/gtk/gtk_util.h"  // nogncheck
 #endif
 
@@ -214,7 +214,7 @@ void MenuBar::ViewHierarchyChanged(
 
 void MenuBar::RefreshColorCache(const ui::NativeTheme* theme) {
   if (theme) {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
     background_color_ = gtk::GetBgColor("GtkMenuBar#menubar");
     enabled_color_ =
         gtk::GetFgColor("GtkMenuBar#menubar GtkMenuItem#menuitem GtkLabel");
@@ -239,7 +239,7 @@ void MenuBar::RebuildChildren() {
 }
 
 void MenuBar::UpdateViewColors() {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // set menubar background color
   SetBackground(views::CreateSolidBackground(background_color_));
 #endif
@@ -247,7 +247,7 @@ void MenuBar::UpdateViewColors() {
   // set child colors
   if (menu_model_ == nullptr)
     return;
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   const auto& textColor =
       window_->IsFocused() ? enabled_color_ : disabled_color_;
   for (views::View* child : GetChildrenInZOrder()) {
diff --git a/electron/shell/browser/ui/views/menu_bar.h b/electron/shell/browser/ui/views/menu_bar.h
index b2e1860ea2..6c9b983a5f 100644
--- a/electron/shell/browser/ui/views/menu_bar.h
+++ b/electron/shell/browser/ui/views/menu_bar.h
@@ -84,7 +84,7 @@ class MenuBar : public views::AccessiblePaneView,
   View* FindAccelChild(char16_t key);
 
   SkColor background_color_;
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   SkColor enabled_color_;
   SkColor disabled_color_;
 #endif
diff --git a/electron/shell/browser/ui/views/submenu_button.cc b/electron/shell/browser/ui/views/submenu_button.cc
index 730cccf1de..5fce434fe0 100644
--- a/electron/shell/browser/ui/views/submenu_button.cc
+++ b/electron/shell/browser/ui/views/submenu_button.cc
@@ -22,7 +22,7 @@ SubmenuButton::SubmenuButton(PressedCallback callback,
                              const SkColor& background_color)
     : views::MenuButton(std::move(callback), gfx::RemoveAccelerator(title)),
       background_color_(background_color) {
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Dont' use native style border.
   SetBorder(CreateDefaultBorder());
 #endif
diff --git a/electron/shell/common/api/electron_api_clipboard.cc b/electron/shell/common/api/electron_api_clipboard.cc
index b335ea7a41..4178e84c0a 100644
--- a/electron/shell/common/api/electron_api_clipboard.cc
+++ b/electron/shell/common/api/electron_api_clipboard.cc
@@ -58,7 +58,7 @@ std::string Clipboard::Read(const std::string& format_string) {
       ui::ClipboardFormatType::CustomPlatformType(format_string));
   bool rawFormatAvailable = clipboard->IsFormatAvailable(
       rawFormat, ui::ClipboardBuffer::kCopyPaste, /* data_dst = */ nullptr);
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (!rawFormatAvailable) {
     rawFormatAvailable = clipboard->IsFormatAvailable(
         rawFormat, ui::ClipboardBuffer::kSelection, /* data_dst = */ nullptr);
@@ -74,7 +74,7 @@ std::string Clipboard::Read(const std::string& format_string) {
   custom_format_names =
       clipboard->ExtractCustomPlatformNames(ui::ClipboardBuffer::kCopyPaste,
                                             /* data_dst = */ nullptr);
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   if (!custom_format_names.contains(format_string)) {
     custom_format_names =
         clipboard->ExtractCustomPlatformNames(ui::ClipboardBuffer::kSelection,
diff --git a/electron/shell/common/api/electron_api_native_image.cc b/electron/shell/common/api/electron_api_native_image.cc
index 18b468370f..041773dee8 100644
--- a/electron/shell/common/api/electron_api_native_image.cc
+++ b/electron/shell/common/api/electron_api_native_image.cc
@@ -640,7 +640,7 @@ void Initialize(v8::Local<v8::Object> exports,
   native_image.SetMethod("createFromDataURL", &NativeImage::CreateFromDataURL);
   native_image.SetMethod("createFromNamedImage",
                          &NativeImage::CreateFromNamedImage);
-#if !BUILDFLAG(IS_LINUX)
+#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_BSD)
   native_image.SetMethod("createThumbnailFromPath",
                          &NativeImage::CreateThumbnailFromPath);
 #endif
diff --git a/electron/shell/common/api/electron_api_native_image.h b/electron/shell/common/api/electron_api_native_image.h
index a840c51445..7ae476d812 100644
--- a/electron/shell/common/api/electron_api_native_image.h
+++ b/electron/shell/common/api/electron_api_native_image.h
@@ -80,7 +80,7 @@ class NativeImage final : public gin::Wrappable<NativeImage> {
                                                     const GURL& url);
   static gin::Handle<NativeImage> CreateFromNamedImage(gin::Arguments* args,
                                                        std::string name);
-#if !BUILDFLAG(IS_LINUX)
+#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_BSD)
   static v8::Local<v8::Promise> CreateThumbnailFromPath(
       v8::Isolate* isolate,
       const base::FilePath& path,
diff --git a/electron/shell/common/api/electron_bindings.cc b/electron/shell/common/api/electron_bindings.cc
index a2bc082ed0..f829167af6 100644
--- a/electron/shell/common/api/electron_bindings.cc
+++ b/electron/shell/common/api/electron_bindings.cc
@@ -254,7 +254,7 @@ void ElectronBindings::DidReceiveMemoryDump(
     if (target_pid == dump.pid()) {
       auto dict = gin_helper::Dictionary::CreateEmpty(isolate);
       const auto& osdump = dump.os_dump();
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_WIN)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_WIN) || BUILDFLAG(IS_BSD)
       dict.Set("residentSet", osdump.resident_set_kb);
 #endif
       dict.Set("private", osdump.private_footprint_kb);
diff --git a/electron/shell/common/electron_command_line.cc b/electron/shell/common/electron_command_line.cc
index bc50114cdb..1bac21fba3 100644
--- a/electron/shell/common/electron_command_line.cc
+++ b/electron/shell/common/electron_command_line.cc
@@ -26,7 +26,7 @@ void ElectronCommandLine::Init(int argc, base::CommandLine::CharType** argv) {
   argv_.assign(argv, argv + argc);
 }
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 // static
 void ElectronCommandLine::InitializeFromCommandLine() {
   argv_ = base::CommandLine::ForCurrentProcess()->argv();
diff --git a/electron/shell/common/electron_command_line.h b/electron/shell/common/electron_command_line.h
index b6c910016b..4284f1ffa9 100644
--- a/electron/shell/common/electron_command_line.h
+++ b/electron/shell/common/electron_command_line.h
@@ -22,7 +22,7 @@ class ElectronCommandLine {
 
   static void Init(int argc, base::CommandLine::CharType** argv);
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // On Linux the command line has to be read from base::CommandLine since
   // it is using zygote.
   static void InitializeFromCommandLine();
diff --git a/electron/shell/common/electron_paths.h b/electron/shell/common/electron_paths.h
index c614f99294..14e86f1103 100644
--- a/electron/shell/common/electron_paths.h
+++ b/electron/shell/common/electron_paths.h
@@ -30,7 +30,7 @@ enum {
   DIR_RECENT,  // Directory where recent files live
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   DIR_APP_DATA,  // Application Data directory under the user profile.
 #endif
 
diff --git a/electron/shell/common/gin_converters/osr_converter.cc b/electron/shell/common/gin_converters/osr_converter.cc
index 7ccc1d71ec..0f59d58181 100644
--- a/electron/shell/common/gin_converters/osr_converter.cc
+++ b/electron/shell/common/gin_converters/osr_converter.cc
@@ -117,7 +117,7 @@ v8::Local<v8::Value> Converter<electron::OffscreenSharedTextureValue>::ToV8(
           const_cast<uintptr_t*>(&val.shared_texture_handle)),
       sizeof(val.shared_texture_handle));
   dict.Set("sharedTextureHandle", handle_buf.ToLocalChecked());
-#elif BUILDFLAG(IS_LINUX)
+#elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   auto v8_planes = base::ToVector(val.planes, [isolate](const auto& plane) {
     gin::Dictionary v8_plane(isolate, v8::Object::New(isolate));
     v8_plane.Set("stride", plane.stride);
diff --git a/electron/shell/common/gin_converters/std_converter.h b/electron/shell/common/gin_converters/std_converter.h
index 5e829445f8..dbcbca857c 100644
--- a/electron/shell/common/gin_converters/std_converter.h
+++ b/electron/shell/common/gin_converters/std_converter.h
@@ -57,7 +57,7 @@ struct Converter<std::array<T, N>> {
   }
 };
 
-#if !BUILDFLAG(IS_LINUX)
+#if !BUILDFLAG(IS_LINUX) && !BUILDFLAG(IS_BSD)
 template <>
 struct Converter<unsigned long> {  // NOLINT(runtime/int)
   static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
diff --git a/electron/shell/common/node_bindings.cc b/electron/shell/common/node_bindings.cc
index ffcfa9d007..7587a59b6d 100644
--- a/electron/shell/common/node_bindings.cc
+++ b/electron/shell/common/node_bindings.cc
@@ -45,7 +45,7 @@
 #include "third_party/electron_node/src/debug_utils.h"
 #include "third_party/electron_node/src/module_wrap.h"
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
 #include "shell/common/crash_keys.h"
 #endif
 
@@ -159,7 +159,7 @@ bool g_is_initialized = false;
 void V8FatalErrorCallback(const char* location, const char* message) {
   LOG(ERROR) << "Fatal error in V8: " << location << " " << message;
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   electron::crash_keys::SetCrashKey("electron.v8-fatal.message", message);
   electron::crash_keys::SetCrashKey("electron.v8-fatal.location", location);
 #endif
@@ -535,7 +535,7 @@ void NodeBindings::Initialize(v8::Local<v8::Context> context) {
   TRACE_EVENT0("electron", "NodeBindings::Initialize");
   // Open node's error reporting system for browser process.
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Get real command line in renderer process forked by zygote.
   if (browser_env_ != BrowserEnvironment::kBrowser)
     ElectronCommandLine::InitializeFromCommandLine();
diff --git a/electron/shell/common/node_bindings_linux.cc b/electron/shell/common/node_bindings_linux.cc
index 7af0b151e6..7fffe56686 100644
--- a/electron/shell/common/node_bindings_linux.cc
+++ b/electron/shell/common/node_bindings_linux.cc
@@ -4,12 +4,25 @@
 
 #include "shell/common/node_bindings_linux.h"
 
+#if !defined(OS_BSD)
 #include <sys/epoll.h>
+#else
+#include <errno.h>
+#include <sys/select.h>
+#include <sys/sysctl.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#endif
 
 namespace electron {
 
 NodeBindingsLinux::NodeBindingsLinux(BrowserEnvironment browser_env)
+#if !defined(OS_BSD)
     : NodeBindings(browser_env), epoll_(epoll_create(1)) {
+#else
+    : NodeBindings(browser_env) {
+#endif
+#if !defined(OS_BSD)
   auto* const event_loop = uv_loop();
 
   int backend_fd = uv_backend_fd(event_loop);
@@ -17,11 +30,13 @@ NodeBindingsLinux::NodeBindingsLinux(BrowserEnvironment browser_env)
   ev.events = EPOLLIN;
   ev.data.fd = backend_fd;
   epoll_ctl(epoll_, EPOLL_CTL_ADD, backend_fd, &ev);
+#endif
 }
 
 void NodeBindingsLinux::PollEvents() {
   auto* const event_loop = uv_loop();
 
+#if !defined(OS_BSD)
   int timeout = uv_backend_timeout(event_loop);
 
   // Wait for new libuv events.
@@ -30,6 +45,26 @@ void NodeBindingsLinux::PollEvents() {
     struct epoll_event ev;
     r = epoll_wait(epoll_, &ev, 1, timeout);
   } while (r == -1 && errno == EINTR);
+#else
+  struct timeval tv;
+  int timeout = uv_backend_timeout(event_loop);
+  if (timeout != -1) {
+    tv.tv_sec = timeout / 1000;
+    tv.tv_usec = (timeout % 1000) * 1000;
+  }
+
+  fd_set readset;
+  int fd = uv_backend_fd(event_loop);
+  FD_ZERO(&readset);
+  FD_SET(fd, &readset);
+
+  // Wait for new libuv events.
+  int r;
+  do {
+    r = select(fd + 1, &readset, nullptr, nullptr,
+               timeout == -1 ? nullptr : &tv);
+   } while (r == -1 && errno == EINTR);
+#endif
 }
 
 // static
diff --git a/electron/shell/common/platform_util.h b/electron/shell/common/platform_util.h
index e67cfad9b4..ace4e42d1c 100644
--- a/electron/shell/common/platform_util.h
+++ b/electron/shell/common/platform_util.h
@@ -56,7 +56,7 @@ bool SetLoginItemEnabled(const std::string& type,
                          bool enabled);
 #endif
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
 // Returns a success flag.
 // Unlike libgtkui, does *not* use "chromium-browser.desktop" as a fallback.
 bool GetDesktopName(std::string* setme);
diff --git a/electron/shell/renderer/api/electron_api_crash_reporter_renderer.cc b/electron/shell/renderer/api/electron_api_crash_reporter_renderer.cc
index 1045eb611c..24b8c3b211 100644
--- a/electron/shell/renderer/api/electron_api_crash_reporter_renderer.cc
+++ b/electron/shell/renderer/api/electron_api_crash_reporter_renderer.cc
@@ -6,7 +6,7 @@
 #include "shell/common/gin_helper/dictionary.h"
 #include "shell/common/node_includes.h"
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
 #include "shell/common/crash_keys.h"
 #endif
 
@@ -14,13 +14,13 @@ namespace {
 
 v8::Local<v8::Value> GetParameters(v8::Isolate* isolate) {
   std::map<std::string, std::string> keys;
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   electron::crash_keys::GetCrashKeys(&keys);
 #endif
   return gin::ConvertToV8(isolate, keys);
 }
 
-#if IS_MAS_BUILD()
+#if IS_MAS_BUILD() || BUILDFLAG(IS_BSD)
 void SetCrashKeyStub(const std::string& key, const std::string& value) {}
 void ClearCrashKeyStub(const std::string& key) {}
 #endif
@@ -30,7 +30,7 @@ void Initialize(v8::Local<v8::Object> exports,
                 v8::Local<v8::Context> context,
                 void* priv) {
   gin_helper::Dictionary dict(context->GetIsolate(), exports);
-#if IS_MAS_BUILD()
+#if IS_MAS_BUILD() || BUILDFLAG(IS_BSD)
   dict.SetMethod("addExtraParameter", &SetCrashKeyStub);
   dict.SetMethod("removeExtraParameter", &ClearCrashKeyStub);
 #else
diff --git a/electron/shell/services/node/node_service.cc b/electron/shell/services/node/node_service.cc
index dd2c5743a9..4613a53284 100644
--- a/electron/shell/services/node/node_service.cc
+++ b/electron/shell/services/node/node_service.cc
@@ -22,7 +22,7 @@
 #include "shell/common/node_includes.h"
 #include "shell/services/node/parent_port.h"
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
 #include "shell/common/crash_keys.h"
 #endif
 
@@ -39,7 +39,7 @@ void V8FatalErrorCallback(const char* location, const char* message) {
     g_client_remote->OnV8FatalError(location, outstream.str());
   }
 
-#if !IS_MAS_BUILD()
+#if !IS_MAS_BUILD() && !BUILDFLAG(IS_BSD)
   electron::crash_keys::SetCrashKey("electron.v8-fatal.message", message);
   electron::crash_keys::SetCrashKey("electron.v8-fatal.location", location);
 #endif
diff --git a/electron/spec/api-app-spec.ts b/electron/spec/api-app-spec.ts
index 425bb2abaf..d84d0beff3 100644
--- a/electron/spec/api-app-spec.ts
+++ b/electron/spec/api-app-spec.ts
@@ -126,11 +126,11 @@ describe('app module', () => {
   });
 
   describe('app.getPreferredSystemLanguages()', () => {
-    ifit(process.platform !== 'linux')('should not be empty', () => {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('should not be empty', () => {
       expect(app.getPreferredSystemLanguages().length).to.not.equal(0);
     });
 
-    ifit(process.platform === 'linux')('should be empty or contain C entry', () => {
+    ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('should be empty or contain C entry', () => {
       const languages = app.getPreferredSystemLanguages();
       if (languages.length) {
         expect(languages).to.not.include('C');
@@ -193,7 +193,7 @@ describe('app module', () => {
       expect(code).to.equal(123, 'exit code should be 123, if you see this please tag @MarshallOfSound');
     });
 
-    ifit(['darwin', 'linux'].includes(process.platform))('exits gracefully', async function () {
+    ifit(['darwin', 'linux', 'freebsd', 'netbsd'].includes(process.platform))('exits gracefully', async function () {
       const electronPath = process.execPath;
       const appPath = path.join(fixturesPath, 'api', 'singleton');
       appProcess = cp.spawn(electronPath, [appPath]);
@@ -447,7 +447,7 @@ describe('app module', () => {
   //   let w = null
 
   //   before(function () {
-  //     if (process.platform !== 'linux') {
+  //     if (process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') {
   //       this.skip()
   //     }
   //   })
@@ -554,7 +554,7 @@ describe('app module', () => {
   describe('app.badgeCount', () => {
     const platformIsNotSupported =
         (process.platform === 'win32') ||
-        (process.platform === 'linux' && !app.isUnityRunning());
+	((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && !app.isUnityRunning());
 
     const expectedBadgeCount = 42;
 
@@ -598,7 +598,7 @@ describe('app module', () => {
     });
   });
 
-  ifdescribe(process.platform !== 'linux' && !process.mas && (process.platform !== 'darwin' || process.arch === 'arm64'))('app.get/setLoginItemSettings API', function () {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd' && !process.mas && (process.platform !== 'darwin' || process.arch === 'arm64'))('app.get/setLoginItemSettings API', function () {
     const isMac = process.platform === 'darwin';
     const isWin = process.platform === 'win32';
 
@@ -978,7 +978,7 @@ describe('app module', () => {
     });
   });
 
-  ifdescribe(process.platform !== 'linux')('accessibilitySupportEnabled property', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('accessibilitySupportEnabled property', () => {
     it('with properties', () => {
       it('can set accessibility support enabled', () => {
         expect(app.accessibilitySupportEnabled).to.eql(false);
@@ -1178,7 +1178,7 @@ describe('app module', () => {
     });
   });
 
-  ifdescribe(process.platform !== 'linux')('select-client-certificate event', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('select-client-certificate event', () => {
     let w: BrowserWindow;
 
     before(function () {
@@ -1313,7 +1313,7 @@ describe('app module', () => {
 
   describe('getApplicationNameForProtocol()', () => {
     // TODO: Linux CI doesn't have registered http & https handlers
-    ifit(!(process.env.CI && process.platform === 'linux'))('returns application names for common protocols', function () {
+    ifit(!(process.env.CI && (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')))('returns application names for common protocols', function () {
       // We can't expect particular app names here, but these protocols should
       // at least have _something_ registered. Except on our Linux CI
       // environment apparently.
@@ -1331,7 +1331,7 @@ describe('app module', () => {
     });
   });
 
-  ifdescribe(process.platform !== 'linux')('getApplicationInfoForProtocol()', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('getApplicationInfoForProtocol()', () => {
     it('returns promise rejection for a bogus protocol', async function () {
       await expect(
         app.getApplicationInfoForProtocol('bogus-protocol://')
@@ -1381,7 +1381,7 @@ describe('app module', () => {
   });
 
   // FIXME Get these specs running on Linux CI
-  ifdescribe(process.platform !== 'linux')('getFileIcon() API', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('getFileIcon() API', () => {
     const iconPath = path.join(__dirname, 'fixtures/assets/icon.ico');
     const sizes = {
       small: 16,
@@ -1463,7 +1463,7 @@ describe('app module', () => {
           expect(entry.memory).to.have.property('privateBytes').that.is.greaterThan(0);
         }
 
-        if (process.platform !== 'linux') {
+        if (process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') {
           expect(entry.sandboxed).to.be.a('boolean');
         }
 
@@ -1537,7 +1537,7 @@ describe('app module', () => {
 
     it('succeeds with complete GPUInfo', async () => {
       const completeInfo = await getGPUInfo('complete');
-      if (process.platform === 'linux') {
+      if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
         // For linux and macOS complete info is same as basic info
         await verifyBasicGPUInfo(completeInfo);
         const basicInfo = await getGPUInfo('basic');
@@ -1561,7 +1561,7 @@ describe('app module', () => {
     });
   });
 
-  ifdescribe(!(process.platform === 'linux' && (process.arch === 'arm64' || process.arch === 'arm')))('sandbox options', () => {
+  ifdescribe(!((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && (process.arch === 'arm64' || process.arch === 'arm')))('sandbox options', () => {
     let appProcess: cp.ChildProcess = null as any;
     let server: net.Server = null as any;
     const socketPath = process.platform === 'win32' ? '\\\\.\\pipe\\electron-mixed-sandbox' : '/tmp/electron-mixed-sandbox';
diff --git a/electron/spec/api-browser-window-spec.ts b/electron/spec/api-browser-window-spec.ts
index 068414b306..6c828fed36 100755
--- a/electron/spec/api-browser-window-spec.ts
+++ b/electron/spec/api-browser-window-spec.ts
@@ -69,7 +69,7 @@ describe('BrowserWindow module', () => {
       }).not.to.throw();
     });
 
-    ifit(process.platform === 'linux')('does not crash when setting large window icons', async () => {
+    ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('does not crash when setting large window icons', async () => {
       const appPath = path.join(fixtures, 'apps', 'xwindow-icon');
       const appProcess = childProcess.spawn(process.execPath, [appPath]);
       await once(appProcess, 'exit');
@@ -296,7 +296,7 @@ describe('BrowserWindow module', () => {
     });
   });
 
-  ifdescribe(process.platform !== 'linux')('BrowserWindow.getContentProtection', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('BrowserWindow.getContentProtection', () => {
     afterEach(closeAllWindows);
     it('can set content protection', async () => {
       const w = new BrowserWindow({ show: false });
@@ -1170,7 +1170,7 @@ describe('BrowserWindow module', () => {
 
     describe('BrowserWindow.minimize()', () => {
       // TODO(codebytere): Enable for Linux once maximize/minimize events work in CI.
-      ifit(process.platform !== 'linux')('should not be visible when the window is minimized', async () => {
+      ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('should not be visible when the window is minimized', async () => {
         const minimize = once(w, 'minimize');
         w.minimize();
         await minimize;
@@ -1187,7 +1187,7 @@ describe('BrowserWindow module', () => {
       });
 
       // TODO(dsanders11): Enable for Linux once CI plays nice with these kinds of tests
-      ifit(process.platform !== 'linux')('should not restore maximized windows', async () => {
+      ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('should not restore maximized windows', async () => {
         const maximize = once(w, 'maximize');
         const shown = once(w, 'show');
         w.maximize();
@@ -1252,7 +1252,7 @@ describe('BrowserWindow module', () => {
         expect(w.isFocused()).to.equal(true);
       });
 
-      ifit(process.platform !== 'linux')('acquires focus status from the other windows', async () => {
+      ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('acquires focus status from the other windows', async () => {
         const w1 = new BrowserWindow({ show: false });
         const w2 = new BrowserWindow({ show: false });
         const w3 = new BrowserWindow({ show: false });
@@ -1353,7 +1353,7 @@ describe('BrowserWindow module', () => {
         expect(w.isFocused()).to.equal(false);
       });
 
-      ifit(process.platform !== 'linux')('transfers focus status to the next window', async () => {
+      ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('transfers focus status to the next window', async () => {
         const w1 = new BrowserWindow({ show: false });
         const w2 = new BrowserWindow({ show: false });
         const w3 = new BrowserWindow({ show: false });
@@ -1812,7 +1812,7 @@ describe('BrowserWindow module', () => {
         });
       });
 
-      ifdescribe(process.platform !== 'linux')('Maximized state', () => {
+      ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('Maximized state', () => {
         it('checks normal bounds when maximized', async () => {
           const bounds = w.getBounds();
           const maximize = once(w, 'maximize');
@@ -2022,7 +2022,7 @@ describe('BrowserWindow module', () => {
         });
       });
 
-      ifdescribe(process.platform !== 'linux')('Minimized state', () => {
+      ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('Minimized state', () => {
         it('checks normal bounds when minimized', async () => {
           const bounds = w.getBounds();
           const minimize = once(w, 'minimize');
@@ -2986,7 +2986,7 @@ describe('BrowserWindow module', () => {
   describe('BrowserWindow.setOpacity(opacity)', () => {
     afterEach(closeAllWindows);
 
-    ifdescribe(process.platform !== 'linux')(('Windows and Mac'), () => {
+    ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')(('Windows and Mac'), () => {
       it('make window with initial opacity', () => {
         const w = new BrowserWindow({ show: false, opacity: 0.5 });
         expect(w.getOpacity()).to.equal(0.5);
@@ -3012,7 +3012,7 @@ describe('BrowserWindow module', () => {
       });
     });
 
-    ifdescribe(process.platform === 'linux')(('Linux'), () => {
+    ifdescribe(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')(('Linux'), () => {
       it('sets 1 regardless of parameter', () => {
         const w = new BrowserWindow({ show: false });
         w.setOpacity(0);
@@ -3223,7 +3223,7 @@ describe('BrowserWindow module', () => {
       expect(overlayRectPreMax.height).to.equal(size);
 
       // 'maximize' event is not emitted on Linux in CI.
-      if (process.platform !== 'linux' && !w.isMaximized()) {
+      if ((process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') && !w.isMaximized()) {
         const maximize = once(w, 'maximize');
         w.show();
         w.maximize();
@@ -3289,7 +3289,7 @@ describe('BrowserWindow module', () => {
         expect(preMaxHeight).to.equal(size);
 
         // 'maximize' event is not emitted on Linux in CI.
-        if (process.platform !== 'linux' && !w.isMaximized()) {
+        if ((process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') && !w.isMaximized()) {
           const maximize = once(w, 'maximize');
           w.show();
           w.maximize();
@@ -3954,7 +3954,7 @@ describe('BrowserWindow module', () => {
         expect(test.nodeTimers).to.equal(true);
         expect(test.nodeUrl).to.equal(true);
 
-        if (process.platform === 'linux' && test.osSandbox) {
+        if ((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && test.osSandbox) {
           expect(test.creationTime).to.be.null('creation time');
           expect(test.systemMemoryInfo).to.be.null('system memory info');
         } else {
@@ -4459,7 +4459,7 @@ describe('BrowserWindow module', () => {
     });
   });
 
-  ifdescribe(process.platform !== 'linux')('max/minimize events', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('max/minimize events', () => {
     afterEach(closeAllWindows);
     it('emits an event when window is maximized', async () => {
       const w = new BrowserWindow({ show: false });
@@ -4730,7 +4730,7 @@ describe('BrowserWindow module', () => {
     // TODO(zcbenz):
     // This test does not run on Linux CI. See:
     // https://github.com/electron/electron/issues/28699
-    ifit(process.platform === 'linux' && !process.env.CI)('should bring a minimized maximized window back to maximized state', async () => {
+    ifit((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && !process.env.CI)('should bring a minimized maximized window back to maximized state', async () => {
       const w = new BrowserWindow({});
       const maximize = once(w, 'maximize');
       w.maximize();
@@ -4747,7 +4747,7 @@ describe('BrowserWindow module', () => {
   });
 
   // TODO(dsanders11): Enable once maximize event works on Linux again on CI
-  ifdescribe(process.platform !== 'linux')('BrowserWindow.maximize()', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('BrowserWindow.maximize()', () => {
     afterEach(closeAllWindows);
     it('should show the window if it is not currently shown', async () => {
       const w = new BrowserWindow({ show: false });
@@ -4784,7 +4784,7 @@ describe('BrowserWindow module', () => {
 
     // TODO(dsanders11): Enable once minimize event works on Linux again.
     //                   See https://github.com/electron/electron/issues/28699
-    ifit(process.platform !== 'linux')('should not restore a minimized window', async () => {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('should not restore a minimized window', async () => {
       const w = new BrowserWindow();
       const minimize = once(w, 'minimize');
       w.minimize();
@@ -5270,7 +5270,7 @@ describe('BrowserWindow module', () => {
       });
 
       // On Linux there is no "resizable" property of a window.
-      ifit(process.platform !== 'linux')('does affect maximizability when disabled and enabled', () => {
+      ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('does affect maximizability when disabled and enabled', () => {
         const w = new BrowserWindow({ show: false });
         expect(w.resizable).to.be.true('resizable');
 
@@ -5480,7 +5480,7 @@ describe('BrowserWindow module', () => {
     });
   });
 
-  ifdescribe(process.platform !== 'linux')('window states (excluding Linux)', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('window states (excluding Linux)', () => {
     // Not implemented on Linux.
     afterEach(closeAllWindows);
 
@@ -6654,7 +6654,7 @@ describe('BrowserWindow module', () => {
   describe('"transparent" option', () => {
     afterEach(closeAllWindows);
 
-    ifit(process.platform !== 'linux')('correctly returns isMaximized() when the window is maximized then minimized', async () => {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('correctly returns isMaximized() when the window is maximized then minimized', async () => {
       const w = new BrowserWindow({
         frame: false,
         transparent: true
diff --git a/electron/spec/api-clipboard-spec.ts b/electron/spec/api-clipboard-spec.ts
index 3befd1a954..eeeea8ad6b 100644
--- a/electron/spec/api-clipboard-spec.ts
+++ b/electron/spec/api-clipboard-spec.ts
@@ -54,7 +54,7 @@ ifdescribe(process.platform !== 'win32' || process.arch !== 'arm64')('clipboard
     });
   });
 
-  ifdescribe(process.platform !== 'linux')('clipboard.readBookmark', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('clipboard.readBookmark', () => {
     it('returns title and url', () => {
       clipboard.writeBookmark('a title', 'https://electronjs.org');
 
@@ -73,7 +73,7 @@ ifdescribe(process.platform !== 'win32' || process.arch !== 'arm64')('clipboard
   });
 
   describe('clipboard.read()', () => {
-    ifit(process.platform !== 'linux')('does not crash when reading various custom clipboard types', () => {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('does not crash when reading various custom clipboard types', () => {
       const type = process.platform === 'darwin' ? 'NSFilenamesPboardType' : 'FileNameW';
 
       expect(() => {
@@ -114,7 +114,7 @@ ifdescribe(process.platform !== 'win32' || process.arch !== 'arm64')('clipboard
       const readImage = clipboard.readImage();
       expect(readImage.toDataURL()).to.equal(i.toDataURL());
 
-      if (process.platform !== 'linux') {
+      if (process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') {
         if (process.platform !== 'win32') {
           expect(clipboard.readBookmark()).to.deep.equal(bookmark);
         } else {
diff --git a/electron/spec/api-content-tracing-spec.ts b/electron/spec/api-content-tracing-spec.ts
index b584b1a818..2e7ac919c7 100644
--- a/electron/spec/api-content-tracing-spec.ts
+++ b/electron/spec/api-content-tracing-spec.ts
@@ -9,7 +9,7 @@ import { setTimeout } from 'node:timers/promises';
 import { ifdescribe } from './lib/spec-helpers';
 
 // FIXME: The tests are skipped on linux arm/arm64
-ifdescribe(!(['arm', 'arm64'].includes(process.arch)) || (process.platform !== 'linux'))('contentTracing', () => {
+ifdescribe(!(['arm', 'arm64'].includes(process.arch)) || (process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd'))('contentTracing', () => {
   const record = async (options: TraceConfig | TraceCategoriesAndOptions, outputFilePath: string | undefined, recordTimeInMilliseconds = 1e1) => {
     await app.whenReady();
 
diff --git a/electron/spec/api-crash-reporter-spec.ts b/electron/spec/api-crash-reporter-spec.ts
index 7dd31a9917..92a47c464c 100644
--- a/electron/spec/api-crash-reporter-spec.ts
+++ b/electron/spec/api-crash-reporter-spec.ts
@@ -14,7 +14,7 @@ import { setTimeout } from 'node:timers/promises';
 import { ifdescribe, ifit, defer, startRemoteControlApp, repeatedly, listen } from './lib/spec-helpers';
 
 const isWindowsOnArm = process.platform === 'win32' && process.arch === 'arm64';
-const isLinuxOnArm = process.platform === 'linux' && process.arch.includes('arm');
+const isLinuxOnArm = ((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && process.arch.includes('arm'));
 
 type CrashInfo = {
   prod: string
@@ -47,7 +47,7 @@ function checkCrash (expectedProcessType: string, fields: CrashInfo) {
 
   // TODO(nornagon): minidumps are sometimes (not always) turning up empty on
   // 32-bit Linux.  Figure out why.
-  if (!(process.platform === 'linux' && process.arch === 'ia32')) {
+  if (!((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && process.arch === 'ia32')) {
     expect(fields.upload_file_minidump.length).to.be.greaterThan(0);
   }
 }
@@ -184,7 +184,7 @@ ifdescribe(!isLinuxOnArm && !process.mas && !process.env.DISABLE_CRASH_REPORTER_
 
     // Ensures that passing in crashpadHandlerPID flag for Linx child processes
     // does not affect child process args.
-    ifit(process.platform === 'linux')('ensure linux child process args are not modified', async () => {
+    ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('ensure linux child process args are not modified', async () => {
       const { port, waitForCrash } = await startServer();
       let exitCode: number | null = null;
       const appPath = path.join(__dirname, 'fixtures', 'apps', 'crash');
@@ -533,7 +533,7 @@ ifdescribe(!isLinuxOnArm && !process.mas && !process.env.DISABLE_CRASH_REPORTER_
       }
     }
 
-    const processList = process.platform === 'linux'
+    const processList = (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')
       ? ['main', 'renderer', 'sandboxed-renderer']
       : ['main', 'renderer', 'sandboxed-renderer', 'node'];
     for (const crashingProcess of processList) {
@@ -546,7 +546,7 @@ ifdescribe(!isLinuxOnArm && !process.mas && !process.env.DISABLE_CRASH_REPORTER_
             return app.getPath('crashDumps');
           });
           let reportsDir = crashesDir;
-          if (process.platform === 'darwin' || process.platform === 'linux') {
+          if (process.platform === 'darwin' || process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
             reportsDir = path.join(crashesDir, 'completed');
           } else if (process.platform === 'win32') {
             reportsDir = path.join(crashesDir, 'reports');
@@ -570,7 +570,7 @@ ifdescribe(!isLinuxOnArm && !process.mas && !process.env.DISABLE_CRASH_REPORTER_
           expect(remoteCrashesDir).to.equal(crashesDir);
 
           let reportsDir = crashesDir;
-          if (process.platform === 'darwin' || process.platform === 'linux') {
+          if (process.platform === 'darwin' || process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
             reportsDir = path.join(crashesDir, 'completed');
           } else if (process.platform === 'win32') {
             reportsDir = path.join(crashesDir, 'reports');
diff --git a/electron/spec/api-desktop-capturer-spec.ts b/electron/spec/api-desktop-capturer-spec.ts
index a3ff4df4a3..b5e96c5ea4 100644
--- a/electron/spec/api-desktop-capturer-spec.ts
+++ b/electron/spec/api-desktop-capturer-spec.ts
@@ -45,7 +45,7 @@ ifdescribe(!process.arch.includes('arm') && process.platform !== 'win32')('deskt
   });
 
   // Linux doesn't return any window sources.
-  ifit(process.platform !== 'linux')('returns an empty display_id for window sources', async () => {
+  ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('returns an empty display_id for window sources', async () => {
     const w = new BrowserWindow({ width: 200, height: 200 });
     await w.loadURL('about:blank');
 
@@ -57,7 +57,7 @@ ifdescribe(!process.arch.includes('arm') && process.platform !== 'win32')('deskt
     }
   });
 
-  ifit(process.platform !== 'linux')('returns display_ids matching the Screen API', async () => {
+  ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('returns display_ids matching the Screen API', async () => {
     const displays = screen.getAllDisplays();
     const sources = await desktopCapturer.getSources({ types: ['screen'] });
     expect(sources).to.be.an('array').of.length(displays.length);
@@ -118,7 +118,7 @@ ifdescribe(!process.arch.includes('arm') && process.platform !== 'win32')('deskt
     // TODO(julien.isorce): investigate why |sources| is empty on the linux
     // bots while it is not on my workstation, as expected, with and without
     // the --ci parameter.
-    if (process.platform === 'linux' && sources.length === 0) {
+    if ((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && sources.length === 0) {
       it.skip('desktopCapturer.getSources returned an empty source list');
       return;
     }
@@ -154,7 +154,7 @@ ifdescribe(!process.arch.includes('arm') && process.platform !== 'win32')('deskt
     // TODO(julien.isorce): investigate why |sources| is empty on the linux
     // bots while it is not on my workstation, as expected, with and without
     // the --ci parameter.
-    if (process.platform === 'linux' && sources.length === 0) {
+    if ((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && sources.length === 0) {
       it.skip('desktopCapturer.getSources returned an empty source list');
       return;
     }
@@ -223,7 +223,7 @@ ifdescribe(!process.arch.includes('arm') && process.platform !== 'win32')('deskt
       // TODO(julien.isorce): investigate why |sources| is empty on the linux
       // bots while it is not on my workstation, as expected, with and without
       // the --ci parameter.
-      if (process.platform === 'linux' && sources.length === 0) {
+      if ((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && sources.length === 0) {
         destroyWindows();
         it.skip('desktopCapturer.getSources returned an empty source list');
         return;
diff --git a/electron/spec/api-menu-spec.ts b/electron/spec/api-menu-spec.ts
index e3343e8cf1..7cca4dd888 100644
--- a/electron/spec/api-menu-spec.ts
+++ b/electron/spec/api-menu-spec.ts
@@ -890,7 +890,7 @@ describe('Menu module', function () {
     // https://github.com/electron/electron/issues/35724
     // Maximizing window is enough to trigger the bug
     // FIXME(dsanders11): Test always passes on CI, even pre-fix
-    ifit(process.platform === 'linux' && !process.env.CI)('does not trigger issue #35724', (done) => {
+    ifit((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && !process.env.CI)('does not trigger issue #35724', (done) => {
       const showAndCloseMenu = async () => {
         await setTimeout(1000);
         menu.popup({ window: w, x: 50, y: 50 });
diff --git a/electron/spec/api-native-image-spec.ts b/electron/spec/api-native-image-spec.ts
index bbd30cff7a..94caf281bf 100644
--- a/electron/spec/api-native-image-spec.ts
+++ b/electron/spec/api-native-image-spec.ts
@@ -428,7 +428,7 @@ describe('nativeImage module', () => {
     });
   });
 
-  ifdescribe(process.platform !== 'linux')('createThumbnailFromPath(path, size)', () => {
+  ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('createThumbnailFromPath(path, size)', () => {
     useRemoteContext({ webPreferences: { contextIsolation: false, nodeIntegration: true } });
 
     it('throws when invalid size is passed', async () => {
diff --git a/electron/spec/api-net-log-spec.ts b/electron/spec/api-net-log-spec.ts
index 40781d5954..38a2186b8d 100644
--- a/electron/spec/api-net-log-spec.ts
+++ b/electron/spec/api-net-log-spec.ts
@@ -121,7 +121,7 @@ describe('netLog module', () => {
     expect(JSON.parse(dump).events.some((x: any) => x.params && x.params.bytes && Buffer.from(x.params.bytes, 'base64').includes(unique))).to.be.true('uuid present in dump');
   });
 
-  ifit(process.platform !== 'linux')('should begin and end logging automatically when --log-net-log is passed', async () => {
+  ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('should begin and end logging automatically when --log-net-log is passed', async () => {
     const appProcess = ChildProcess.spawn(process.execPath,
       [appPath], {
         env: {
@@ -134,7 +134,7 @@ describe('netLog module', () => {
     expect(fs.existsSync(dumpFile)).to.be.true('dump file exists');
   });
 
-  ifit(process.platform !== 'linux')('should begin and end logging automatically when --log-net-log is passed, and behave correctly when .startLogging() and .stopLogging() is called', async () => {
+  ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('should begin and end logging automatically when --log-net-log is passed, and behave correctly when .startLogging() and .stopLogging() is called', async () => {
     const appProcess = ChildProcess.spawn(process.execPath,
       [appPath], {
         env: {
@@ -150,7 +150,7 @@ describe('netLog module', () => {
     expect(fs.existsSync(dumpFileDynamic)).to.be.true('dynamic dump file exists');
   });
 
-  ifit(process.platform !== 'linux')('should end logging automatically when only .startLogging() is called', async () => {
+  ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('should end logging automatically when only .startLogging() is called', async () => {
     const appProcess = ChildProcess.spawn(process.execPath,
       [appPath], {
         env: {
diff --git a/electron/spec/api-notification-dbus-spec.ts b/electron/spec/api-notification-dbus-spec.ts
index a601296536..7d6cfd726d 100644
--- a/electron/spec/api-notification-dbus-spec.ts
+++ b/electron/spec/api-notification-dbus-spec.ts
@@ -19,7 +19,7 @@ import { ifdescribe } from './lib/spec-helpers';
 
 const fixturesPath = path.join(__dirname, 'fixtures');
 
-const skip = process.platform !== 'linux' ||
+const skip = (process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') ||
              process.arch === 'ia32' ||
              process.arch.indexOf('arm') === 0 ||
              !process.env.DBUS_SESSION_BUS_ADDRESS;
diff --git a/electron/spec/api-power-monitor-spec.ts b/electron/spec/api-power-monitor-spec.ts
index 47a2e6cdab..d16f88b0ee 100644
--- a/electron/spec/api-power-monitor-spec.ts
+++ b/electron/spec/api-power-monitor-spec.ts
@@ -18,7 +18,7 @@ import { ifdescribe, startRemoteControlApp } from './lib/spec-helpers';
 describe('powerMonitor', () => {
   let logindMock: any, dbusMockPowerMonitor: any, getCalls: any, emitSignal: any, reset: any;
 
-  ifdescribe(process.platform === 'linux' && process.env.DBUS_SYSTEM_BUS_ADDRESS != null)('when powerMonitor module is loaded with dbus mock', () => {
+  ifdescribe((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && process.env.DBUS_SYSTEM_BUS_ADDRESS != null)('when powerMonitor module is loaded with dbus mock', () => {
     before(async () => {
       const systemBus = dbus.systemBus();
       const loginService = systemBus.getService('org.freedesktop.login1');
diff --git a/electron/spec/api-process-spec.ts b/electron/spec/api-process-spec.ts
index 81e045a0ac..460d93ca69 100644
--- a/electron/spec/api-process-spec.ts
+++ b/electron/spec/api-process-spec.ts
@@ -39,7 +39,7 @@ describe('process module', () => {
       it('resolves promise successfully with valid data', async () => {
         const memoryInfo = await invoke(() => process.getProcessMemoryInfo());
         expect(memoryInfo).to.be.an('object');
-        if (process.platform === 'linux' || process.platform === 'win32') {
+        if (process.platform === 'linux' || process.platform === 'win32' || process.platform === 'freebsd' || process.platform === 'netbsd') {
           expect(memoryInfo.residentSet).to.be.a('number').greaterThan(0);
         }
         expect(memoryInfo.private).to.be.a('number').greaterThan(0);
diff --git a/electron/spec/api-protocol-spec.ts b/electron/spec/api-protocol-spec.ts
index bdbdd9d383..1141024f78 100644
--- a/electron/spec/api-protocol-spec.ts
+++ b/electron/spec/api-protocol-spec.ts
@@ -1738,7 +1738,7 @@ describe('protocol module', () => {
 
     // TODO(nornagon): this test doesn't pass on Linux currently, investigate.
     // test is also flaky on CI on macOS so it is currently disabled there as well.
-    ifit(process.platform !== 'linux' && (!process.env.CI || process.platform !== 'darwin'))('is fast', async () => {
+    ifit((process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') && (!process.env.CI || process.platform !== 'darwin'))('is fast', async () => {
       // 128 MB of spaces.
       const chunk = new Uint8Array(128 * 1024 * 1024);
       chunk.fill(' '.charCodeAt(0));
diff --git a/electron/spec/api-safe-storage-spec.ts b/electron/spec/api-safe-storage-spec.ts
index b8d9c1358a..7696274225 100644
--- a/electron/spec/api-safe-storage-spec.ts
+++ b/electron/spec/api-safe-storage-spec.ts
@@ -29,7 +29,7 @@ describe('safeStorage module', () => {
 
 describe('safeStorage module', () => {
   before(() => {
-    if (process.platform === 'linux') {
+    if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
       safeStorage.setUsePlainTextEncryption(true);
     }
   });
@@ -47,7 +47,7 @@ describe('safeStorage module', () => {
     });
   });
 
-  ifdescribe(process.platform === 'linux')('SafeStorage.getSelectedStorageBackend()', () => {
+  ifdescribe(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('SafeStorage.getSelectedStorageBackend()', () => {
     it('should return a valid backend', () => {
       expect(safeStorage.getSelectedStorageBackend()).to.equal('basic_text');
     });
diff --git a/electron/spec/api-screen-spec.ts b/electron/spec/api-screen-spec.ts
index 1c3141c4e6..3a88437a7c 100644
--- a/electron/spec/api-screen-spec.ts
+++ b/electron/spec/api-screen-spec.ts
@@ -95,7 +95,7 @@ describe('screen module', () => {
 
       const { size } = display!;
 
-      if (process.platform === 'linux') {
+      if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
         expect(size).to.have.property('width').that.is.a('number');
         expect(size).to.have.property('height').that.is.a('number');
       } else {
@@ -109,7 +109,7 @@ describe('screen module', () => {
 
       const { workAreaSize } = display!;
 
-      if (process.platform === 'linux') {
+      if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
         expect(workAreaSize).to.have.property('width').that.is.a('number');
         expect(workAreaSize).to.have.property('height').that.is.a('number');
       } else {
@@ -125,7 +125,7 @@ describe('screen module', () => {
       expect(bounds).to.have.property('x').that.is.a('number');
       expect(bounds).to.have.property('y').that.is.a('number');
 
-      if (process.platform === 'linux') {
+      if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
         expect(bounds).to.have.property('width').that.is.a('number');
         expect(bounds).to.have.property('height').that.is.a('number');
       } else {
diff --git a/electron/spec/api-shell-spec.ts b/electron/spec/api-shell-spec.ts
index 643c780ed4..7c2f438b8a 100644
--- a/electron/spec/api-shell-spec.ts
+++ b/electron/spec/api-shell-spec.ts
@@ -37,7 +37,7 @@ describe('shell module', () => {
 
     afterEach(async () => {
       // reset env vars to prevent side effects
-      if (process.platform === 'linux') {
+      if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
         process.env.DE = envVars.de;
         process.env.BROWSER = envVars.browser;
         process.env.DISPLAY = envVars.display;
@@ -57,6 +57,16 @@ describe('shell module', () => {
         process.env.DE = 'generic';
         process.env.DISPLAY = '';
         requestReceived = Promise.resolve();
+      } else if (process.platform === 'freebsd' || process.platform === 'openbsd' || process.platform === 'netbsd') {
+        process.env.BROWSER = '/usr/bin/true';
+        process.env.DE = 'generic';
+        process.env.DISPLAY = '';
+        requestReceived = Promise.resolve();
+      } else if (process.platform === 'netbsd') {
+        process.env.BROWSER = '/usr/bin/true';
+        process.env.DE = 'generic';
+        process.env.DISPLAY = '';
+        requestReceived = Promise.resolve();
       } else if (process.platform === 'darwin') {
         // On the Mac CI machines, Safari tries to ask for a password to the
         // code signing keychain we set up to test code signing (see
diff --git a/electron/spec/api-subframe-spec.ts b/electron/spec/api-subframe-spec.ts
index 66b5dcc00e..91984f3cc5 100644
--- a/electron/spec/api-subframe-spec.ts
+++ b/electron/spec/api-subframe-spec.ts
@@ -218,7 +218,7 @@ describe('renderer nodeIntegrationInSubFrames', () => {
 });
 
 // app.getAppMetrics() does not return sandbox information on Linux.
-ifdescribe(process.platform !== 'linux')('cross-site frame sandboxing', () => {
+ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('cross-site frame sandboxing', () => {
   let server: http.Server;
   let crossSiteUrl: string;
   let serverUrl: string;
diff --git a/electron/spec/api-tray-spec.ts b/electron/spec/api-tray-spec.ts
index f56ba1e695..658bf9fa79 100644
--- a/electron/spec/api-tray-spec.ts
+++ b/electron/spec/api-tray-spec.ts
@@ -131,7 +131,7 @@ describe('tray module', () => {
   describe('tray.getBounds()', () => {
     afterEach(() => { tray.destroy(); });
 
-    ifit(process.platform !== 'linux')('returns a bounds object', function () {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('returns a bounds object', function () {
       const bounds = tray.getBounds();
       expect(bounds).to.be.an('object').and.to.have.all.keys('x', 'y', 'width', 'height');
     });
diff --git a/electron/spec/api-utility-process-spec.ts b/electron/spec/api-utility-process-spec.ts
index bc3f95c784..a9510efe07 100644
--- a/electron/spec/api-utility-process-spec.ts
+++ b/electron/spec/api-utility-process-spec.ts
@@ -452,7 +452,7 @@ describe('utilityProcess module', () => {
       expect(output).to.include(result);
     });
 
-    ifit(process.platform !== 'linux')('can access exposed main process modules from the utility process', async () => {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('can access exposed main process modules from the utility process', async () => {
       const message = 'Message from utility process';
       const child = utilityProcess.fork(path.join(fixturesPath, 'expose-main-process-module.js'));
       await once(child, 'spawn');
@@ -489,7 +489,7 @@ describe('utilityProcess module', () => {
       await closeWindow(w);
     });
 
-    ifit(process.platform === 'linux')('allows executing a setuid binary with child_process', async () => {
+    ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('allows executing a setuid binary with child_process', async () => {
       const child = utilityProcess.fork(path.join(fixturesPath, 'suid.js'));
       await once(child, 'spawn');
       const [data] = await once(child, 'message');
diff --git a/electron/spec/api-web-contents-spec.ts b/electron/spec/api-web-contents-spec.ts
index 8450228437..bb494e7a62 100644
--- a/electron/spec/api-web-contents-spec.ts
+++ b/electron/spec/api-web-contents-spec.ts
@@ -2652,7 +2652,7 @@ describe('webContents module', () => {
     });
 
     // TODO(codebytere): OOPIF printing is disabled on Linux at the moment due to crashes.
-    ifit(process.platform !== 'linux')('can print cross-origin iframes', async () => {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('can print cross-origin iframes', async () => {
       server = http.createServer((_, res) => {
         res.writeHead(200);
         res.end(`
diff --git a/electron/spec/api-web-frame-main-spec.ts b/electron/spec/api-web-frame-main-spec.ts
index 236140780a..f98336b45f 100644
--- a/electron/spec/api-web-frame-main-spec.ts
+++ b/electron/spec/api-web-frame-main-spec.ts
@@ -315,7 +315,7 @@ describe('webFrameMain module', () => {
     });
 
     // TODO(jkleinsc) fix this flaky test on linux
-    ifit(process.platform !== 'linux')('throws upon accessing properties when disposed', async () => {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('throws upon accessing properties when disposed', async () => {
       await w.loadFile(path.join(subframesPath, 'frame-with-frame-container.html'));
       const { mainFrame } = w.webContents;
       w.destroy();
diff --git a/electron/spec/chromium-spec.ts b/electron/spec/chromium-spec.ts
index fa64d54cc3..492fd19668 100644
--- a/electron/spec/chromium-spec.ts
+++ b/electron/spec/chromium-spec.ts
@@ -474,13 +474,13 @@ describe('command line switches', () => {
     it('should not set an invalid locale', async () => testLocale('asdfkl', `${currentLocale}|${currentSystemLocale}|${currentPreferredLanguages}`));
 
     const lcAll = String(process.env.LC_ALL);
-    ifit(process.platform === 'linux')('current process has a valid LC_ALL env', async () => {
+    ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('current process has a valid LC_ALL env', async () => {
       // The LC_ALL env should not be set to DOM locale string.
       expect(lcAll).to.not.equal(app.getLocale());
     });
-    ifit(process.platform === 'linux')('should not change LC_ALL', async () => testLocale('fr', lcAll, true));
-    ifit(process.platform === 'linux')('should not change LC_ALL when setting invalid locale', async () => testLocale('asdfkl', lcAll, true));
-    ifit(process.platform === 'linux')('should not change LC_ALL when --lang is not set', async () => testLocale('', lcAll, true));
+    ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('should not change LC_ALL', async () => testLocale('fr', lcAll, true));
+    ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('should not change LC_ALL when setting invalid locale', async () => testLocale('asdfkl', lcAll, true));
+    ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('should not change LC_ALL when --lang is not set', async () => testLocale('', lcAll, true));
   });
 
   describe('--remote-debugging-pipe switch', () => {
@@ -2922,12 +2922,12 @@ describe('font fallback', () => {
       expect(fonts[0].familyName).to.equal('Arial');
     } else if (process.platform === 'darwin') {
       expect(fonts[0].familyName).to.equal('Helvetica');
-    } else if (process.platform === 'linux') {
+    } else if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
       expect(fonts[0].familyName).to.equal('DejaVu Sans');
     } // I think this depends on the distro? We don't specify a default.
   });
 
-  ifit(process.platform !== 'linux')('should fall back to Japanese font for sans-serif Japanese script', async function () {
+  ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('should fall back to Japanese font for sans-serif Japanese script', async function () {
     const html = `
     <html lang="ja-JP">
       <head>
@@ -3471,7 +3471,7 @@ describe('paste execCommand', () => {
   });
 });
 
-ifdescribe((process.platform !== 'linux' || app.isUnityRunning()))('navigator.setAppBadge/clearAppBadge', () => {
+ifdescribe(((process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') || app.isUnityRunning()))('navigator.setAppBadge/clearAppBadge', () => {
   let w: BrowserWindow;
 
   const expectedBadgeCount = 42;
diff --git a/electron/spec/crash-spec.ts b/electron/spec/crash-spec.ts
index 1bffcd8321..62dc3d0c06 100644
--- a/electron/spec/crash-spec.ts
+++ b/electron/spec/crash-spec.ts
@@ -52,7 +52,7 @@ const shouldRunCase = (crashCase: string) => {
       if (process.platform === 'win32') {
         return process.arch !== 'ia32';
       } else {
-        return (process.platform !== 'linux' || (process.arch !== 'arm64' && process.arch !== 'arm'));
+        return ((process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd') || (process.arch !== 'arm64' && process.arch !== 'arm'));
       }
     }
     default: {
diff --git a/electron/spec/fixtures/api/safe-storage/decrypt-app/main.js b/electron/spec/fixtures/api/safe-storage/decrypt-app/main.js
index fe983e4d54..831d29b040 100644
--- a/electron/spec/fixtures/api/safe-storage/decrypt-app/main.js
+++ b/electron/spec/fixtures/api/safe-storage/decrypt-app/main.js
@@ -7,7 +7,7 @@ const pathToEncryptedString = path.resolve(__dirname, '..', 'encrypted.txt');
 const readFile = fs.readFile;
 
 app.whenReady().then(async () => {
-  if (process.platform === 'linux') {
+  if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
     safeStorage.setUsePlainTextEncryption(true);
   }
   const encryptedString = await readFile(pathToEncryptedString);
diff --git a/electron/spec/fixtures/api/safe-storage/encrypt-app/main.js b/electron/spec/fixtures/api/safe-storage/encrypt-app/main.js
index 1bb90b65d3..b608eddb38 100644
--- a/electron/spec/fixtures/api/safe-storage/encrypt-app/main.js
+++ b/electron/spec/fixtures/api/safe-storage/encrypt-app/main.js
@@ -7,7 +7,7 @@ const pathToEncryptedString = path.resolve(__dirname, '..', 'encrypted.txt');
 const writeFile = fs.writeFile;
 
 app.whenReady().then(async () => {
-  if (process.platform === 'linux') {
+  if (process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') {
     safeStorage.setUsePlainTextEncryption(true);
   }
   const encrypted = safeStorage.encryptString('plaintext');
diff --git a/electron/spec/fixtures/crash-cases/safe-storage/index.js b/electron/spec/fixtures/crash-cases/safe-storage/index.js
index 08bdede4da..2085888940 100644
--- a/electron/spec/fixtures/crash-cases/safe-storage/index.js
+++ b/electron/spec/fixtures/crash-cases/safe-storage/index.js
@@ -22,7 +22,7 @@ const { expect } = require('chai');
   await app.whenReady();
   // isEncryptionAvailable() will always return false on CI due to a mocked
   // dbus as mentioned above.
-  expect(safeStorage.isEncryptionAvailable()).to.equal(process.platform !== 'linux');
+  expect(safeStorage.isEncryptionAvailable()).to.equal(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd');
   if (safeStorage.isEncryptionAvailable()) {
     const plaintext = 'plaintext';
     const ciphertext = safeStorage.encryptString(plaintext);
diff --git a/electron/spec/fixtures/native-addon/uv-dlopen/index.js b/electron/spec/fixtures/native-addon/uv-dlopen/index.js
index c2761afc41..2ec5b0a573 100644
--- a/electron/spec/fixtures/native-addon/uv-dlopen/index.js
+++ b/electron/spec/fixtures/native-addon/uv-dlopen/index.js
@@ -4,7 +4,7 @@ const testLoadLibrary = require('./build/Release/test_module');
 
 const lib = (() => {
   switch (process.platform) {
-    case 'linux':
+    case 'linux': case 'freebsd': case 'netbsd':
       return path.resolve(__dirname, 'build/Release/foo.so');
     case 'darwin':
       return path.resolve(__dirname, 'build/Release/foo.dylib');
diff --git a/electron/spec/node-spec.ts b/electron/spec/node-spec.ts
index 420698f88c..3f010f1dbc 100644
--- a/electron/spec/node-spec.ts
+++ b/electron/spec/node-spec.ts
@@ -148,7 +148,7 @@ describe('node feature', () => {
     });
 
     describe('child_process.exec', () => {
-      ifit(process.platform === 'linux')('allows executing a setuid binary from non-sandboxed renderer', async () => {
+      ifit(process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd')('allows executing a setuid binary from non-sandboxed renderer', async () => {
         // Chrome uses prctl(2) to set the NO_NEW_PRIVILEGES flag on Linux (see
         // https://github.com/torvalds/linux/blob/40fde647cc/Documentation/userspace-api/no_new_privs.rst).
         // We disable this for unsandboxed processes, which the renderer tests
diff --git a/electron/spec/version-bump-spec.ts b/electron/spec/version-bump-spec.ts
index e84d4a82ac..f44c19885d 100644
--- a/electron/spec/version-bump-spec.ts
+++ b/electron/spec/version-bump-spec.ts
@@ -53,7 +53,7 @@ class GitFake {
 }
 
 describe('version-bumper', () => {
-  ifdescribe(!(process.platform === 'linux' && process.arch.indexOf('arm') === 0) && process.platform !== 'darwin')('nextVersion', () => {
+  ifdescribe(!((process.platform === 'linux' || process.platform === 'freebsd' || process.platform === 'netbsd') && process.arch.indexOf('arm') === 0) && process.platform !== 'darwin')('nextVersion', () => {
     describe('bump versions', () => {
       const nightlyPattern = /[0-9.]*(-nightly.(\d{4})(\d{2})(\d{2}))$/g;
       const betaPattern = /[0-9.]*(-beta[0-9.]*)/g;
diff --git a/electron/spec/visibility-state-spec.ts b/electron/spec/visibility-state-spec.ts
index 23c47b484a..066403fc54 100644
--- a/electron/spec/visibility-state-spec.ts
+++ b/electron/spec/visibility-state-spec.ts
@@ -11,7 +11,7 @@ import { closeAllWindows } from './lib/window-helpers';
 
 // visibilityState specs pass on linux with a real window manager but on CI
 // the environment does not let these specs pass
-ifdescribe(process.platform !== 'linux')('document.visibilityState', () => {
+ifdescribe(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('document.visibilityState', () => {
   let w: BaseWindow & {webContents: WebContents};
 
   before(() => {
diff --git a/electron/spec/webview-spec.ts b/electron/spec/webview-spec.ts
index 23d07e3256..2df482e4e7 100644
--- a/electron/spec/webview-spec.ts
+++ b/electron/spec/webview-spec.ts
@@ -559,7 +559,7 @@ describe('<webview> tag', function () {
     });
 
     // FIXME(zcbenz): Fullscreen events do not work on Linux.
-    ifit(process.platform !== 'linux')('exiting fullscreen should unfullscreen window', async () => {
+    ifit(process.platform !== 'linux' && process.platform !== 'freebsd' && process.platform !== 'netbsd')('exiting fullscreen should unfullscreen window', async () => {
       const [w, webview] = await loadWebViewWindow();
       const enterFullScreen = once(w, 'enter-full-screen');
       await webview.executeJavaScript('document.getElementById("div").requestFullscreen()', true);
diff --git a/mojo/public/tools/bindings/mojom.gni b/mojo/public/tools/bindings/mojom.gni
index 1f23f0c5d0..12c43d70b2 100644
--- a/mojo/public/tools/bindings/mojom.gni
+++ b/mojo/public/tools/bindings/mojom.gni
@@ -801,6 +801,11 @@ template("mojom") {
       enabled_features += [ "is_bsd" ]
     }
 
+    if (is_netbsd) {
+      enabled_features += [ "is_netbsd" ]
+      enabled_features += [ "is_bsd" ]
+    }
+
     if (is_freebsd) {
       enabled_features += [ "is_freebsd" ]
       enabled_features += [ "is_bsd" ]
diff --git a/net/dns/dns_config_service_posix.cc b/net/dns/dns_config_service_posix.cc
index 5e3b6b46fd..54f031db80 100644
--- a/net/dns/dns_config_service_posix.cc
+++ b/net/dns/dns_config_service_posix.cc
@@ -148,6 +148,7 @@ class DnsConfigServicePosix::Watcher : public DnsConfigService::Watcher {
       return false;
 
     bool success = true;
+#if !IS_MAS_BUILD()
     if (!config_watcher_.Watch(base::BindRepeating(&Watcher::OnConfigChanged,
                                                    base::Unretained(this)))) {
       LOG(ERROR) << "DNS config watch failed to start.";
diff --git a/services/device/hid/BUILD.gn b/services/device/hid/BUILD.gn
index e824475bda..14914dfb7a 100644
--- a/services/device/hid/BUILD.gn
+++ b/services/device/hid/BUILD.gn
@@ -62,6 +62,13 @@ source_set("hid") {
     ]
   }
 
+  if (is_netbsd) {
+    sources += [
+      "hid_service_fuchsia.cc",
+      "hid_service_fuchsia.h",
+    ]
+  }
+
   if ((is_linux || is_chromeos) && !is_bsd && use_udev) {
     sources += [
       "hid_connection_linux.cc",
diff --git a/third_party/.gitignore b/third_party/.gitignore
index 62e5355ca0..ca74f51a9a 100644
--- a/third_party/.gitignore
+++ b/third_party/.gitignore
@@ -143,7 +143,7 @@
 /subresource-filter-ruleset/data/*
 /swift-format
 /swift-toolchain
-/swiftshaderXXXXXX/
+/swiftshaderXXX/
 /syzygy
 /syzygy/binaries
 /tint/src
@@ -153,7 +153,7 @@
 /vulkan-loader/src
 /vulkan-tools/src
 /vulkan-utility-libraries/src
-/vulkan-validation-layersXXXXXX/src
+/vulkan-validation-layersXXX/src
 /webdriver/python/selenium
 /webgl
 /webpagereplay
diff --git a/third_party/electron_node/BUILD.gn b/third_party/electron_node/BUILD.gn
index 4171613ba8..95e7f12420 100644
--- a/third_party/electron_node/BUILD.gn
+++ b/third_party/electron_node/BUILD.gn
@@ -40,8 +40,8 @@ declare_args() {
   node_release_urlbase = ""
 
   # Allows downstream packagers (eg. Linux distributions) to build Electron against system shared libraries.
-  use_system_cares = false
-  use_system_nghttp2 = false
+  use_system_cares = true
+  use_system_nghttp2 = true
   use_system_llhttp = false
   use_system_histogram = false
 }
diff --git a/third_party/electron_node/common.gypi b/third_party/electron_node/common.gypi
index 98aab200b4..cd3700f529 100644
--- a/third_party/electron_node/common.gypi
+++ b/third_party/electron_node/common.gypi
@@ -86,6 +86,8 @@
     'v8_use_perfetto': 0,
     'tsan%': 0,
 
+    'using_electron_config_gypi%': 0,
+
     ##### end V8 defaults #####
 
     # When building native modules using 'npm install' with the system npm,
diff --git a/third_party/electron_node/deps/cares/BUILD.gn b/third_party/electron_node/deps/cares/BUILD.gn
index ef745c19f2..538754c3ec 100644
--- a/third_party/electron_node/deps/cares/BUILD.gn
+++ b/third_party/electron_node/deps/cares/BUILD.gn
@@ -172,11 +172,21 @@ static_library("cares") {
     defines += [ "HAVE_CONFIG_H" ]
   }
 
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     include_dirs += [ "config/linux" ]
     sources += [ "config/linux/ares_config.h" ]
   }
 
+  if (is_freebsd) {
+    include_dirs += [ "config/freebsd" ]
+    sources += [ "config/freebsd/ares_config.h" ]
+  }
+
+  if (is_netbsd) {
+    include_dirs += [ "config/netbsd" ]
+    sources += [ "config/netbsd/ares_config.h" ]
+  }
+
   if (is_mac) {
     include_dirs += [ "config/darwin" ]
     sources += [
diff --git a/third_party/electron_node/deps/uv/BUILD.gn b/third_party/electron_node/deps/uv/BUILD.gn
index 7518168141..35f18e431e 100644
--- a/third_party/electron_node/deps/uv/BUILD.gn
+++ b/third_party/electron_node/deps/uv/BUILD.gn
@@ -3,7 +3,7 @@ config("libuv_config") {
 
   defines = []
 
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     defines += [ "_POSIX_C_SOURCE=200112" ]
   }
   if (!is_win) {
@@ -157,7 +157,7 @@ static_library("uv") {
     libs += [ "m" ]
     ldflags += [ "-pthread" ]
   }
-  if (is_mac || is_linux) {
+  if (is_mac || (is_linux && !is_bsd)) {
     sources += [ "src/unix/proctitle.c" ]
   }
   if (is_mac) {
@@ -172,7 +172,7 @@ static_library("uv") {
       "_DARWIN_UNLIMITED_SELECT=1",
     ]
   }
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     defines += [ "_GNU_SOURCE" ]
     sources += [
       "src/unix/linux.c",
@@ -191,4 +191,24 @@ static_library("uv") {
       "src/unix/kqueue.c",
     ]
   }
+  if (is_bsd) {
+    sources += [
+      "src/unix/bsd-ifaddrs.c",
+      "src/unix/bsd-proctitle.c",
+      "src/unix/kqueue.c",
+      "src/unix/posix-hrtime.c",
+      "src/unix/random-getrandom.c",
+    ]
+  }
+  if (is_freebsd) {
+    sources += [
+      "src/unix/freebsd.c",
+    ]
+  }
+  if (is_netbsd) {
+    sources += [
+      "src/unix/netbsd.c",
+    ]
+    libs += [ "kvm" ]
+  }
 }
diff --git a/third_party/electron_node/deps/uv/src/unix/pipe.c b/third_party/electron_node/deps/uv/src/unix/pipe.c
index d332f35183..a5777bdbb2 100644
--- a/third_party/electron_node/deps/uv/src/unix/pipe.c
+++ b/third_party/electron_node/deps/uv/src/unix/pipe.c
@@ -186,9 +186,13 @@ int uv_pipe_open(uv_pipe_t* handle, uv_file fd) {
   if (mode == -1)
     return UV__ERR(errno); /* according to docs, must be EBADF */
 
+  /* If ioctl(FIONBIO) reports ENOTTY, try fcntl(F_GETFL) + fcntl(F_SETFL).
+   * Workaround for e.g. kqueue fds not supporting ioctls.
+   */
   err = uv__nonblock(fd, 1);
-  if (err)
-    return err;
+  if (err == UV_ENOTTY)
+    if (uv__nonblock == uv__nonblock_ioctl)
+      err = uv__nonblock_fcntl(fd, 1);
 
 #if defined(__APPLE__)
   err = uv__stream_try_select((uv_stream_t*) handle, &fd);
diff --git a/third_party/electron_node/deps/uvwasi/src/uvwasi.c b/third_party/electron_node/deps/uvwasi/src/uvwasi.c
index 948c1355c9..55e3b7b9fe 100644
--- a/third_party/electron_node/deps/uvwasi/src/uvwasi.c
+++ b/third_party/electron_node/deps/uvwasi/src/uvwasi.c
@@ -1,4 +1,8 @@
 #include <stdlib.h>
+#if defined(__NetBSD__)
+// strnlen, telldir, seekdir
+#define _NETBSD_SOURCE
+#endif
 #include <string.h>
 
 #ifndef _WIN32
@@ -803,7 +807,7 @@ uvwasi_errno_t uvwasi_fd_close(uvwasi_t* uvwasi, uvwasi_fd_t fd) {
     uv_mutex_unlock(&wrap->mutex);
     if (err != UVWASI_ESUCCESS) {
       goto exit;
-    }   
+    }
   }
 
   if (r != 0) {
@@ -2793,7 +2797,7 @@ uvwasi_errno_t uvwasi_sock_shutdown(uvwasi_t* uvwasi,
 
   uv_mutex_unlock(&wrap->mutex);
 
-  if (shutdown_data.status != 0) 
+  if (shutdown_data.status != 0)
     return uvwasi__translate_uv_error(shutdown_data.status);
 
   return UVWASI_ESUCCESS;
diff --git a/third_party/electron_node/lib/internal/modules/cjs/loader.js b/third_party/electron_node/lib/internal/modules/cjs/loader.js
index 82a3b80f6f..6e2802ab49 100644
--- a/third_party/electron_node/lib/internal/modules/cjs/loader.js
+++ b/third_party/electron_node/lib/internal/modules/cjs/loader.js
@@ -1530,6 +1530,13 @@ Module.prototype._compile = function(content, filename, format) {
   this[kIsExecuting] = true;
   if (this[kIsMainSymbol] && getOptionValue('--inspect-brk')) {
     const { callAndPauseOnStart } = internalBinding('inspector');
+    // process._firstFileName is used by Embedders to tell node what
+    // the first "real" file is when they use themselves as the entry
+    // point
+    if (process._firstFileName) {
+      resolvedArgv = process._firstFileName;
+      delete process._firstFileName;
+    }
     result = callAndPauseOnStart(compiledWrapper, thisValue, exports,
                                  require, module, filename, dirname,
                                  process, localGlobal, localBuffer);
diff --git a/third_party/electron_node/src/node_contextify.cc b/third_party/electron_node/src/node_contextify.cc
index de50880b0c..9f38cdf60f 100644
--- a/third_party/electron_node/src/node_contextify.cc
+++ b/third_party/electron_node/src/node_contextify.cc
@@ -486,14 +486,15 @@ bool ContextifyContext::IsStillInitializing(const ContextifyContext* ctx) {
 }
 
 // static
-void ContextifyContext::PropertyGetterCallback(
-    Local<Name> property,
-    const PropertyCallbackInfo<Value>& args) {
+Intercepted ContextifyContext::PropertyGetterCallback(
+    Local<Name> property, const PropertyCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   ContextifyContext* ctx = ContextifyContext::Get(args);
 
   // Still initializing
-  if (IsStillInitializing(ctx)) return;
+  if (IsStillInitializing(ctx)) {
+    return Intercepted::kNo;
+  }
 
   Local<Context> context = ctx->context();
   Local<Object> sandbox = ctx->sandbox();
diff --git a/third_party/electron_node/src/node_external_reference.h b/third_party/electron_node/src/node_external_reference.h
index c4aba23510..6d9988810b 100644
--- a/third_party/electron_node/src/node_external_reference.h
+++ b/third_party/electron_node/src/node_external_reference.h
@@ -66,16 +66,17 @@ class ExternalReferenceRegistry {
   V(v8::FunctionCallback)                                                      \
   V(v8::AccessorNameGetterCallback)                                            \
   V(v8::AccessorNameSetterCallback)                                            \
-  V(v8::GenericNamedPropertyDefinerCallback)                                   \
-  V(v8::GenericNamedPropertyDeleterCallback)                                   \
-  V(v8::GenericNamedPropertyEnumeratorCallback)                                \
-  V(v8::GenericNamedPropertyQueryCallback)                                     \
-  V(v8::GenericNamedPropertySetterCallback)                                    \
-  V(v8::IndexedPropertySetterCallback)                                         \
-  V(v8::IndexedPropertyDefinerCallback)                                        \
-  V(v8::IndexedPropertyDeleterCallback)                                        \
-  V(v8::IndexedPropertyQueryCallback)                                          \
-  V(v8::IndexedPropertyDescriptorCallback)                                     \
+  V(v8::NamedPropertyGetterCallback)                                           \
+  V(v8::NamedPropertyDefinerCallback)                                          \
+  V(v8::NamedPropertyDeleterCallback)                                          \
+  V(v8::NamedPropertyEnumeratorCallback)                                       \
+  V(v8::NamedPropertyQueryCallback)                                            \
+  V(v8::NamedPropertySetterCallback)                                           \
+  V(v8::IndexedPropertyGetterCallbackV2)                                       \
+  V(v8::IndexedPropertySetterCallbackV2)                                       \
+  V(v8::IndexedPropertyDefinerCallbackV2)                                      \
+  V(v8::IndexedPropertyDeleterCallbackV2)                                      \
+  V(v8::IndexedPropertyQueryCallbackV2)                                        \
   V(const v8::String::ExternalStringResourceBase*)
 
 #define V(ExternalReferenceType)                                               \
diff --git a/third_party/electron_node/tools/generate_gn_filenames_json.py b/third_party/electron_node/tools/generate_gn_filenames_json.py
index 37c1685900..53d5db1b98 100755
--- a/third_party/electron_node/tools/generate_gn_filenames_json.py
+++ b/third_party/electron_node/tools/generate_gn_filenames_json.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python3
+#!@PYTHONBIN@
 import json
 import os
 import sys
diff --git a/third_party/engflow-reclient-configs/python/python_remote_wrapper.template b/third_party/engflow-reclient-configs/python/python_remote_wrapper.template
index 54817e4f6f..98b9f59e40 100644
--- a/third_party/engflow-reclient-configs/python/python_remote_wrapper.template
+++ b/third_party/engflow-reclient-configs/python/python_remote_wrapper.template
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!@SH@
 # Copyright (c) 2023 Contributors to the reclient-configs project. All rights reserved.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
diff --git a/third_party/lzma_sdk/C/CpuArch.c b/third_party/lzma_sdk/C/CpuArch.c
index 9b670f4998..6eb5e7f81a 100644
--- a/third_party/lzma_sdk/C/CpuArch.c
+++ b/third_party/lzma_sdk/C/CpuArch.c
@@ -885,35 +885,70 @@ MY_HWCAP_CHECK_FUNC (AES)
 
 #else // __APPLE__
 
-#include <sys/auxv.h>
+#if defined(__GLIBC__) && (__GLIBC__ * 100 + __GLIBC_MINOR__ >= 216)
+  #define Z7_GETAUXV_AVAILABLE
+#else
+// #pragma message("=== is not NEW GLIBC === ")
+  #if defined __has_include
+  #if __has_include (<sys/auxv.h>)
+// #pragma message("=== sys/auxv.h is avail=== ")
+    #define Z7_GETAUXV_AVAILABLE
+  #endif
+  #endif
+#endif
 
-#if !defined(ARMV8_OS_FUCHSIA) && !defined(__FreeBSD__) && !defined(__NetBSD__)
+#ifdef Z7_GETAUXV_AVAILABLE
+// #pragma message("=== Z7_GETAUXV_AVAILABLE === ")
+#include <sys/auxv.h>
 #define USE_HWCAP
-#endif // !defined(ARMV8_OS_FUCHSIA)
+#endif
 
 #ifdef USE_HWCAP
 
+#if defined(__FreeBSD__)
+static unsigned long MY_getauxval(int aux)
+{
+  unsigned long val;
+  if (elf_aux_info(aux, &val, sizeof(val)))
+    return 0;
+  return val;
+}
+#else
+#define MY_getauxval  getauxval
+  #if defined __has_include
+  #if __has_include (<asm/hwcap.h>)
 #include <asm/hwcap.h>
+  #endif
+  #endif
+#endif
 
   #define MY_HWCAP_CHECK_FUNC_2(name1, name2) \
-  BoolInt CPU_IsSupported_ ## name1() { return (getauxval(AT_HWCAP)  & (HWCAP_  ## name2)) ? 1 : 0; }
+  BoolInt CPU_IsSupported_ ## name1(void) { return (MY_getauxval(AT_HWCAP)  & (HWCAP_  ## name2)); }
 
 #ifdef MY_CPU_ARM64
   #define MY_HWCAP_CHECK_FUNC(name) \
   MY_HWCAP_CHECK_FUNC_2(name, name)
+#if 1 || defined(__ARM_NEON)
+  BoolInt CPU_IsSupported_NEON(void) { return True; }
+#else
   MY_HWCAP_CHECK_FUNC_2(NEON, ASIMD)
+#endif
 // MY_HWCAP_CHECK_FUNC (ASIMD)
 #elif defined(MY_CPU_ARM)
   #define MY_HWCAP_CHECK_FUNC(name) \
-  BoolInt CPU_IsSupported_ ## name() { return (getauxval(AT_HWCAP2) & (HWCAP2_ ## name)) ? 1 : 0; }
+  BoolInt CPU_IsSupported_ ## name(void) { return (MY_getauxval(AT_HWCAP2) & (HWCAP2_ ## name)); }
   MY_HWCAP_CHECK_FUNC_2(NEON, NEON)
 #endif
 
 #else // USE_HWCAP
 
   #define MY_HWCAP_CHECK_FUNC(name) \
-  BoolInt CPU_IsSupported_ ## name() { return 0; }
+  BoolInt CPU_IsSupported_ ## name(void) { return 0; }
+#if defined(__ARM_NEON)
+  BoolInt CPU_IsSupported_NEON(void) { return True; }
+#else
   MY_HWCAP_CHECK_FUNC(NEON)
+#endif
 
 #endif // USE_HWCAP
 
diff --git a/third_party/perfetto/src/base/utils.cc b/third_party/perfetto/src/base/utils.cc
index d4a45fdb21..b743efeaaf 100644
--- a/third_party/perfetto/src/base/utils.cc
+++ b/third_party/perfetto/src/base/utils.cc
@@ -290,7 +290,7 @@ std::string GetCurExecutablePath() {
   self_path = std::string(buf, static_cast<size_t>(size));
 #elif PERFETTO_BUILDFLAG(PERFETTO_OS_BSD)
   char *buf;
-  const char *cpath = "@PREFIX@/lib/chromium/chrome";
+  const char *cpath = "@PREFIX@/lib/@PKGBASE@/electron";
   if ((buf = getenv("CHROME_EXE_PATH")) != NULL)
     self_path = std::string(buf);
   else
diff --git a/third_party/squirrel.mac/build/xcrun.py b/third_party/squirrel.mac/build/xcrun.py
index a7aeeb7d3e..82598e69c7 100644
--- a/third_party/squirrel.mac/build/xcrun.py
+++ b/third_party/squirrel.mac/build/xcrun.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python3
+#!@PYTHONBIN@
 from __future__ import print_function
 import os
 import subprocess
diff --git a/third_party/unrar/src/crc.cpp b/third_party/unrar/src/crc.cpp
index 6ec67f2b8a..93a3158349 100644
--- a/third_party/unrar/src/crc.cpp
+++ b/third_party/unrar/src/crc.cpp
@@ -43,12 +43,18 @@ void InitCRC32(uint *CRCTab)
   }
 
 #ifdef USE_NEON_CRC32
-  #ifdef _APPLE
+  #if defined(_APPLE)
     // getauxval isn't available in OS X
     uint Value=0;
     size_t Size=sizeof(Value);
     int RetCode=sysctlbyname("hw.optional.armv8_crc32",&Value,&Size,NULL,0);
     CRC_Neon=RetCode==0 && Value!=0;
+  #elif defined(__FreeBSD__)
+    // getauxval isn't available on FreeBSD
+    uint64 Reg=READ_SPECIALREG(id_aa64isar0_el1);
+    if (ID_AA64ISAR0_CRC32_VAL(Reg) == ID_AA64ISAR0_CRC32_BASE) {
+      CRC_Neon=true;
+    }
   #else
     CRC_Neon=(getauxval(AT_HWCAP) & HWCAP_CRC32)!=0;
   #endif
diff --git a/third_party/unrar/src/os.hpp b/third_party/unrar/src/os.hpp
index 278e3c923f..2f4240c0f9 100644
--- a/third_party/unrar/src/os.hpp
+++ b/third_party/unrar/src/os.hpp
@@ -162,10 +162,13 @@
 
 #if defined(__aarch64__) && (defined(__ARM_FEATURE_CRYPTO) || defined(__ARM_FEATURE_CRC32))
 #include <arm_neon.h>
-#ifndef _APPLE
+#if !defined(_APPLE) && !defined(__FreeBSD__)
 #include <sys/auxv.h>
 #include <asm/hwcap.h>
 #endif
+#ifdef __FreeBSD__
+#include <machine/armreg.h>
+#endif
 #ifdef __ARM_FEATURE_CRYPTO
 #define USE_NEON_AES
 #endif
diff --git a/third_party/unrar/src/rijndael.cpp b/third_party/unrar/src/rijndael.cpp
index 8707b5784a..ac37cfc905 100644
--- a/third_party/unrar/src/rijndael.cpp
+++ b/third_party/unrar/src/rijndael.cpp
@@ -116,7 +116,7 @@ void Rijndael::Init(bool Encrypt,const byte *key,uint keyLen,const byte * initVe
 #endif
 
 #elif defined(USE_NEON_AES)
-  #ifdef _APPLE
+  #if defined(_APPLE)
     // getauxval isn't available in OS X
     uint Value=0;
     size_t Size=sizeof(Value);
@@ -126,6 +126,12 @@ void Rijndael::Init(bool Encrypt,const byte *key,uint keyLen,const byte * initVe
     // because "hw.optional.arm.FEAT_AES" was missing in OS X 11, but AES
     // still was supported by Neon.
     AES_Neon=RetCode!=0 || Value!=0;
+  #elif defined(__FreeBSD__)
+    // getauxval isn't available on FreeBSD
+    uint64 Reg=READ_SPECIALREG(id_aa64isar0_el1);
+    if (ID_AA64ISAR0_AES_VAL(Reg) == ID_AA64ISAR0_AES_BASE) {
+      AES_Neon=true;
+    }
   #else
     AES_Neon=(getauxval(AT_HWCAP) & HWCAP_AES)!=0;
   #endif
diff --git a/third_party/vulkan-deps/.gitignore b/third_party/vulkan-deps/.gitignore
index 0b216a3b3b..5af96250de 100644
--- a/third_party/vulkan-deps/.gitignore
+++ b/third_party/vulkan-deps/.gitignore
@@ -8,4 +8,4 @@ DEPS.old
 /vulkan-loader/src
 /vulkan-tools/src
 /vulkan-utility-libraries/src
-/vulkan-validation-layersXXXXXX/src
+/vulkan-validation-layersXXX/src
diff --git a/third_party/webrtc/modules/video_capture/linux/pipewire_session.cc b/third_party/webrtc/modules/video_capture/linux/pipewire_session.cc
index 98eb656096..cfe5350331 100644
--- a/third_party/webrtc/modules/video_capture/linux/pipewire_session.cc
+++ b/third_party/webrtc/modules/video_capture/linux/pipewire_session.cc
@@ -87,7 +87,7 @@ PipeWireNode::PipeWireNode(PipeWireSession* session,
       .param = OnNodeParam,
   };
 
-  pw_node_add_listener(proxy_, &node_listener_, &node_events, this);
+  pw_node_add_listener(reinterpret_cast<pw_node*>(proxy_), &node_listener_, &node_events, this);
 }
 
 // static
@@ -119,7 +119,7 @@ void PipeWireNode::OnNodeInfo(void* data, const pw_node_info* info) {
       uint32_t id = info->params[i].id;
       if (id == SPA_PARAM_EnumFormat &&
           info->params[i].flags & SPA_PARAM_INFO_READ) {
-        pw_node_enum_params(that->proxy_, 0, id, 0, UINT32_MAX, nullptr);
+        pw_node_enum_params(reinterpret_cast<pw_node*>(that->proxy_), 0, id, 0, UINT32_MAX, nullptr);
         break;
       }
     }
diff --git a/ui/base/accelerators/accelerator_unittest.cc b/ui/base/accelerators/accelerator_unittest.cc
index bc08a75b82..6089409bec 100644
--- a/ui/base/accelerators/accelerator_unittest.cc
+++ b/ui/base/accelerators/accelerator_unittest.cc
@@ -58,7 +58,7 @@ TEST(AcceleratorTest, MAYBE_GetShortcutText) {
 #if BUILDFLAG(IS_MAC)
       {VKEY_T, EF_COMMAND_DOWN | EF_CONTROL_DOWN, nullptr, u"T"},
 #endif
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
       {VKEY_T, EF_COMMAND_DOWN | EF_CONTROL_DOWN, u"Super+Ctrl+T", nullptr},
 #endif
   };
diff --git a/ui/gtk/gtk_compat.cc b/ui/gtk/gtk_compat.cc
index e358e722d3..fabd2e01bc 100644
--- a/ui/gtk/gtk_compat.cc
+++ b/ui/gtk/gtk_compat.cc
@@ -70,15 +70,6 @@ void* GetLibGio() {
   return libgio;
 }
 
-void* GetLibGdkPixbuf() {
-#if BUILDFLAG(IS_BSD)
-  static void* libgdk_pixbuf = DlOpen("libgdk_pixbuf-2.0.so");
-#else
-  static void* libgdk_pixbuf = DlOpen("libgdk_pixbuf-2.0.so.0");
-#endif
-  return libgdk_pixbuf;
-}
-
 void* GetLibGdk3() {
 #if BUILDFLAG(IS_BSD)
   static void* libgdk3 = DlOpen("libgdk-3.so");
@@ -155,7 +146,11 @@ gfx::Insets InsetsFromGtkBorder(const GtkBorder& border) {
 }  // namespace
 
 void* GetLibGdkPixbuf() {
+#if BUILDFLAG(IS_BSD)
+  static void* libgdk_pixbuf = DlOpen("libgdk_pixbuf-2.0.so");
+#else
   static void* libgdk_pixbuf = DlOpen("libgdk_pixbuf-2.0.so.0");
+#endif
   return libgdk_pixbuf;
 }
 
diff --git a/ui/qt/BUILD.gn b/ui/qt/BUILD.gn
index e71e7d7821..7118297773 100644
--- a/ui/qt/BUILD.gn
+++ b/ui/qt/BUILD.gn
@@ -124,7 +124,10 @@ component("qt") {
   defines = [ "IS_QT_IMPL" ]
 
   # qt_shim is in data_deps since we want to load it manually.
-  data_deps = [ ":qt5_shim" ]
+  data_deps = []
+  if (use_qt5) {
+    data_deps += [ ":qt5_shim" ]
+  }
   if (use_qt6) {
     data_deps += [ ":qt6_shim" ]
   }
diff --git a/ui/qt/qt.gni b/ui/qt/qt.gni
index fa5e245cd3..7d72dba10a 100644
--- a/ui/qt/qt.gni
+++ b/ui/qt/qt.gni
@@ -9,24 +9,17 @@ import("//build/config/sysroot.gni")
 declare_args() {
   # TODO(crbug.com/40260415): Allow QT in MSAN builds once QT is
   # added to the instrumented libraries.
-  use_qt = is_linux && !is_castos && !is_msan
+  use_qt5 = use_sysroot && is_linux && !is_castos && !is_msan
+  use_qt6 = use_sysroot && is_linux && !is_castos && !is_msan
 }
 
 declare_args() {
-  if (!use_sysroot && use_qt) {
+  if (!use_sysroot && use_qt5) {
     moc_qt5_path = "@QTDIR@/bin"
   }
-}
-
-declare_args() {
-  use_qt6 = use_qt && use_sysroot
-}
-
-declare_args() {
   if (!use_sysroot && use_qt6) {
     moc_qt6_path = ""
   }
 }
 
-# use_qt6 => use_qt
-assert(!use_qt6 || use_qt)
+use_qt = use_qt5 || use_qt6
diff --git a/ui/qt/qt_ui.cc b/ui/qt/qt_ui.cc
index 9266382d1c..2b3cb3d5c4 100644
--- a/ui/qt/qt_ui.cc
+++ b/ui/qt/qt_ui.cc
@@ -436,7 +436,8 @@ std::unique_ptr<ui::NavButtonProvider> QtUi::CreateNavButtonProvider() {
 }
 
 ui::WindowFrameProvider* QtUi::GetWindowFrameProvider(bool solid_frame,
-                                                      bool tiled) {
+                                                      bool tiled,
+                                                      bool maximized) {
   // QT prefers server-side decorations.
   return nullptr;
 }
diff --git a/ui/qt/qt_ui.h b/ui/qt/qt_ui.h
index 2e5a321413..2d6c367533 100644
--- a/ui/qt/qt_ui.h
+++ b/ui/qt/qt_ui.h
@@ -82,7 +82,8 @@ class QtUi : public ui::LinuxUiAndTheme, QtInterface::Delegate {
   void SetAccentColor(std::optional<SkColor>) override;
   std::unique_ptr<ui::NavButtonProvider> CreateNavButtonProvider() override;
   ui::WindowFrameProvider* GetWindowFrameProvider(bool solid_frame,
-                                                  bool tiled) override;
+                                                  bool tiled,
+                                                  bool maximized) override;
 
   // QtInterface::Delegate:
   void FontChanged() override;
diff --git a/ui/shell_dialogs/select_file_dialog.h b/ui/shell_dialogs/select_file_dialog.h
index b4b2f7294c..9643db3a6d 100644
--- a/ui/shell_dialogs/select_file_dialog.h
+++ b/ui/shell_dialogs/select_file_dialog.h
@@ -224,7 +224,7 @@ class SHELL_DIALOGS_EXPORT SelectFileDialog
                   const GURL* caller = nullptr);
   bool HasMultipleFileTypeChoices();
 
-#if BUILDFLAG(IS_LINUX)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
   // Set the label used for the file select button.
   virtual void SetButtonLabel(const std::string& label) = 0;
 
diff --git a/ui/strings/ui_strings.grd b/ui/strings/ui_strings.grd
index 7d08606d0b..66f7b73a78 100644
--- a/ui/strings/ui_strings.grd
+++ b/ui/strings/ui_strings.grd
@@ -767,7 +767,7 @@ need to be translated for each locale.-->
           Win
         </message>
       </if>
-      <if expr="is_linux">
+      <if expr="is_posix">
         <message name="IDS_APP_SUPER_KEY" desc="Windows key on Windows keyboards, and Command key on Mac keyboards.">
           Super
         </message>
diff --git a/v8/include/v8config.h b/v8/include/v8config.h
index 8d68f4359a..a43f38c7b9 100644
--- a/v8/include/v8config.h
+++ b/v8/include/v8config.h
@@ -258,6 +258,11 @@ path. Add it with -I<path> to the command line
 # define V8_TARGET_OS_BSD
 #endif
 
+#ifdef V8_OS_NETBSD
+# define V8_TARGET_OS_NETBSD
+# define V8_TARGET_OS_BSD
+#endif
+
 #ifdef V8_OS_MACOS
 # define V8_TARGET_OS_MACOS
 #endif
diff --git a/v8/src/builtins/x64/builtins-x64.cc b/v8/src/builtins/x64/builtins-x64.cc
index c894ce0c42..f555690c66 100644
--- a/v8/src/builtins/x64/builtins-x64.cc
+++ b/v8/src/builtins/x64/builtins-x64.cc
@@ -1830,7 +1830,7 @@ static void Generate_InterpreterEnterBytecode(MacroAssembler* masm) {
                   times_system_pointer_size, 0));
 
   // Jump to the interpreter entry, and call kJavaScriptCallCodeStartRegister.
-  __ jmp(rbx);
+  __ jmp(rbx, /*notrack=*/true);
 }
 
 void Builtins::Generate_InterpreterEnterAtNextBytecode(MacroAssembler* masm) {
