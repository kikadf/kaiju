diff --git a/base/BUILD.gn b/base/BUILD.gn
index 16c9c6e563..ccdcd33b79 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -971,7 +971,7 @@ component("base") {
     #"system/sys_info_openbsd.cc",
   ]
 
-  if (is_apple || current_os == "freebsd" || current_os == "openbsd") {
+  if (is_apple || current_os == "freebsd" || current_os == "openbsd" || current_os == "netbsd") {
     sources += [
       "posix/sysctl.cc",
       "posix/sysctl.h",
@@ -2180,6 +2180,13 @@ component("base") {
       "process/process_metrics_freebsd.cc",
       "system/sys_info_freebsd.cc",
     ]
+  }  else if (is_netbsd) {
+    sources += [
+      "process/process_handle_netbsd.cc",
+      "process/process_iterator_netbsd.cc",
+      "process/process_metrics_netbsd.cc",
+      "system/sys_info_netbsd.cc",
+    ]
   }
 
   # iOS
diff --git a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
index 03769fe759..798f2c5f24 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
+++ b/base/allocator/partition_allocator/src/partition_alloc/partition_alloc_config.h
@@ -56,8 +56,8 @@ static_assert(sizeof(void*) != 8, "");
 // POSIX is not only UNIX, e.g. macOS and other OSes. We do use Linux-specific
 // features such as futex(2).
 #define PA_CONFIG_HAS_LINUX_KERNEL()                      \
-  (PA_BUILDFLAG(IS_LINUX) || PA_BUILDFLAG(IS_CHROMEOS) || \
-   PA_BUILDFLAG(IS_ANDROID))
+  ((PA_BUILDFLAG(IS_LINUX) || PA_BUILDFLAG(IS_CHROMEOS) || \
+   PA_BUILDFLAG(IS_ANDROID)) && !PA_BUILDFLAG(IS_NETBSD))
 
 // Need TLS support.
 #define PA_CONFIG_THREAD_CACHE_SUPPORTED() \
diff --git a/base/allocator/partition_allocator/src/partition_alloc/spinning_mutex.cc b/base/allocator/partition_allocator/src/partition_alloc/spinning_mutex.cc
index 535bf0b548..d75ce5042c 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/spinning_mutex.cc
+++ b/base/allocator/partition_allocator/src/partition_alloc/spinning_mutex.cc
@@ -25,7 +25,7 @@
 #endif
 
 #if PA_CONFIG(HAS_LINUX_KERNEL)
-#if defined(OS_OPENBSD)
+#if defined(OS_OPENBSD) || defined(OS_NETBSD)
 #include <sys/time.h>
 #include <sys/futex.h>
 #elif defined(OS_FREEBSD)
@@ -170,6 +170,9 @@ PA_ALWAYS_INLINE long FutexSyscall(volatile void* ftx, int op, int value) {
 #elif defined(OS_OPENBSD)
   long retval = futex(reinterpret_cast<volatile unsigned int *>(&state_), FUTEX_WAIT | FUTEX_PRIVATE_FLAG,
                     kLockedContended, nullptr, nullptr);
+#elif defined(OS_NETBSD)
+  long retval = syscall(SYS___futex, reinterpret_cast<volatile int *>(&state_), op | FUTEX_PRIVATE_FLAG,
+                     value, nullptr, nullptr, 0, 0);
 #else
   long retval = syscall(SYS_futex, ftx, op | FUTEX_PRIVATE_FLAG, value, nullptr,
                         nullptr, 0);
diff --git a/base/allocator/partition_allocator/src/partition_alloc/stack/stack.cc b/base/allocator/partition_allocator/src/partition_alloc/stack/stack.cc
index af1d495382..f03f27ca77 100644
--- a/base/allocator/partition_allocator/src/partition_alloc/stack/stack.cc
+++ b/base/allocator/partition_allocator/src/partition_alloc/stack/stack.cc
@@ -23,7 +23,7 @@
 #include <pthread.h>
 #endif
 
-#if PA_BUILDFLAG(IS_BSD)
+#if PA_BUILDFLAG(IS_BSD) && !PA_BUILDFLAG(IS_NETBSD)
 #include <pthread_np.h>
 #endif
 
@@ -68,7 +68,7 @@ void* GetStackTop() {
   return reinterpret_cast<uint8_t*>(ss.ss_sp);
 }
 
-#elif PA_BUILDFLAG(IS_FREEBSD)
+#elif PA_BUILDFLAG(IS_FREEBSD) || PA_BUILDFLAG(IS_NETBSD)
 
 void* GetStackTop() {
    pthread_attr_t attr;
diff --git a/base/base_paths_posix.cc b/base/base_paths_posix.cc
index bff1751810..5d45da8f3f 100644
--- a/base/base_paths_posix.cc
+++ b/base/base_paths_posix.cc
@@ -58,6 +58,15 @@ bool PathProviderPosix(int key, FilePath* result) {
       }
       *result = FilePath(bin_dir.value());
       return true;
+#elif BUILDFLAG(IS_NETBSD)
+      std::optional<std::string> bin_dir = StringSysctl({ CTL_KERN, KERN_PROC_ARGS, getpid(), KERN_PROC_PATHNAME });
+      if (!bin_dir.has_value() || bin_dir.value().length() <= 1) {
+        NOTREACHED() << "Unable to resolve path.";
+        return false;
+      }
+      *result = FilePath(bin_dir.value());
+      VLOG(1) << "PathProviderPosix result: " << bin_dir.value();
+      return true;
 #elif BUILDFLAG(IS_SOLARIS)
       char bin_dir[PATH_MAX + 1];
       if (realpath(getexecname(), bin_dir) == NULL) {
@@ -119,7 +128,7 @@ out:
         if ((cpath = getenv("CHROME_EXE_PATH")) != NULL)
           *result = FilePath(cpath);
         else
-          *result = FilePath("/usr/local/chrome/chrome");
+          *result = FilePath("@PREFIX@/lib/chromium/chrome");
         return true;
 #if !BUILDFLAG(IS_AIX)
       }
diff --git a/base/compiler_specific.h b/base/compiler_specific.h
index c2cc60e7e1..f80b427a2d 100644
--- a/base/compiler_specific.h
+++ b/base/compiler_specific.h
@@ -734,6 +734,7 @@ inline constexpr bool AnalyzerAssumeTrue(bool arg) {
     (defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_X86_64)) && \
     !defined(COMPONENT_BUILD) &&                             \
     !BUILDFLAG(IS_OPENBSD) &&                                \
+    !BUILDFLAG(IS_NETBSD) &&                                 \
     !(BUILDFLAG(IS_WIN) && defined(ARCH_CPU_ARM64))
 #define PRESERVE_MOST [[clang::preserve_most]]
 #else
diff --git a/base/debug/debugger_posix.cc b/base/debug/debugger_posix.cc
index c331181cae..003d806ad0 100644
--- a/base/debug/debugger_posix.cc
+++ b/base/debug/debugger_posix.cc
@@ -87,6 +87,7 @@ bool BeingDebugged() {
 
   // Initialize mib, which tells sysctl what info we want.  In this case,
   // we're looking for information about a specific process ID.
+#if !BUILDFLAG(IS_NETBSD)
   int mib[] = {CTL_KERN,
                KERN_PROC,
                KERN_PROC_PID,
@@ -97,12 +98,24 @@ bool BeingDebugged() {
                0
 #endif
   };
+#else
+  int mib[] = {CTL_KERN,
+               KERN_PROC2,
+               KERN_PROC_PID,
+               getpid(),
+               sizeof(struct kinfo_proc2),
+               1
+  };
+#endif
 
   // Caution: struct kinfo_proc is marked __APPLE_API_UNSTABLE.  The source and
   // binary interfaces may change.
 #if BUILDFLAG(IS_OPENBSD)
   struct kinfo_proc *info;
   size_t info_size;
+#elif BUILDFLAG(IS_NETBSD)
+  struct kinfo_proc2 info;
+  size_t info_size = sizeof(info);
 #else
   struct kinfo_proc info;
   size_t info_size = sizeof(info);
@@ -121,6 +134,11 @@ bool BeingDebugged() {
   }
 
   int sysctl_result = sysctl(mib, std::size(mib), info, &info_size, NULL, 0);
+#elif BUILDFLAG(IS_NETBSD)
+  if (sysctl(mib, std::size(mib), NULL, &info_size, NULL, 0) < 0)
+    return -1;
+
+  mib[5] = (info_size / sizeof(struct kinfo_proc2));
 #endif
 
 #if !BUILDFLAG(IS_OPENBSD)
@@ -139,6 +157,8 @@ bool BeingDebugged() {
   being_debugged = (info.ki_flag & P_TRACED) != 0;
 #elif BUILDFLAG(IS_OPENBSD)
   being_debugged = (info->p_psflags & PS_TRACED) != 0;
+#elif BUILDFLAG(IS_NETBSD)
+  being_debugged = (info.p_flag & P_TRACED) != 0;
 #else
   being_debugged = (info.kp_proc.p_flag & P_TRACED) != 0;
 #endif
diff --git a/base/debug/stack_trace_posix.cc b/base/debug/stack_trace_posix.cc
index ad6b9b91ab..142b7e97e6 100644
--- a/base/debug/stack_trace_posix.cc
+++ b/base/debug/stack_trace_posix.cc
@@ -50,7 +50,7 @@
 // Surprisingly, uClibc defines __GLIBC__ in some build configs, but
 // execinfo.h and backtrace(3) are really only present in glibc and in macOS
 // libc.
-#if BUILDFLAG(IS_APPLE) || \
+#if BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_NETBSD) || \
     (defined(__GLIBC__) && !defined(__UCLIBC__) && !defined(__AIX) && !BUILDFLAG(IS_BSD))
 #define HAVE_BACKTRACE
 #include <execinfo.h>
diff --git a/base/logging_unittest.cc b/base/logging_unittest.cc
index 1fdd4bd9ac..b5ad52b85b 100644
--- a/base/logging_unittest.cc
+++ b/base/logging_unittest.cc
@@ -586,7 +586,7 @@ void CheckCrashTestSighandler(int, siginfo_t* info, void* context_ptr) {
   // need the arch-specific boilerplate below, which is inspired by breakpad.
   // At the same time, on OSX, ucontext.h is deprecated but si_addr works fine.
   uintptr_t crash_addr = 0;
-#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_FREEBSD)
+#if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
   crash_addr = reinterpret_cast<uintptr_t>(info->si_addr);
 #else  // OS_*
   ucontext_t* context = reinterpret_cast<ucontext_t*>(context_ptr);
diff --git a/base/message_loop/message_pump_glib.cc b/base/message_loop/message_pump_glib.cc
index a88163bcb0..45bcef1ac1 100644
--- a/base/message_loop/message_pump_glib.cc
+++ b/base/message_loop/message_pump_glib.cc
@@ -9,9 +9,13 @@
 #include <math.h>
 
 #if BUILDFLAG(IS_BSD)
+#if BUILDFLAG(IS_NETBSD)
+#include <lwp.h>
+#else
 #include <pthread.h>
 #include <pthread_np.h>
 #endif
+#endif
 
 #include "base/logging.h"
 #include "base/memory/raw_ptr.h"
@@ -64,7 +68,13 @@ int GetTimeIntervalMilliseconds(TimeTicks next_task_time) {
 
 bool RunningOnMainThread() {
 #if BUILDFLAG(IS_BSD)
+#if BUILDFLAG(IS_NETBSD)
+  auto pid = getpid();
+  auto tid = _lwp_self();
+  return pid > 0 && tid > 0 && pid == tid;
+#else
   return pthread_main_np();
+#endif
 #else
   auto pid = getpid();
   auto tid = PlatformThread::CurrentId().raw();
diff --git a/base/posix/sysctl.cc b/base/posix/sysctl.cc
index d0b07c2acc..29365bbe1b 100644
--- a/base/posix/sysctl.cc
+++ b/base/posix/sysctl.cc
@@ -17,17 +17,17 @@
 #include "build/build_config.h"
 
 namespace {
-
+// NetBSD has sysctl_func macro in sys/sysctl.h, workaround: sysctl_func -> sysctl_func2
 std::optional<std::string> StringSysctlImpl(
-    base::FunctionRef<int(char* /*out*/, size_t* /*out_len*/)> sysctl_func) {
+    base::FunctionRef<int(char* /*out*/, size_t* /*out_len*/)> sysctl_func2) {
   size_t buf_len;
-  int result = sysctl_func(nullptr, &buf_len);
+  int result = sysctl_func2(nullptr, &buf_len);
   if (result < 0 || buf_len < 1) {
     return std::nullopt;
   }
 
   std::string value(buf_len - 1, '\0');
-  result = sysctl_func(&value[0], &buf_len);
+  result = sysctl_func2(&value[0], &buf_len);
   if (result < 0) {
     return std::nullopt;
   }
diff --git a/base/process/launch.h b/base/process/launch.h
index 85317e4429..d0a51054eb 100644
--- a/base/process/launch.h
+++ b/base/process/launch.h
@@ -7,6 +7,13 @@
 #ifndef BASE_PROCESS_LAUNCH_H_
 #define BASE_PROCESS_LAUNCH_H_
 
+#if defined(__NetBSD__)
+#define _NETBSD_SOURCE 1
+#ifndef PTHREAD_STACK_MIN
+#define PTHREAD_STACK_MIN 4096
+#endif
+#endif
+
 #include <limits.h>
 #include <stddef.h>
 
diff --git a/base/process/launch_posix.cc b/base/process/launch_posix.cc
index 4f9ffed9d9..543354a5ba 100644
--- a/base/process/launch_posix.cc
+++ b/base/process/launch_posix.cc
@@ -218,6 +218,8 @@ static const char kFDDir[] = "/dev/fd";
 static const char kFDDir[] = "/dev/fd";
 #elif BUILDFLAG(IS_OPENBSD)
 static const char kFDDir[] = "/dev/fd";
+#elif BUILDFLAG(IS_NETBSD)
+static const char kFDDir[] = "/dev/fd";
 #elif BUILDFLAG(IS_ANDROID)
 static const char kFDDir[] = "/proc/self/fd";
 #endif
diff --git a/base/process/process_handle_netbsd.cc b/base/process/process_handle_netbsd.cc
new file mode 100644
index 0000000000..d01cacb2a0
--- /dev/null
+++ b/base/process/process_handle_netbsd.cc
@@ -0,0 +1,56 @@
+// Copyright 2011 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/process/process_handle.h"
+#include "base/files/file_util.h"
+
+#include <stddef.h>
+#include <sys/param.h>
+#include <sys/proc.h>
+#include <sys/sysctl.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <optional>
+
+#include "base/files/file_path.h"
+#include "base/posix/sysctl.h"
+
+namespace base {
+
+ProcessId GetParentProcessId(ProcessHandle process) {
+  struct kinfo_proc2 *info;
+  size_t length;
+  pid_t ppid;
+  int mib[] = { CTL_KERN, KERN_PROC2, KERN_PROC_PID, process,
+                sizeof(struct kinfo_proc2), 1 };
+
+  if (sysctl(mib, std::size(mib), NULL, &length, NULL, 0) < 0) {
+    return -1;
+  }
+
+  info = (struct kinfo_proc2 *)malloc(length);
+
+  mib[5] = static_cast<int>((length / sizeof(struct kinfo_proc2)));
+
+  if (sysctl(mib, std::size(mib), info, &length, NULL, 0) < 0) {
+    ppid = -1;
+    goto out;
+  }
+
+  ppid = info->p_ppid;
+
+out:
+  free(info);
+  return ppid;
+}
+
+FilePath GetProcessExecutablePath(ProcessHandle process) {
+  std::optional<std::string> pathname =
+      base::StringSysctl({CTL_KERN, KERN_PROC_ARGS, process, KERN_PROC_PATHNAME});
+
+  return FilePath(pathname.value_or(std::string{}));
+}
+
+}  // namespace base
diff --git a/base/process/process_handle_openbsd.cc b/base/process/process_handle_openbsd.cc
index 27b5a28f30..624f036264 100644
--- a/base/process/process_handle_openbsd.cc
+++ b/base/process/process_handle_openbsd.cc
@@ -62,7 +62,7 @@ FilePath GetProcessExecutablePath(ProcessHandle process) {
   if ((cpath = getenv("CHROME_EXE_PATH")) != NULL)
     result = FilePath(cpath);
   else
-    result = FilePath("/usr/local/chrome/chrome");
+    result = FilePath("@PREFIX@/lib/chromium/chrome");
 
   if (sysctl(mib, std::size(mib), NULL, &len, NULL, 0) != -1) {
     retvalargs = static_cast<char**>(malloc(len));
diff --git a/base/process/process_iterator.h b/base/process/process_iterator.h
index 3d0734a828..9de7aae748 100644
--- a/base/process/process_iterator.h
+++ b/base/process/process_iterator.h
@@ -25,7 +25,7 @@
 #include <windows.h>
 
 #include <tlhelp32.h>
-#elif BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_OPENBSD)
+#elif BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_NETBSD)
 #include <sys/sysctl.h>
 #elif BUILDFLAG(IS_FREEBSD)
 #include <sys/user.h>
@@ -117,7 +117,11 @@ class BASE_EXPORT ProcessIterator {
   HANDLE snapshot_;
   bool started_iteration_ = false;
 #elif BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_BSD)
+# if BUILDFLAG(IS_NETBSD)
+  std::vector<kinfo_proc2> kinfo_procs_;
+# else
   std::vector<kinfo_proc> kinfo_procs_;
+# endif
   size_t index_of_kinfo_proc_ = 0;
 #elif BUILDFLAG(IS_POSIX)
   struct DIRClose {
diff --git a/base/process/process_iterator_netbsd.cc b/base/process/process_iterator_netbsd.cc
new file mode 100644
index 0000000000..396da4f494
--- /dev/null
+++ b/base/process/process_iterator_netbsd.cc
@@ -0,0 +1,134 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/process/process_iterator.h"
+
+#include <errno.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sys/proc.h>
+#include <sys/sysctl.h>
+
+#include "base/logging.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+
+namespace base {
+
+ProcessIterator::ProcessIterator(const ProcessFilter* filter)
+    : filter_(filter) {
+  int mib[] = { CTL_KERN, KERN_PROC2, KERN_PROC_UID, static_cast<int>(getuid()),
+                sizeof(struct kinfo_proc2), 1 };
+
+  bool done = false;
+  int try_num = 1;
+  const int max_tries = 10;
+  size_t num_of_kinfo_proc;
+
+  do {
+    size_t len = 0;
+    if (sysctl(mib, std::size(mib), NULL, &len, NULL, 0) < 0) {
+      DLOG(ERROR) << "failed to get the size needed for the process list";
+      kinfo_procs_.resize(0);
+      done = true;
+    } else {
+      num_of_kinfo_proc = len / sizeof(struct kinfo_proc2);
+      // Leave some spare room for process table growth (more could show up
+      // between when we check and now)
+      num_of_kinfo_proc += 16;
+      kinfo_procs_.resize(num_of_kinfo_proc);
+      len = num_of_kinfo_proc * sizeof(struct kinfo_proc2);
+      if (sysctl(mib, std::size(mib), &kinfo_procs_[0], &len, NULL, 0) < 0) {
+        // If we get a mem error, it just means we need a bigger buffer, so
+        // loop around again.  Anything else is a real error and give up.
+        if (errno != ENOMEM) {
+          DLOG(ERROR) << "failed to get the process list";
+          kinfo_procs_.resize(0);
+          done = true;
+        }
+      } else {
+        // Got the list, just make sure we're sized exactly right
+        num_of_kinfo_proc = len / sizeof(struct kinfo_proc2);
+        kinfo_procs_.resize(num_of_kinfo_proc);
+        done = true;
+      }
+    }
+  } while (!done && (try_num++ < max_tries));
+
+  if (!done) {
+    DLOG(ERROR) << "failed to collect the process list in a few tries";
+    kinfo_procs_.resize(0);
+  }
+}
+
+ProcessIterator::~ProcessIterator() = default;
+
+bool ProcessIterator::CheckForNextProcess() {
+  std::string data;
+  for (; index_of_kinfo_proc_ < kinfo_procs_.size(); ++index_of_kinfo_proc_) {
+    kinfo_proc2& kinfo = kinfo_procs_[index_of_kinfo_proc_];
+
+    // Skip processes just awaiting collection
+    if ((kinfo.p_pid > 0) && (kinfo.p_stat == SZOMB)) {
+      continue;
+    }
+
+    int mib[] = { CTL_KERN, KERN_PROC_ARGS, kinfo.p_pid };
+
+    // Find out what size buffer we need.
+    size_t data_len = 0;
+    if (sysctl(mib, std::size(mib), NULL, &data_len, NULL, 0) < 0) {
+      DVPLOG(1) << "failed to figure out the buffer size for a commandline";
+      continue;
+    }
+
+    data.resize(data_len);
+    if (sysctl(mib, std::size(mib), &data[0], &data_len, NULL, 0) < 0) {
+      DVPLOG(1) << "failed to fetch a commandline";
+      continue;
+    }
+
+    // |data| contains all the command line parameters of the process, separated
+    // by blocks of one or more null characters. We tokenize |data| into a
+    // vector of strings using '\0' as a delimiter and populate
+    // |entry_.cmd_line_args_|.
+    std::string delimiters;
+    delimiters.push_back('\0');
+    entry_.cmd_line_args_ = SplitString(data, delimiters, KEEP_WHITESPACE,
+                                        SPLIT_WANT_NONEMPTY);
+
+    // |data| starts with the full executable path followed by a null character.
+    // We search for the first instance of '\0' and extract everything before it
+    // to populate |entry_.exe_file_|.
+    size_t exec_name_end = data.find('\0');
+    if (exec_name_end == std::string::npos) {
+      DLOG(ERROR) << "command line data didn't match expected format";
+      continue;
+    }
+
+    entry_.pid_ = kinfo.p_pid;
+    entry_.ppid_ = kinfo.p_ppid;
+    entry_.gid_ = kinfo.p__pgid;
+    size_t last_slash = data.rfind('/', exec_name_end);
+    if (last_slash == std::string::npos) {
+      entry_.exe_file_.assign(data, 0, exec_name_end);
+    } else {
+      entry_.exe_file_.assign(data, last_slash + 1,
+                              exec_name_end - last_slash - 1);
+    }
+    // Start w/ the next entry next time through
+    ++index_of_kinfo_proc_;
+    // Done
+    return true;
+  }
+  return false;
+}
+
+bool NamedProcessIterator::IncludeEntry() {
+  return (executable_name_ == entry().exe_file() &&
+          ProcessIterator::IncludeEntry());
+}
+
+}  // namespace base
diff --git a/base/process/process_metrics_netbsd.cc b/base/process/process_metrics_netbsd.cc
new file mode 100644
index 0000000000..36e0a22aae
--- /dev/null
+++ b/base/process/process_metrics_netbsd.cc
@@ -0,0 +1,173 @@
+// Copyright 2013 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/process/process_metrics.h"
+
+#include <stddef.h>
+#include <stdint.h>
+#include <fcntl.h>
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/vmmeter.h>
+
+#include "base/files/dir_reader_posix.h" // DirReaderPosix
+#include "base/process/internal_linux.h" // GetProcPidDir()
+#include "base/memory/ptr_util.h"
+#include "base/types/expected.h"
+#include "base/values.h"
+#include "base/notimplemented.h"
+
+namespace base {
+
+ProcessMetrics::ProcessMetrics(ProcessHandle process) : process_(process) {}
+
+base::expected<ProcessMemoryInfo, ProcessUsageError>
+ProcessMetrics::GetMemoryInfo() const {
+  ProcessMemoryInfo memory_info;
+  struct kinfo_proc2 info;
+  size_t length = sizeof(struct kinfo_proc2);
+
+  int mib[] = { CTL_KERN, KERN_PROC2, KERN_PROC_PID, process_,
+                sizeof(struct kinfo_proc2), 1 };
+
+  if (process_ == 0) {
+    return base::unexpected(ProcessUsageError::kSystemError);
+  }
+
+  if (sysctl(mib, std::size(mib), &info, &length, NULL, 0) < 0) {
+    return base::unexpected(ProcessUsageError::kSystemError);
+  }
+
+  if (length == 0) {
+    return base::unexpected(ProcessUsageError::kProcessNotFound);
+  }
+
+  memory_info.resident_set_bytes =
+    checked_cast<uint64_t>(info.p_vm_rssize * getpagesize());
+
+  return memory_info;
+}
+
+base::expected<TimeDelta, ProcessCPUUsageError>
+ProcessMetrics::GetCumulativeCPUUsage() {
+  struct kinfo_proc2 info;
+  size_t length = sizeof(struct kinfo_proc2);
+  struct timeval tv;
+
+  int mib[] = { CTL_KERN, KERN_PROC2, KERN_PROC_PID, process_,
+                sizeof(struct kinfo_proc2), 1 };
+
+  if (process_ == 0) {
+    return base::unexpected(ProcessCPUUsageError::kSystemError);
+  }
+
+  if (sysctl(mib, std::size(mib), &info, &length, NULL, 0) < 0) {
+    return base::unexpected(ProcessCPUUsageError::kSystemError);
+  }
+
+  if (length == 0) {
+    return base::unexpected(ProcessCPUUsageError::kProcessNotFound);
+  }
+
+  tv.tv_sec = info.p_rtime_sec;
+  tv.tv_usec = info.p_rtime_usec;
+
+  return base::ok(Microseconds(TimeValToMicroseconds(tv)));
+}
+
+// static
+std::unique_ptr<ProcessMetrics> ProcessMetrics::CreateProcessMetrics(
+    ProcessHandle process) {
+  return WrapUnique(new ProcessMetrics(process));
+}
+
+size_t GetSystemCommitCharge() {
+  int mib[] = { CTL_VM, VM_METER };
+  size_t pagesize;
+  struct vmtotal vmtotal;
+  unsigned long mem_total, mem_free, mem_inactive;
+  size_t len = sizeof(vmtotal);
+
+  if (sysctl(mib, std::size(mib), &vmtotal, &len, NULL, 0) < 0) {
+    return 0;
+  }
+
+  mem_total = vmtotal.t_vm;
+  mem_free = vmtotal.t_free;
+  mem_inactive = vmtotal.t_vm - vmtotal.t_avm;
+
+  pagesize = checked_cast<size_t>(getpagesize());
+
+  return mem_total - (mem_free * pagesize) - (mem_inactive * pagesize);
+}
+
+int ProcessMetrics::GetOpenFdCount() const {
+  // Use /proc/<pid>/fd to count the number of entries there.
+  FilePath fd_path = internal::GetProcPidDir(process_).Append("fd");
+
+  DirReaderPosix dir_reader(fd_path.value().c_str());
+  if (!dir_reader.IsValid()) {
+    return -1;
+  }
+
+  int total_count = 0;
+  for (; dir_reader.Next();) {
+    const char* name = dir_reader.name();
+    if (strcmp(name, ".") != 0 && strcmp(name, "..") != 0) {
+      ++total_count;
+    }
+  }
+
+  return total_count;
+}
+
+int ProcessMetrics::GetOpenFdSoftLimit() const {
+  return getdtablesize();
+//  return GetMaxFds();
+}
+
+bool ProcessMetrics::GetPageFaultCounts(PageFaultCounts* counts) const {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool GetSystemMemoryInfo(SystemMemoryInfo* meminfo) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool GetSystemDiskInfo(SystemDiskInfo* diskinfo) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+bool GetVmStatInfo(VmStatInfo* vmstat) {
+  NOTIMPLEMENTED();
+  return false;
+}
+
+int ProcessMetrics::GetIdleWakeupsPerSecond() {
+  NOTIMPLEMENTED();
+  return 0;
+}
+
+SystemDiskInfo::SystemDiskInfo() {
+  reads = 0;
+  reads_merged = 0;
+  sectors_read = 0;
+  read_time = 0;
+  writes = 0;
+  writes_merged = 0;
+  sectors_written = 0;
+  write_time = 0;
+  io = 0;
+  io_time = 0;
+  weighted_io_time = 0;
+}
+
+SystemDiskInfo::SystemDiskInfo(const SystemDiskInfo&) = default;
+
+SystemDiskInfo& SystemDiskInfo::operator=(const SystemDiskInfo&) = default;
+
+}  // namespace base
diff --git a/base/process/process_metrics_posix.cc b/base/process/process_metrics_posix.cc
index 56906b903c..a8af5d8ff8 100644
--- a/base/process/process_metrics_posix.cc
+++ b/base/process/process_metrics_posix.cc
@@ -21,7 +21,7 @@
 
 #if BUILDFLAG(IS_APPLE)
 #include <malloc/malloc.h>
-#elif BUILDFLAG(IS_OPENBSD)
+#elif BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_NETBSD)
 #include <stdlib.h>
 #else
 #include <malloc.h>
diff --git a/base/profiler/stack_base_address_posix.cc b/base/profiler/stack_base_address_posix.cc
index 21a80955fd..1e6880cc57 100644
--- a/base/profiler/stack_base_address_posix.cc
+++ b/base/profiler/stack_base_address_posix.cc
@@ -20,8 +20,12 @@
 #endif
 
 #if BUILDFLAG(IS_BSD)
+#if BUILDFLAG(IS_NETBSD)
+#include <pthread.h>
+#else
 #include <pthread_np.h>
 #endif
+#endif
 
 #if BUILDFLAG(IS_CHROMEOS)
 extern "C" void* __libc_stack_end;
diff --git a/base/system/sys_info_netbsd.cc b/base/system/sys_info_netbsd.cc
new file mode 100644
index 0000000000..013f946f5b
--- /dev/null
+++ b/base/system/sys_info_netbsd.cc
@@ -0,0 +1,99 @@
+// Copyright 2011 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "base/system/sys_info.h"
+
+#include <stddef.h>
+#include <stdint.h>
+#include <sys/param.h>
+#include <sys/shm.h>
+#include <sys/sysctl.h>
+#include <uvm/uvm_extern.h>
+
+#include "base/notreached.h"
+#include "base/posix/sysctl.h"
+#include "base/strings/string_util.h"
+
+namespace base {
+
+namespace {
+
+ByteCount AmountOfMemory(int pages_name) {
+  long pages = sysconf(pages_name);
+  long page_size = sysconf(_SC_PAGESIZE);
+  if (pages < 0 || page_size < 0) {
+    return ByteCount(0);
+  }
+  return ByteCount(page_size) * page_size;
+}
+
+}  // namespace
+
+// static
+int SysInfo::NumberOfProcessors() {
+  int mib[] = {CTL_HW, HW_NCPU};
+  int ncpu;
+  size_t size = sizeof(ncpu);
+  if (sysctl(mib, std::size(mib), &ncpu, &size, NULL, 0) < 0) {
+    NOTREACHED();
+  }
+  return ncpu;
+}
+
+// static
+std::string SysInfo::CPUModelName() {
+  int mib[] = { CTL_HW, HW_MODEL };
+  char name[256];
+  size_t size = std::size(name);
+
+  if (sysctl(mib, std::size(mib), &name, &size, NULL, 0) == 0) {
+    return name;
+  }
+
+  return std::string();
+}
+
+// static
+ByteCount SysInfo::AmountOfPhysicalMemoryImpl() {
+  return AmountOfMemory(_SC_PHYS_PAGES);
+}
+
+// static
+ByteCount SysInfo::AmountOfAvailablePhysicalMemoryImpl() {
+  // With NetBSD-11
+  //return AmountOfMemory(_SC_AVPHYS_PAGES);
+  struct uvmexp_sysctl uvmexp;
+  size_t len = sizeof(uvmexp);
+  int mib[] = { CTL_VM, VM_UVMEXP2 };
+  if (sysctl(mib, std::size(mib), &uvmexp, &len, NULL, 0) <0) {
+    NOTREACHED();
+    return ByteCount();
+  }
+  return ByteCount(uvmexp.free);
+}
+
+// static
+uint64_t SysInfo::MaxSharedMemorySize() {
+  int mib[] = {CTL_KERN, KERN_SYSVIPC, KERN_SYSVIPC_SHMMAX};
+  size_t limit;
+  size_t size = sizeof(limit);
+  if (sysctl(mib, std::size(mib), &limit, &size, NULL, 0) < 0) {
+    NOTREACHED();
+  }
+  return static_cast<uint64_t>(limit);
+}
+
+// static
+SysInfo::HardwareInfo SysInfo::GetHardwareInfoSync() {
+  HardwareInfo info;
+  // Set the manufacturer to "NetBSD" and the model to
+  // an empty string.
+  info.manufacturer = "NetBSD";
+  info.model = HardwareModelName();
+  DCHECK(IsStringUTF8(info.manufacturer));
+  DCHECK(IsStringUTF8(info.model));
+  return info;
+}
+
+}  // namespace base
diff --git a/base/test/launcher/test_launcher.cc b/base/test/launcher/test_launcher.cc
index 5cab73e684..bed90bc9a5 100644
--- a/base/test/launcher/test_launcher.cc
+++ b/base/test/launcher/test_launcher.cc
@@ -1832,6 +1832,10 @@ bool TestLauncher::Init(CommandLine* command_line) {
   results_tracker_.AddGlobalTag("OS_OPENBSD");
 #endif
 
+#if BUILDFLAG(IS_NETBSD)
+  results_tracker_.AddGlobalTag("OS_NETBSD");
+#endif
+
 #if BUILDFLAG(IS_POSIX)
   results_tracker_.AddGlobalTag("OS_POSIX");
 #endif
diff --git a/base/tracing/trace_time.cc b/base/tracing/trace_time.cc
index b1c86d1dd7..dc5351a68b 100644
--- a/base/tracing/trace_time.cc
+++ b/base/tracing/trace_time.cc
@@ -10,6 +10,8 @@
 
 #if BUILDFLAG(IS_FREEBSD)
 #define CLOCK_BOOTTIME CLOCK_UPTIME
+#elif BUILDFLAG(IS_NETBSD)
+#define CLOCK_BOOTTIME CLOCK_MONOTONIC
 #endif
 
 namespace base::tracing {
diff --git a/base/version_info/version_info.h b/base/version_info/version_info.h
index 1f54eef6f4..614b7684f7 100644
--- a/base/version_info/version_info.h
+++ b/base/version_info/version_info.h
@@ -74,6 +74,8 @@ constexpr std::string_view GetOSType() {
   return "FreeBSD";
 #elif BUILDFLAG(IS_OPENBSD)
   return "OpenBSD";
+#elif BUILDFLAG(IS_NETBSD)
+  return "NetBSD";
 #elif BUILDFLAG(IS_SOLARIS)
   return "Solaris";
 #elif BUILDFLAG(IS_FUCHSIA)
diff --git a/build/config/BUILDCONFIG.gn b/build/config/BUILDCONFIG.gn
index edbeaa4d18..7ebfe040b8 100644
--- a/build/config/BUILDCONFIG.gn
+++ b/build/config/BUILDCONFIG.gn
@@ -137,7 +137,7 @@ declare_args() {
 
   # Set to true when compiling with the Clang compiler.
   is_clang = current_os != "linux" || current_os == "openbsd" ||
-             current_os == "freebsd" ||
+             current_os == "freebsd" || current_os == "netbsd" ||
              (current_cpu != "s390x" && current_cpu != "s390" &&
               current_cpu != "ppc64" && current_cpu != "ppc" &&
               current_cpu != "mips" && current_cpu != "mips64")
@@ -239,6 +239,8 @@ if (host_toolchain == "") {
     host_toolchain = "//build/toolchain/openbsd:clang_$host_cpu"
   } else if (host_os == "freebsd") {
     host_toolchain = "//build/toolchain/freebsd:clang_$host_cpu"
+  } else if (host_os == "netbsd") {
+    host_toolchain = "//build/toolchain/netbsd:clang_$host_cpu"
   } else {
     assert(false, "Unsupported host_os: $host_os")
   }
@@ -288,7 +290,7 @@ if (target_os == "android") {
   assert(
       false,
       "emscripten is not a supported target_os. It is available only as secondary toolchain.")
-} else if (target_os == "openbsd" || target_os == "freebsd") {
+} else if (target_os == "openbsd" || target_os == "freebsd" || target_os == "netbsd") {
   _default_toolchain = host_toolchain
 } else {
   assert(false, "Unsupported target_os: $target_os")
@@ -325,10 +327,11 @@ is_chromeos = current_os == "chromeos"
 is_fuchsia = current_os == "fuchsia"
 is_ios = current_os == "ios"
 is_linux = current_os == "linux" || current_os == "openbsd" ||
-           current_os == "freebsd"
+           current_os == "freebsd" || current_os == "netbsd"
 is_openbsd = current_os == "openbsd"
 is_freebsd = current_os == "freebsd"
-is_bsd = current_os == "openbsd" || current_os == "freebsd"
+is_netbsd = current_os == "netbsd"
+is_bsd = current_os == "openbsd" || current_os == "freebsd" || current_os == "netbsd"
 is_mac = current_os == "mac"
 is_wasm = current_os == "emscripten"
 is_watchos = current_os == "watchos"
diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index 13610f31dd..63bc3fb861 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -1313,7 +1313,7 @@ config("compiler_cpu_abi") {
       }
       cflags += [ "-msse3" ]
     } else if (current_cpu == "x86") {
-      if (is_clang && !is_android && !is_chromeos_device && !Is_bsd) {
+      if (is_clang && !is_android && !is_chromeos_device && !is_bsd) {
         cflags += [ "--target=i386-unknown-linux-gnu" ]
         ldflags += [ "--target=i386-unknown-linux-gnu" ]
       } else {
@@ -2540,7 +2540,7 @@ config("export_dynamic") {
 # 2. Remove the thin_archive config, so that the .a file actually contains all
 #    .o files, instead of just references to .o files in the build directoy
 config("thin_archive") {
-  if ((is_apple && use_lld) || (is_linux && !is_clang) || current_os == "aix") {
+  if ((is_apple && use_lld) || (is_linux && !is_clang) || current_os == "aix" || (is_netbsd)) {
     # The macOS and iOS linker ld64.ldd doesn't support thin archive without
     # symbol table, gcc on linux also throws the error `archive has no index`.
     # AIX does support -s option, not -S option.
diff --git a/build/config/linux/pkg-config.py b/build/config/linux/pkg-config.py
index f0ecfeec03..580596606e 100755
--- a/build/config/linux/pkg-config.py
+++ b/build/config/linux/pkg-config.py
@@ -108,7 +108,7 @@ def main():
   # If this is run on non-Linux platforms, just return nothing and indicate
   # success. This allows us to "kind of emulate" a Linux build from other
   # platforms.
-  if not sys.platform.startswith(tuple(['linux', 'openbsd', 'freebsd'])):
+  if not sys.platform.startswith(tuple(['linux', 'openbsd', 'freebsd', 'netbsd'])):
     print("[[],[],[],[],[]]")
     return 0
 
diff --git a/build/config/ozone.gni b/build/config/ozone.gni
index ea5f122a7a..6d42eec7fd 100644
--- a/build/config/ozone.gni
+++ b/build/config/ozone.gni
@@ -88,6 +88,10 @@ declare_args() {
       ozone_platform = "x11"
       ozone_platform_wayland = false
       ozone_platform_x11 = true
+    } else if (is_netbsd) {
+      ozone_platform = "x11"
+      ozone_platform_wayland = false
+      ozone_platform_x11 = true
     } else if (is_freebsd) {
       ozone_platform = "x11"
       ozone_platform_wayland = true
diff --git a/build/config/rust.gni b/build/config/rust.gni
index 22dc89a743..b43ea8e5b4 100644
--- a/build/config/rust.gni
+++ b/build/config/rust.gni
@@ -63,7 +63,7 @@ declare_args() {
   # Rust targets to be rebuilt, which allows you to update your toolchain and
   # not break incremental builds.
   rustc_version = exec_script("//build/gn_run_binary.py",
-    [ "/usr/local/bin/rustc", "-V" ], "trim string")
+    [ "@PREFIX@/bin/rustc", "-V" ], "trim string")
 
   # Whether artifacts produced by the Rust compiler can participate in ThinLTO.
   #
@@ -178,7 +178,7 @@ if (is_linux || is_chromeos) {
   if (current_cpu == "arm64") {
     rust_abi_target = "aarch64-unknown-linux-gnu"
   } else if (current_cpu == "x86") {
-    rust_abi_target = "i686-unknown-linux-gnu"
+    rust_abi_target = "i586-unknown-linux-gnu"
   } else if (current_cpu == "x64") {
     rust_abi_target = "x86_64-unknown-linux-gnu"
   } else if (current_cpu == "arm") {
diff --git a/build/gn_run_binary.py b/build/gn_run_binary.py
index 375ab50311..8485a0a00a 100644
--- a/build/gn_run_binary.py
+++ b/build/gn_run_binary.py
@@ -23,7 +23,7 @@ if not os.path.isabs(path):
 # The rest of the arguments are passed directly to the executable.
 args = [path] + sys.argv[2:]
 
-ret = subprocess.call(args, env={"CHROME_EXE_PATH":"${WRKSRC}/out/Release/chrome","LD_LIBRARY_PATH":"${WRKSRC}/out/Release"})
+ret = subprocess.call(args, env={"CHROME_EXE_PATH":"@WRKSRC@/out/Release/chrome","LD_LIBRARY_PATH":"@WRKSRC@/out/Release"})
 if ret != 0:
   if ret <= -100:
     # Windows error codes such as 0xC0000005 and 0xC0000409 are much easier to
diff --git a/build/linux/strip_binary.gni b/build/linux/strip_binary.gni
index f74875e2b8..b6edfb0348 100644
--- a/build/linux/strip_binary.gni
+++ b/build/linux/strip_binary.gni
@@ -21,8 +21,8 @@ template("strip_binary") {
                            "testonly",
                          ])
   action("${target_name}") {
-    llvm_strip_binary = "${LOCALBASE}/llvm${MODCLANG_VERSION}/bin/llvm-strip"
-    llvm_objcopy_binary = "${LOCALBASE}/llvm${MODCLANG_VERSION}/bin/llvm-objcopy"
+    llvm_strip_binary = "@PREFIX@/bin/llvm-strip"
+    llvm_objcopy_binary = "@PREFIX@/bin/llvm-objcopy"
     script = "//build/linux/strip_binary.py"
 
     if (defined(invoker.stripped_binary_output)) {
diff --git a/build/rust/rust_bindgen.gni b/build/rust/rust_bindgen.gni
index 25f6891b92..ddcae42f65 100644
--- a/build/rust/rust_bindgen.gni
+++ b/build/rust/rust_bindgen.gni
@@ -12,14 +12,14 @@ if (is_win) {
   import("//build/toolchain/win/win_toolchain_data.gni")
 }
 
-_bindgen_path = "${LOCALBASE}/bin/bindgen"
+_bindgen_path = "@PREFIX@/bin/bindgen"
 if (host_os == "win") {
   _bindgen_path = "${_bindgen_path}.exe"
 }
 
 # On Windows, the libclang.dll is beside the bindgen.exe, otherwise it is in
 # ../lib.
-_libclang_path = "${LOCALBASE}/llvm${MODCLANG_VERSION}"
+_libclang_path = "@PREFIX@"
 if (host_os == "win") {
   _libclang_path += "/bin"
 } else {
diff --git a/build/rust/rust_bindgen_generator.gni b/build/rust/rust_bindgen_generator.gni
index 5ed9253d08..8a4ee7d638 100644
--- a/build/rust/rust_bindgen_generator.gni
+++ b/build/rust/rust_bindgen_generator.gni
@@ -11,14 +11,14 @@ if (is_win) {
   import("//build/toolchain/win/win_toolchain_data.gni")
 }
 
-_bindgen_path = "${LOCALBASE}/bin/bindgen"
+_bindgen_path = "@PREFIX@/bin/bindgen"
 if (host_os == "win") {
   _bindgen_path = "${_bindgen_path}.exe"
 }
 
 # On Windows, the libclang.dll is beside the bindgen.exe, otherwise it is in
 # ../lib.
-_libclang_path = "${LOCALBASE}/llvm${MODCLANG_VERSION}"
+_libclang_path = "@PREFIX@"
 if (host_os == "win") {
   _libclang_path += "/bin"
 } else {
diff --git a/build/toolchain/gcc_toolchain.gni b/build/toolchain/gcc_toolchain.gni
index 404fcb9c6e..1b557d26b9 100644
--- a/build/toolchain/gcc_toolchain.gni
+++ b/build/toolchain/gcc_toolchain.gni
@@ -605,7 +605,7 @@ template("single_gcc_toolchain") {
       # We need to specify link groups, at least, for single pass linkers. I.e.
       # Rust libraries are alpha-sorted instead of by dependencies so they fail
       # to link if not properly ordered or grouped.
-      link_command = "$ld {{ldflags}}${extra_ldflags} -o \"$unstripped_outfile\" $start_group_flag @\"$rspfile\" $end_group_flag {{solibs}} {{libs}} $start_group_flag {{rlibs}} $end_group_flag"
+      link_command = "$ld $start_group_flag {{ldflags}}${extra_ldflags} -o \"$unstripped_outfile\" @\"$rspfile\" {{solibs}} {{libs}} {{rlibs}} $end_group_flag"
 
       # Generate a map file to be used for binary size analysis.
       # Map file adds ~10% to the link time on a z620.
diff --git a/build/toolchain/netbsd/BUILD.gn b/build/toolchain/netbsd/BUILD.gn
new file mode 100644
index 0000000000..27240dd95a
--- /dev/null
+++ b/build/toolchain/netbsd/BUILD.gn
@@ -0,0 +1,66 @@
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/sysroot.gni")
+import("//build/toolchain/gcc_toolchain.gni")
+
+clang_toolchain("clang_x86") {
+  toolchain_args = {
+    current_cpu = "x86"
+    current_os = "netbsd"
+  }
+}
+
+gcc_toolchain("x86") {
+  cc = "gcc"
+  cxx = "g++"
+
+  readelf = "readelf"
+  nm = "nm"
+  ar = "ar"
+  ld = cxx
+
+  toolchain_args = {
+    current_cpu = "x86"
+    current_os = "netbsd"
+    is_clang = false
+  }
+}
+
+clang_toolchain("clang_x64") {
+  toolchain_args = {
+    current_cpu = "x64"
+    current_os = "netbsd"
+  }
+}
+
+gcc_toolchain("x64") {
+  cc = "gcc"
+  cxx = "g++"
+
+  readelf = "readelf"
+  nm = "nm"
+  ar = "ar"
+  ld = cxx
+
+  toolchain_args = {
+    current_cpu = "x64"
+    current_os = "netbsd"
+    is_clang = false
+  }
+}
+
+clang_toolchain("clang_arm") {
+  toolchain_args = {
+    current_cpu = "arm64"
+    current_os = "netbsd"
+  }
+}
+
+clang_toolchain("clang_arm64") {
+  toolchain_args = {
+    current_cpu = "arm64"
+    current_os = "netbsd"
+  }
+}
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index 280dbec718..13fdda83eb 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -871,6 +871,8 @@ const FeatureEntry::FeatureParam kAudioBackendPulseAudio[] = {
         { "audio-backend", "pulseaudio" }};
 const FeatureEntry::FeatureParam kAudioBackendSndio[] = {
         { "audio-backend", "sndio" }};
+const FeatureEntry::FeatureParam kAudioBackendAudioIO[] = {
+        { "audio-backend", "audioio" }};
 const FeatureEntry::FeatureParam kAudioBackendAlsa[] = {
         { "audio-backend", "alsa" }};
 const FeatureEntry::FeatureVariation
@@ -881,6 +883,9 @@ const FeatureEntry::FeatureVariation
         {"using sndio by default if available", kAudioBackendSndio,
          std::size(kAudioBackendSndio),
          nullptr},
+        {"using audioio by default if available", kAudioBackendAudioIO,
+         std::size(kAudioBackendAudioIO),
+         nullptr},
         {"using ALSA by default if available", kAudioBackendAlsa,
          std::size(kAudioBackendAlsa),
          nullptr}};
diff --git a/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc b/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
index 69ac16379d..440efec89c 100644
--- a/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
+++ b/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
@@ -364,6 +364,8 @@ bool ChromeRuntimeAPIDelegate::GetPlatformInfo(PlatformInfo* info) {
     info->os = extensions::api::runtime::PlatformOs::kLinux;
   } else if (os == "freebsd") {
     info->os = extensions::api::runtime::PlatformOs::kLinux;
+  } else if (os == "netbsd") {
+    info->os = extensions::api::runtime::PlatformOs::kLinux;
   } else if (os == "android") {
     info->os = extensions::api::runtime::PlatformOs::kAndroid;
   } else {
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index 043239e95d..990350c3a4 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -8592,6 +8592,8 @@ inline constexpr char kAudioBackendName[] =
 inline constexpr char kAudioBackendDescription[] =
 #if BUILDFLAG(IS_OPENBSD)
     "Select the desired audio backend to use. The default is sndio.";
+#elif BUILDFLAG(IS_NETBSD)
+    "Select the desired audio backend to use. The default is audioio.";
 #elif BUILDFLAG(IS_FREEBSD)
     "Select the desired audio backend to use. The default will automatically "
     "enumerate through the supported backends.";
diff --git a/chrome/common/chrome_paths.cc b/chrome/common/chrome_paths.cc
index 06ef89a82a..5fb6bb9341 100644
--- a/chrome/common/chrome_paths.cc
+++ b/chrome/common/chrome_paths.cc
@@ -52,9 +52,9 @@ std::optional<bool> g_override_using_default_data_directory_for_testing;
 // /usr/share seems like a good choice, see: http://www.pathname.com/fhs/
 const base::FilePath::CharType kFilepathSinglePrefExtensions[] =
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
-    FILE_PATH_LITERAL("/usr/local/share/chromium/extensions");
+    FILE_PATH_LITERAL("@PREFIX@/share/chromium/extensions");
 #else
-    FILE_PATH_LITERAL("/usr/local/share/chromium/extensions");
+    FILE_PATH_LITERAL("@PREFIX@/share/chromium/extensions");
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
@@ -474,9 +474,9 @@ bool PathProvider(int key, base::FilePath* result) {
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
       cur = base::FilePath(
           FILE_PATH_LITERAL("/etc/opt/chrome/native-messaging-hosts"));
-#elif BUILDFLAG(IS_FREEBSD)
+#elif BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
       cur = base::FilePath(FILE_PATH_LITERAL(
-          "/usr/local/etc/chromium/native-messaging-hosts"));
+          "@PREFIX@/etc/chromium/native-messaging-hosts"));
 #else
       cur = base::FilePath(
           FILE_PATH_LITERAL("/etc/chromium/native-messaging-hosts"));
diff --git a/components/crash/core/app/chrome_crashpad_handler.cc b/components/crash/core/app/chrome_crashpad_handler.cc
index 9aa752e77f..5c3ba36cc3 100644
--- a/components/crash/core/app/chrome_crashpad_handler.cc
+++ b/components/crash/core/app/chrome_crashpad_handler.cc
@@ -6,7 +6,7 @@
 extern "C" int CrashpadHandlerMain(int argc, char* argv[]);
 
 int main(int argc, char* argv[]) {
-#if defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
   return -1;
 #else
   return CrashpadHandlerMain(argc, argv);
diff --git a/components/named_mojo_ipc_server/connection_info.h b/components/named_mojo_ipc_server/connection_info.h
index 14b4a9ed0d..5c51e2566b 100644
--- a/components/named_mojo_ipc_server/connection_info.h
+++ b/components/named_mojo_ipc_server/connection_info.h
@@ -17,6 +17,12 @@
 #include <sys/ucred.h>
 #endif
 #include <sys/socket.h>
+#if defined(__NetBSD__)
+#include <sys/un.h>
+#define ucred unpcbid
+#define SO_PEERCRED LOCAL_PEEREID
+#define pid unp_pid
+#endif
 #endif
 
 namespace named_mojo_ipc_server {
diff --git a/components/policy/core/common/cloud/cloud_policy_util.cc b/components/policy/core/common/cloud/cloud_policy_util.cc
index 2b5a9a1cdb..24a7e12c3c 100644
--- a/components/policy/core/common/cloud/cloud_policy_util.cc
+++ b/components/policy/core/common/cloud/cloud_policy_util.cc
@@ -40,7 +40,7 @@
 #include <limits.h>  // For HOST_NAME_MAX
 #endif
 
-#if BUILDFLAG(IS_FREEBSD)
+#if BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
 #include <sys/param.h>
 #define HOST_NAME_MAX MAXHOSTNAMELEN
 #endif
diff --git a/components/policy/core/common/policy_paths.cc b/components/policy/core/common/policy_paths.cc
index 2afbdd5d3f..f849c13dfd 100644
--- a/components/policy/core/common/policy_paths.cc
+++ b/components/policy/core/common/policy_paths.cc
@@ -19,6 +19,8 @@ const char kPolicyPath[] = "/etc/opt/chrome/policies";
 const char kPolicyPath[] = "/etc/opt/chrome_for_testing/policies";
 #elif BUILDFLAG(IS_FREEBSD)
 const char kPolicyPath[] = "/usr/local/etc/chromium/policies";
+#elif BUILDFLAG(IS_NETBSD)
+const char kPolicyPath[] = "@PKG_SYSCONFBASE@/chromium/policies";
 #else
 const char kPolicyPath[] = "/etc/chromium/policies";
 #endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
diff --git a/components/policy/tools/generate_policy_source.py b/components/policy/tools/generate_policy_source.py
index ee0c3b30ea..386c091b4c 100755
--- a/components/policy/tools/generate_policy_source.py
+++ b/components/policy/tools/generate_policy_source.py
@@ -38,9 +38,9 @@ PLATFORM_STRINGS = {
     'ios': ['ios'],
     'fuchsia': ['fuchsia'],
     'chrome.win': ['win'],
-    'chrome.linux': ['linux', 'openbsd', 'freebsd'],
+    'chrome.linux': ['linux', 'openbsd', 'freebsd', 'netbsd'],
     'chrome.mac': ['mac'],
-    'chrome.*': ['win', 'mac', 'linux', 'openbsd', 'freebsd'],
+    'chrome.*': ['win', 'mac', 'linux', 'openbsd', 'freebsd', 'netbsd'],
     'chrome.win7': ['win'],
 }
 
diff --git a/components/sync/base/sync_util.cc b/components/sync/base/sync_util.cc
index 183add7414..8a1757bcda 100644
--- a/components/sync/base/sync_util.cc
+++ b/components/sync/base/sync_util.cc
@@ -44,6 +44,8 @@ std::string GetSystemString() {
   system = "FREEBSD ";
 #elif BUILDFLAG(IS_OPENBSD)
   system = "OPENBSD ";
+#elif BUILDFLAG(IS_NETBSD)
+  system = "NETBSD ";
 #elif BUILDFLAG(IS_MAC)
   system = "MAC ";
 #endif
diff --git a/components/sync_device_info/local_device_info_util_linux.cc b/components/sync_device_info/local_device_info_util_linux.cc
index 0be5361ac9..7be86fc918 100644
--- a/components/sync_device_info/local_device_info_util_linux.cc
+++ b/components/sync_device_info/local_device_info_util_linux.cc
@@ -9,7 +9,7 @@
 
 #include "base/linux_util.h"
 
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__NetBSD__)
 #include <sys/param.h>
 #define HOST_NAME_MAX MAXHOSTNAMELEN
 #endif
diff --git a/components/update_client/update_query_params.cc b/components/update_client/update_query_params.cc
index 9e015028f9..986c03f30b 100644
--- a/components/update_client/update_query_params.cc
+++ b/components/update_client/update_query_params.cc
@@ -41,6 +41,8 @@ constexpr std::string_view kOs =
     "openbsd";
 #elif defined(OS_FREEBSD)
     "freebsd";
+#elif defined(OS_NETBSD)
+    "netbsd";
 #else
 #error "unknown os"
 #endif
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index dfd3674692..bd5e1646cf 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -1873,7 +1873,7 @@ test("content_browsertests") {
     "--disable-crashpad-for-testing",
   ]
 
-  if (is_linux) {
+  if ((is_linux) && !is_bsd) {
     sources += [ "../browser/network/address_map_linux_browsertest.cc" ]
   }
 
diff --git a/extensions/common/api/_permission_features.json b/extensions/common/api/_permission_features.json
index 9c6016f2cd..be1eae5060 100644
--- a/extensions/common/api/_permission_features.json
+++ b/extensions/common/api/_permission_features.json
@@ -61,7 +61,7 @@
     "channel": "stable",
     "extension_types": ["platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },
   "app.window.ime": {
      "channel": "stable",
@@ -77,7 +77,7 @@
     "channel": "stable",
     "extension_types": ["platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },
   "audio": [
     {
@@ -98,13 +98,13 @@
       "channel": "dev",
       "extension_types": ["platform_app"],
       // "desktop_android" is not supported.
-      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
     },
     {
       "channel": "stable",
       "extension_types": ["platform_app"],
       // "desktop_android" is not supported.
-      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"],
+      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"],
       "allowlist": [
         "8C3741E3AF0B93B6E8E0DDD499BB0B74839EA578",
         "E703483CEF33DEC18B4B6DD84B5C776FB9182BDB",
@@ -142,7 +142,7 @@
     {
       "channel": "stable",
       "extension_types": ["platform_app"],
-      "platforms": ["chromeos", "win", "mac", "linux", "openbsd", "freebsd"],
+      "platforms": ["chromeos", "win", "mac", "linux", "openbsd", "freebsd", "netbsd"],
       "allowlist": [
         "1C93BD3CF875F4A73C0B2A163BB8FBDA8B8B3D80",  // http://crbug.com/387169
         "A3BC37E2148AC4E99BE4B16AF9D42DD1E592BBBE",  // http://crbug.com/387169
@@ -217,7 +217,7 @@
     "extension_types": ["extension", "legacy_packaged_app"],
     "max_manifest_version": 2,
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },
   "devtools": {
     "channel": "stable",
@@ -266,7 +266,7 @@
     "channel": "stable",
     "extension_types": ["extension", "platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"],
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"],
     "allowlist": [
       "7910EAFDAF64B947E1CB31B333A9BD14CA556B6C",  // Feedback UI.
       "1C93BD3CF875F4A73C0B2A163BB8FBDA8B8B3D80",  // http://crbug.com/293683
@@ -288,12 +288,12 @@
     "extension_types": ["platform_app"],
     "default_parent": true,
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },{
     "channel": "stable",
     "extension_types": ["extension"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"],
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"],
     "allowlist": [
       "2FC374607C2DF285634B67C64A2E356C607091C3",  // Quickoffice
       "3727DD3E564B6055387425027AD74C58784ACC15",  // Quickoffice internal
@@ -330,13 +330,13 @@
       "channel": "stable",
       "extension_types": ["platform_app"],
       // "desktop_android" is not supported.
-      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
     },
     {
       "channel": "stable",
       "extension_types": ["extension"],
       // "desktop_android" is not supported.
-      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"],
+      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"],
       "allowlist": [
         "D7CD4B3956B1F6E970E4AFCBCD4094B1EF4D07B9",  // http://crbug.com/710541
         "D4EFCCC0CC612380762758BB96C7997224BD6395",  // http://crbug.com/710541
@@ -445,7 +445,7 @@
     "channel": "stable",
     "extension_types": ["extension", "legacy_packaged_app", "platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "mac", "win", "linux", "openbsd", "freebsd"],
+    "platforms": ["chromeos", "mac", "win", "linux", "openbsd", "freebsd", "netbsd"],
     "allowlist": [
       "0DE0F05680A4A056BCEC864ED8DDA84296F82B40",  // http://crbug.com/434651
       "1C93BD3CF875F4A73C0B2A163BB8FBDA8B8B3D80",  // http://crbug.com/293683
@@ -484,7 +484,7 @@
     "channel": "stable",
     "extension_types": ["extension", "legacy_packaged_app", "platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "mac", "win", "linux", "openbsd", "freebsd"],
+    "platforms": ["chromeos", "mac", "win", "linux", "openbsd", "freebsd", "netbsd"],
     "allowlist": [
       // DO NOT ADD ANY MORE ENTRIES HERE.
       // networkingPrivate is being migrated to networking.onc.
@@ -564,7 +564,7 @@
     "channel": "stable",
     "extension_types": ["extension", "platform_app" ],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },
   // Note: runtime is not actually a permission, but some systems check these
   // values to verify restrictions.
@@ -576,13 +576,13 @@
     "channel": "stable",
     "extension_types": ["platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },
   "socket": {
     "channel": "stable",
     "extension_types": ["platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },
   "storage": [
     {
@@ -672,13 +672,13 @@
       "channel": "stable",
       "extension_types": ["extension", "legacy_packaged_app", "platform_app"],
       // "desktop_android" is not supported.
-      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
     },
     {
       "channel": "stable",
       "extension_types": ["hosted_app"],
       // "desktop_android" is not supported.
-      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"],
+      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"],
       "allowlist": ["B44D08FD98F1523ED5837D78D0A606EA9D6206E5"]  // Web Store
     }
   ],
@@ -687,13 +687,13 @@
       "channel": "stable",
       "extension_types": ["extension", "legacy_packaged_app", "platform_app"],
       // "desktop_android" is not supported.
-      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
     },
     {
       "channel": "stable",
       "extension_types": ["hosted_app"],
       // "desktop_android" is not supported.
-      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"],
+      "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"],
       "allowlist": ["B44D08FD98F1523ED5837D78D0A606EA9D6206E5"]  // Web Store
     }
   ],
@@ -720,7 +720,7 @@
     "channel": "stable",
     "extension_types": ["platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },
   "usbDevices": [
     {
@@ -788,7 +788,7 @@
     "channel": "stable",
     "extension_types": ["platform_app"],
     // "desktop_android" is not supported.
-    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd"]
+    "platforms": ["chromeos", "linux", "mac", "win", "openbsd", "freebsd", "netbsd"]
   },
   "webRequest": [
     {
diff --git a/extensions/common/api/runtime.json b/extensions/common/api/runtime.json
index 5e419305d8..a1b3a22da3 100644
--- a/extensions/common/api/runtime.json
+++ b/extensions/common/api/runtime.json
@@ -86,7 +86,8 @@
             {"name": "cros", "description": "Specifies the Chrome operating system."},
             {"name": "linux", "description": "Specifies the Linux operating system."},
             {"name": "openbsd", "description": "Specifies the OpenBSD operating system."},
-            {"name": "freebsd", "description": "Specifies the FreeBSD operating system."}
+            {"name": "freebsd", "description": "Specifies the FreeBSD operating system."},
+            {"name": "netbsd", "description": "Specifies the NetBSD operating system."}
         ]
       },
       {
diff --git a/media/BUILD.gn b/media/BUILD.gn
index a53a359619..fd2a4fc5c8 100644
--- a/media/BUILD.gn
+++ b/media/BUILD.gn
@@ -110,6 +110,9 @@ config("media_config") {
   if (use_sndio) {
     defines += [ "USE_SNDIO" ]
   }
+#  if (use_audioio) {
+#    defines += [ "USE_AUDIOIO" ]
+#  }
 }
 
 # Internal grouping of the configs necessary to support sub-folders having their
diff --git a/media/audio/BUILD.gn b/media/audio/BUILD.gn
index f3c2b84b52..85906f9287 100644
--- a/media/audio/BUILD.gn
+++ b/media/audio/BUILD.gn
@@ -295,7 +295,7 @@ source_set("audio") {
     sources += [ "linux/audio_manager_linux.cc" ]
   }
 
-  if (is_bsd) {
+  if (is_bsd && !use_audioio) {
     sources += [ "sndio/audio_manager_sndio.cc" ]
   }
 
@@ -309,6 +309,17 @@ source_set("audio") {
     ]
    }
 
+  if (use_audioio) {
+    sources += [
+      "audioio/audio_manager_audioio.cc",
+      "audioio/audio_manager_audioio.h",
+      "audioio/audioio_input.cc",
+      "audioio/audioio_input.h",
+      "audioio/audioio_output.cc",
+      "audioio/audioio_output.h"
+    ]
+   }
+
   if (use_alsa) {
     libs += [ "asound" ]
     sources += [
diff --git a/media/base/libvpx_thread_wrapper.cc b/media/base/libvpx_thread_wrapper.cc
index ad545ee2ae..d43ed6bb60 100644
--- a/media/base/libvpx_thread_wrapper.cc
+++ b/media/base/libvpx_thread_wrapper.cc
@@ -5,14 +5,14 @@
 #include "media/base/libvpx_thread_wrapper.h"
 
 #include "media/base/codec_worker_impl.h"
-#if !BUILDFLAG(IS_OPENBSD)
+#if !BUILDFLAG(IS_OPENBSD) && !BUILDFLAG(IS_NETBSD)
 #include "third_party/libvpx/source/libvpx/vpx_util/vpx_thread.h"
 #endif
 
 namespace media {
 
 void InitLibVpxThreadWrapper() {
-#if !BUILDFLAG(IS_OPENBSD)
+#if !BUILDFLAG(IS_OPENBSD) && !BUILDFLAG(IS_NETBSD)
   const VPxWorkerInterface interface =
       CodecWorkerImpl<VPxWorkerInterface, VPxWorkerImpl, VPxWorker,
                       VPxWorkerStatus, VPX_WORKER_STATUS_NOT_OK,
diff --git a/media/base/media_switches.cc b/media/base/media_switches.cc
index c3fc1689c3..d58bfb7ded 100644
--- a/media/base/media_switches.cc
+++ b/media/base/media_switches.cc
@@ -67,7 +67,7 @@ const char kReportVp9AsAnUnsupportedMimeType[] =
     "report-vp9-as-an-unsupported-mime-type";
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_FREEBSD) || \
-    BUILDFLAG(IS_SOLARIS)
+    BUILDFLAG(IS_SOLARIS) || BUILDFLAG(IS_NETBSD)
 // The Alsa device to use when opening an audio input stream.
 const char kAlsaInputDevice[] = "alsa-input-device";
 // The Alsa device to use when opening an audio stream.
@@ -383,6 +383,7 @@ constexpr base::FeatureParam<AudioBackend>::Option
     kAudioBackendOptions[] = {
         {AudioBackend::kAuto,
          "auto"},
+        {AudioBackend::kAudioIO, "audioio"},
         {AudioBackend::kPulseAudio, "pulseaudio"},
         {AudioBackend::kSndio, "sndio"},
         {AudioBackend::kAlsa, "alsa"}};
@@ -392,6 +393,8 @@ const base::FeatureParam<AudioBackend>
         &kAudioBackend, "audio-backend",
 #if BUILDFLAG(IS_OPENBSD)
         AudioBackend::kSndio,
+#elif BUILDFLAG(IS_NETBSD)
+        AudioBackend::kAudioIO,
 #elif BUILDFLAG(IS_FREEBSD)
         AudioBackend::kAuto,
 #endif
diff --git a/media/base/media_switches.h b/media/base/media_switches.h
index 8cdaf4426e..bd153f5efa 100644
--- a/media/base/media_switches.h
+++ b/media/base/media_switches.h
@@ -43,7 +43,7 @@ MEDIA_EXPORT extern const char kDisableBackgroundMediaSuspend[];
 MEDIA_EXPORT extern const char kReportVp9AsAnUnsupportedMimeType[];
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_FREEBSD) || \
-    BUILDFLAG(IS_SOLARIS)
+    BUILDFLAG(IS_SOLARIS) || BUILDFLAG(IS_NETBSD)
 MEDIA_EXPORT extern const char kAlsaInputDevice[];
 MEDIA_EXPORT extern const char kAlsaOutputDevice[];
 #endif
@@ -342,6 +342,7 @@ enum class AudioBackend {
   kAuto,
   kPulseAudio,
   kSndio,
+  kAudioIO,
   kAlsa
 };
 
diff --git a/media/capture/video/linux/fake_v4l2_impl.h b/media/capture/video/linux/fake_v4l2_impl.h
index 2a5d1d2364..435d2e24bc 100644
--- a/media/capture/video/linux/fake_v4l2_impl.h
+++ b/media/capture/video/linux/fake_v4l2_impl.h
@@ -9,7 +9,7 @@
 #include <string>
 
 #include "build/build_config.h"
-#if BUILDFLAG(IS_OPENBSD)
+#if BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_NETBSD)
 #include <sys/videoio.h>
 typedef __uint32_t __u32;
 #else
diff --git a/media/capture/video/linux/v4l2_capture_delegate.cc b/media/capture/video/linux/v4l2_capture_delegate.cc
index c2020e70be..885e118e06 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.cc
+++ b/media/capture/video/linux/v4l2_capture_delegate.cc
@@ -1067,6 +1067,12 @@ void V4L2CaptureDelegate::DoCapture() {
       // in older kernels, and stopping and starting the stream gets the camera
       // out of this bad state. Upgrading the kernel is difficult so this is our
       // way out for now.
+#if BUILDFLAG(IS_NETBSD)
+      // On NetBSD cause: StartStream@media/capture/video/linux/v4l2_capture_delegate.cc:1017,
+      // Error requesting MMAP buffers from V4L2, OS message: Device busy (16)
+      // so do nothing, just wait for timeout_count_ >= kContinuousTimeoutLimit
+      DLOG(WARNING) << "DoCapture: poll timeout";
+#else
       DLOG(WARNING) << "Restarting camera stream";
       if (!StopStream() || !StartStream())
         return;
@@ -1074,6 +1080,7 @@ void V4L2CaptureDelegate::DoCapture() {
           FROM_HERE,
           base::BindOnce(&V4L2CaptureDelegate::DoCapture, GetWeakPtr()));
       return;
+#endif
     } else if (timeout_count_ >= kContinuousTimeoutLimit) {
       SetErrorState(
           VideoCaptureError::kV4L2MultipleContinuousTimeoutsWhileReadPolling,
diff --git a/media/capture/video/linux/v4l2_capture_delegate.h b/media/capture/video/linux/v4l2_capture_delegate.h
index 89ae3bf60e..4c67e80b80 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.h
+++ b/media/capture/video/linux/v4l2_capture_delegate.h
@@ -22,7 +22,7 @@
 #include "media/capture/video/linux/v4l2_capture_device_impl.h"
 #include "media/capture/video/video_capture_device.h"
 
-#if BUILDFLAG(IS_OPENBSD)
+#if BUILDFLAG(IS_OPENBSD) || defined(OS_NETBSD)
 #include <sys/videoio.h>
 #else
 #include <linux/videodev2.h>
diff --git a/media/capture/video/linux/video_capture_device_factory_v4l2.cc b/media/capture/video/linux/video_capture_device_factory_v4l2.cc
index a885068cd7..51c136e220 100644
--- a/media/capture/video/linux/video_capture_device_factory_v4l2.cc
+++ b/media/capture/video/linux/video_capture_device_factory_v4l2.cc
@@ -29,7 +29,7 @@
 #include "media/capture/video/linux/scoped_v4l2_device_fd.h"
 #include "media/capture/video/linux/video_capture_device_linux.h"
 
-#if BUILDFLAG(IS_OPENBSD)
+#if BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_NETBSD)
 #include <sys/videoio.h>
 #else
 #include <linux/videodev2.h>
@@ -44,7 +44,7 @@ bool CompareCaptureDevices(const VideoCaptureDeviceInfo& a,
   return a.descriptor < b.descriptor;
 }
 
-#if !BUILDFLAG(IS_OPENBSD)
+#if !BUILDFLAG(IS_OPENBSD) && !BUILDFLAG(IS_NETBSD)
 // USB VID and PID are both 4 bytes long.
 const size_t kVidPidSize = 4;
 const size_t kMaxInterfaceNameSize = 256;
@@ -106,7 +106,7 @@ class DevVideoFilePathsDeviceProvider
   }
 
   std::string GetDeviceModelId(const std::string& device_id) override {
-#if BUILDFLAG(IS_OPENBSD)
+#if BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_NETBSD)
     return std::string();
 #else
     const std::string file_name = ExtractFileNameFromDeviceId(device_id);
@@ -129,7 +129,7 @@ class DevVideoFilePathsDeviceProvider
   }
 
   std::string GetDeviceDisplayName(const std::string& device_id) override {
-#if BUILDFLAG(IS_OPENBSD)
+#if BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_NETBSD)
     return std::string();
 #else
     const std::string file_name = ExtractFileNameFromDeviceId(device_id);
@@ -308,6 +308,11 @@ std::vector<float> VideoCaptureDeviceFactoryV4L2::GetFrameRateList(
         frame_rates.push_back(
             frame_interval.discrete.denominator /
             static_cast<float>(frame_interval.discrete.numerator));
+#if BUILDFLAG(IS_NETBSD)
+        // On NetBSD VIDIOC_ENUM_FRAMEINTERVALS(video_enum_frameival) always return the same values
+        // and not handle index, what is cause infinity loop. One round is enough.
+        break;
+#endif
       }
     } else if (frame_interval.type == V4L2_FRMIVAL_TYPE_CONTINUOUS ||
                frame_interval.type == V4L2_FRMIVAL_TYPE_STEPWISE) {
diff --git a/media/capture/video/linux/video_capture_device_linux.cc b/media/capture/video/linux/video_capture_device_linux.cc
index e3c13fe0f2..a9059ea1bd 100644
--- a/media/capture/video/linux/video_capture_device_linux.cc
+++ b/media/capture/video/linux/video_capture_device_linux.cc
@@ -15,7 +15,7 @@
 #include "build/build_config.h"
 #include "media/capture/video/linux/v4l2_capture_delegate.h"
 
-#if BUILDFLAG(IS_OPENBSD)
+#if BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_NETBSD)
 #include <sys/videoio.h>
 #else
 #include <linux/videodev2.h>
diff --git a/media/ffmpeg/scripts/build_ffmpeg.py b/media/ffmpeg/scripts/build_ffmpeg.py
index 968fbc40c1..bafd596df5 100755
--- a/media/ffmpeg/scripts/build_ffmpeg.py
+++ b/media/ffmpeg/scripts/build_ffmpeg.py
@@ -45,6 +45,7 @@ ARCH_MAP = {
     'linux': ['ia32', 'x64', 'noasm-x64', 'arm', 'arm-neon', 'arm64', 'riscv64'],
     'openbsd': ['x64', 'arm64', 'ia32'],
     'freebsd': ['x64', 'arm64', 'ia32'],
+    'netbsd': ['x64', 'arm64', 'ia32'],
     'mac': ['x64', 'arm64'],
     'win': ['ia32', 'x64', 'arm64'],
 }
@@ -126,7 +127,7 @@ def PrintAndCheckCall(argv, *args, **kwargs):
 
 
 def GetDsoName(target_os, dso_name, dso_version):
-    if target_os in ('linux', 'linux-noasm', 'android', 'openbsd', 'freebsd'):
+    if target_os in ('linux', 'linux-noasm', 'android', 'openbsd', 'freebsd', 'netbsd'):
         return 'lib%s.so.%s' % (dso_name, dso_version)
     elif target_os == 'mac':
         return 'lib%s.%s.dylib' % (dso_name, dso_version)
@@ -477,7 +478,7 @@ def BuildFFmpeg(target_os, target_arch, host_os, host_arch, parallel_jobs,
     # removing <sys/sysctl.h> soon, so this is needed to silence a deprecation
     # #warning which will be converted to an error via -Werror.
     # There is also no prctl.h
-    if target_os in ['linux', 'linux-noasm', 'openbsd', 'freebsd']:
+    if target_os in ['linux', 'linux-noasm', 'openbsd', 'freebsd', 'netbsd']:
         pre_make_rewrites += [
             (r'(#define HAVE_SYSCTL [01])',
              r'#define HAVE_SYSCTL 0 /* \1 -- forced to 0 for Fuchsia */'),
@@ -600,7 +601,7 @@ def main(argv):
     configure_args = args[2:]
 
     if target_os not in ('android', 'linux', 'linux-noasm', 'mac', 'win',
-                         'all', 'openbsd', 'freebsd'):
+                         'all', 'openbsd', 'freebsd', 'netbsd'):
         parser.print_help()
         return 1
 
@@ -714,7 +715,7 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch,
             '--optflags="-O2"',
         ])
 
-    if target_os in ('linux', 'linux-noasm', 'android', 'openbsd', 'freebsd'):
+    if target_os in ('linux', 'linux-noasm', 'android', 'openbsd', 'freebsd', 'netbsd'):
         if target_arch == 'x64':
             if target_os == 'android':
                 configure_flags['Common'].extend([
@@ -934,7 +935,7 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch,
         # typically be the system one, so explicitly configure use of Clang's
         # ld.lld, to ensure that things like cross-compilation and LTO work.
         # This does not work for ia32 and is always used on mac.
-        if target_arch != 'ia32' and target_os != 'mac':
+        if target_arch != 'ia32' and target_os != 'mac' and target_os != 'netbsd':
             configure_flags['Common'].append('--extra-ldflags=-fuse-ld=lld')
 
     # Should be run on Mac, unless we're cross-compiling on Linux.
diff --git a/media/ffmpeg/scripts/robo_lib/config.py b/media/ffmpeg/scripts/robo_lib/config.py
index c681e1fe1b..8dc21f2615 100644
--- a/media/ffmpeg/scripts/robo_lib/config.py
+++ b/media/ffmpeg/scripts/robo_lib/config.py
@@ -183,7 +183,7 @@ class RoboConfiguration:
             self._host_architecture = "ia32"
         elif platform.machine() == "x86_64" or platform.machine() == "AMD64" or platform.machine() == "amd64":
             self._host_architecture = "x64"
-        elif platform.machine() == "aarch64" or platform.machine() == "arm64":
+        elif platform.machine() == "aarch64" or platform.machine() == "arm64" or platform.machine() == "evbarm":
             self._host_architecture = "arm64"
         elif platform.machine() == "mips32":
             self._host_architecture = "mipsel"
@@ -228,6 +228,8 @@ class RoboConfiguration:
             self._host_operating_system = "openbsd"
         elif platform.system() == "FreeBSD":
             self._host_operating_system = "freebsd"
+        elif platform.system() == "NetBSD":
+            self._host_operating_system = "netbsd"
         else:
             raise ValueError(f"Unsupported platform: {platform.system()}")
 
diff --git a/media/media_options.gni b/media/media_options.gni
index 647256a35e..50b2cfa128 100644
--- a/media/media_options.gni
+++ b/media/media_options.gni
@@ -209,6 +209,9 @@ declare_args() {
   # Enable runtime selection of sndio(7)
   use_sndio = false
 
+  # Enable runtime selection of audio(4)
+  use_audioio = false
+
   # Alsa should be used on all non-Android, non-Mac POSIX systems - with the
   # exception of CastOS desktop builds.
   #
diff --git a/mojo/public/cpp/platform/socket_utils_posix.cc b/mojo/public/cpp/platform/socket_utils_posix.cc
index 7657fbea3c..c9880681c3 100644
--- a/mojo/public/cpp/platform/socket_utils_posix.cc
+++ b/mojo/public/cpp/platform/socket_utils_posix.cc
@@ -30,7 +30,7 @@ bool IsRecoverableError() {
 }
 
 bool GetPeerEuid(base::PlatformFile fd, uid_t* peer_euid) {
-#if BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_FREEBSD)
+#if BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
   uid_t socket_euid;
   gid_t socket_gid;
   if (getpeereid(fd, &socket_euid, &socket_gid) < 0) {
diff --git a/mojo/public/tools/bindings/mojom.gni b/mojo/public/tools/bindings/mojom.gni
index 8144fcf1c3..9a6331fa1d 100644
--- a/mojo/public/tools/bindings/mojom.gni
+++ b/mojo/public/tools/bindings/mojom.gni
@@ -756,6 +756,11 @@ template("mojom") {
       enabled_features += [ "is_bsd" ]
     }
 
+    if (is_netbsd) {
+      enabled_features += [ "is_netbsd" ]
+      enabled_features += [ "is_bsd" ]
+    }
+
     if (is_freebsd) {
       enabled_features += [ "is_freebsd" ]
       enabled_features += [ "is_bsd" ]
diff --git a/net/base/network_change_notifier.cc b/net/base/network_change_notifier.cc
index cd7694a2c6..8fc627cbf6 100644
--- a/net/base/network_change_notifier.cc
+++ b/net/base/network_change_notifier.cc
@@ -540,7 +540,7 @@ base::cstring_view NetworkChangeNotifier::IPAddressChangeTypeToString(
   return kChangeTypeNames[type];
 }
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_BSD)
 // static
 AddressMapOwnerLinux* NetworkChangeNotifier::GetAddressMapOwner() {
   return g_network_change_notifier
@@ -889,7 +889,7 @@ NetworkChangeNotifier::NetworkChangeNotifier(
   }
 }
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_BSD)
 AddressMapOwnerLinux* NetworkChangeNotifier::GetAddressMapOwnerInternal() {
   return nullptr;
 }
diff --git a/net/base/network_change_notifier.h b/net/base/network_change_notifier.h
index f95b8240f9..92e43696ac 100644
--- a/net/base/network_change_notifier.h
+++ b/net/base/network_change_notifier.h
@@ -20,7 +20,7 @@
 #include "net/base/network_handle.h"
 #include "third_party/perfetto/include/perfetto/tracing/track.h"
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_BSD)
 #include "net/base/address_map_linux.h"
 #endif
 
@@ -459,7 +459,7 @@ class NET_EXPORT NetworkChangeNotifier {
   // packets sent lazily.
   static bool IsDefaultNetworkActive();
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_BSD)
   // Returns the AddressTrackerLinux if present.
   static AddressMapOwnerLinux* GetAddressMapOwner();
 #endif
@@ -634,7 +634,7 @@ class NET_EXPORT NetworkChangeNotifier {
       SystemDnsConfigChangeNotifier* system_dns_config_notifier = nullptr,
       bool omit_observers_in_constructor_for_testing = false);
 
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
+#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_BSD)
   // Returns the AddressMapOwnerLinux if present.
   virtual AddressMapOwnerLinux* GetAddressMapOwnerInternal();
 #endif
diff --git a/net/dns/dns_reloader.cc b/net/dns/dns_reloader.cc
index d07385e531..275794e827 100644
--- a/net/dns/dns_reloader.cc
+++ b/net/dns/dns_reloader.cc
@@ -89,20 +89,37 @@ class DnsReloader : public NetworkChangeNotifier::DNSObserver {
     if (!reload_state) {
       auto new_reload_state = std::make_unique<ReloadState>();
       new_reload_state->resolver_generation = resolver_generation_;
+#if BUILDFLAG(IS_NETBSD)
+      memset(&new_reload_state->res, 0, sizeof(new_reload_state->res));
+      res_ninit(&new_reload_state->res);
+#else
       res_ninit(&_res);
+#endif
       tls_reload_state_.Set(std::move(new_reload_state));
     } else if (reload_state->resolver_generation != resolver_generation_) {
       reload_state->resolver_generation = resolver_generation_;
       // It is safe to call res_nclose here since we know res_ninit will have
       // been called above.
+#if BUILDFLAG(IS_NETBSD)
+      res_nclose(&reload_state->res);
+      //memset(&reload_state->res, 0, sizeof(reload_state->res));
+      res_ninit(&reload_state->res);
+#else
       res_nclose(&_res);
       res_ninit(&_res);
+#endif
     }
   }
 
  private:
   struct ReloadState {
+#if BUILDFLAG(IS_NETBSD)
+    ~ReloadState() { res_nclose(&res); }
+
+    struct __res_state res;
+#else
     ~ReloadState() { res_nclose(&_res); }
+#endif
 
     int resolver_generation;
   };
diff --git a/net/dns/public/resolv_reader.cc b/net/dns/public/resolv_reader.cc
index 3d5095a740..7b0ffd4a52 100644
--- a/net/dns/public/resolv_reader.cc
+++ b/net/dns/public/resolv_reader.cc
@@ -64,7 +64,7 @@ std::optional<std::vector<IPEndPoint>> GetNameservers(
   if (!(res.options & RES_INIT))
     return std::nullopt;
 
-#if BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_FREEBSD)
+#if BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
   union res_sockaddr_union addresses[MAXNS];
   int nscount = res_getservers(const_cast<res_state>(&res), addresses, MAXNS);
   DCHECK_GE(nscount, 0);
diff --git a/net/dns/public/scoped_res_state.cc b/net/dns/public/scoped_res_state.cc
index 6f60261edb..a1d4cafaff 100644
--- a/net/dns/public/scoped_res_state.cc
+++ b/net/dns/public/scoped_res_state.cc
@@ -33,7 +33,7 @@ ScopedResState::~ScopedResState() {
 #if !BUILDFLAG(IS_OPENBSD) && !BUILDFLAG(IS_FUCHSIA)
 
   // Prefer res_ndestroy where available.
-#if BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_FREEBSD)
+#if BUILDFLAG(IS_APPLE) || BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
   res_ndestroy(&res_);
 #else
   res_nclose(&res_);
diff --git a/net/socket/tcp_socket_posix.cc b/net/socket/tcp_socket_posix.cc
index 263a8260f9..5cacc04ce7 100644
--- a/net/socket/tcp_socket_posix.cc
+++ b/net/socket/tcp_socket_posix.cc
@@ -6,6 +6,9 @@
 
 #include <errno.h>
 #include <netinet/tcp.h>
+#if BUILDFLAG(IS_NETBSD)
+#include <netinet/in.h>
+#endif
 #include <sys/socket.h>
 
 #include <algorithm>
@@ -98,7 +101,7 @@ bool SetTCPKeepAlive(int fd, bool enable, int delay) {
       PLOG(ERROR) << "Failed to set TCP_KEEPALIVE on fd: " << fd;
       return false;
     }
-#elif BUILDFLAG(IS_FREEBSD)
+#elif BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
   // Set seconds until first TCP keep alive.
   if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof(delay))) {
     PLOG(ERROR) << "Failed to set TCP_KEEPIDLE on fd: " << fd;
diff --git a/net/socket/udp_socket_posix.cc b/net/socket/udp_socket_posix.cc
index 2188644135..48f4e2dc2d 100644
--- a/net/socket/udp_socket_posix.cc
+++ b/net/socket/udp_socket_posix.cc
@@ -78,6 +78,32 @@ constexpr int kBindRetries = 10;
 constexpr int kPortStart = 1024;
 constexpr int kPortEnd = 65535;
 
+#if BUILDFLAG(IS_NETBSD)
+int GetIPv4AddressFromIndex(int socket, uint32_t index, uint32_t* address) {
+  if (!index) {
+    *address = htonl(INADDR_ANY);
+    return OK;
+  }
+
+  sockaddr_in* result = nullptr;
+
+  ifreq ifr;
+  ifr.ifr_addr.sa_family = AF_INET;
+  if (!if_indextoname(index, ifr.ifr_name))
+    return MapSystemError(errno);
+  int rv = ioctl(socket, SIOCGIFADDR, &ifr);
+  if (rv == -1)
+    return MapSystemError(errno);
+  result = reinterpret_cast<sockaddr_in*>(&ifr.ifr_addr);
+
+  if (!result)
+    return ERR_ADDRESS_INVALID;
+
+  *address = result->sin_addr.s_addr;
+  return OK;
+}
+#endif
+
 int GetSocketFDHash(int fd) {
   return fd ^ 1595649551;
 }
@@ -902,9 +928,17 @@ int UDPSocketPosix::SetMulticastOptions() {
   if (multicast_interface_ != 0) {
     switch (addr_family_) {
       case AF_INET: {
+#if BUILDFLAG(IS_NETBSD)
+        ip_mreq mreq = {};
+        int error = GetIPv4AddressFromIndex(socket_, multicast_interface_,
+                                            &mreq.imr_interface.s_addr);
+        if (error != OK)
+          return error;
+#else
         ip_mreqn mreq = {};
         mreq.imr_ifindex = multicast_interface_;
         mreq.imr_address.s_addr = htonl(INADDR_ANY);
+#endif
         int rv = setsockopt(socket_, IPPROTO_IP, IP_MULTICAST_IF,
                             reinterpret_cast<const char*>(&mreq), sizeof(mreq));
         if (rv)
@@ -967,9 +1001,17 @@ int UDPSocketPosix::JoinGroup(const IPAddress& group_address) const {
     case IPAddress::kIPv4AddressSize: {
       if (addr_family_ != AF_INET)
         return ERR_ADDRESS_INVALID;
+#if BUILDFLAG(IS_NETBSD)
+      ip_mreq mreq = {};
+      int error = GetIPv4AddressFromIndex(socket_, multicast_interface_,
+                                          &mreq.imr_interface.s_addr);
+      if (error != OK)
+        return error;
+#else
       ip_mreqn mreq = {};
       mreq.imr_ifindex = multicast_interface_;
       mreq.imr_address.s_addr = htonl(INADDR_ANY);
+#endif
       mreq.imr_multiaddr = ToInAddr(group_address);
       int rv = setsockopt(socket_, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                           &mreq, sizeof(mreq));
@@ -1004,9 +1046,17 @@ int UDPSocketPosix::LeaveGroup(const IPAddress& group_address) const {
     case IPAddress::kIPv4AddressSize: {
       if (addr_family_ != AF_INET)
         return ERR_ADDRESS_INVALID;
+#if BUILDFLAG(IS_NETBSD)
+      ip_mreq mreq = {};
+      int error = GetIPv4AddressFromIndex(socket_, multicast_interface_,
+                                          &mreq.imr_interface.s_addr);
+      if (error != OK)
+        return error;
+#else
       ip_mreqn mreq = {};
       mreq.imr_ifindex = multicast_interface_;
       mreq.imr_address.s_addr = INADDR_ANY;
+#endif
       mreq.imr_multiaddr = ToInAddr(group_address);
       int rv = setsockopt(socket_, IPPROTO_IP, IP_DROP_MEMBERSHIP,
                           &mreq, sizeof(mreq));
diff --git a/net/tools/net_watcher/net_watcher.cc b/net/tools/net_watcher/net_watcher.cc
index e5710df2fd..deb369e786 100644
--- a/net/tools/net_watcher/net_watcher.cc
+++ b/net/tools/net_watcher/net_watcher.cc
@@ -159,7 +159,7 @@ class NetWatcher :
 }  // namespace
 
 int main(int argc, char* argv[]) {
-#if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_BSD)
+#if BUILDFLAG(IS_APPLE)
   base::apple::ScopedNSAutoreleasePool pool;
 #endif
   base::AtExitManager exit_manager;
diff --git a/sandbox/policy/BUILD.gn b/sandbox/policy/BUILD.gn
index 3325d74e40..6c1804199d 100644
--- a/sandbox/policy/BUILD.gn
+++ b/sandbox/policy/BUILD.gn
@@ -125,6 +125,17 @@ component("policy") {
     ]
     libs = [ "util" ]
   }
+  if (is_netbsd) {
+    sources += [
+      "netbsd/sandbox_netbsd.cc",
+      "netbsd/sandbox_netbsd.h",
+    ]
+    deps += [
+      "//sandbox:sandbox_buildflags",
+      "//ui/gfx/x",
+    ]
+    libs = [ "util" ]
+  }
   if (is_freebsd) {
     sources += [
       "freebsd/sandbox_freebsd.cc",
diff --git a/sandbox/policy/mojom/sandbox.mojom b/sandbox/policy/mojom/sandbox.mojom
index dd8ef1e970..57d120c37a 100644
--- a/sandbox/policy/mojom/sandbox.mojom
+++ b/sandbox/policy/mojom/sandbox.mojom
@@ -71,6 +71,9 @@ enum Sandbox {
   [EnableIf=is_openbsd]
   kVideoCapture,
 
+  [EnableIf=is_netbsd]
+  kVideoCapture,
+
   [EnableIf=is_freebsd]
   kVideoCapture,
 
diff --git a/sandbox/policy/netbsd/sandbox_netbsd.cc b/sandbox/policy/netbsd/sandbox_netbsd.cc
new file mode 100644
index 0000000000..9492ab48d7
--- /dev/null
+++ b/sandbox/policy/netbsd/sandbox_netbsd.cc
@@ -0,0 +1,210 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "sandbox/policy/netbsd/sandbox_netbsd.h"
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <sys/resource.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <limits>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/command_line.h"
+#include "base/debug/stack_trace.h"
+#include "base/feature_list.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_file.h"
+#include "base/logging.h"
+#include "base/memory/singleton.h"
+#include "base/path_service.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/system/sys_info.h"
+#include "base/threading/thread.h"
+#include "base/time/time.h"
+#include "build/build_config.h"
+#include "crypto/crypto_buildflags.h"
+#include "sandbox/constants.h"
+#include "sandbox/linux/services/credentials.h"
+#include "sandbox/linux/services/namespace_sandbox.h"
+#include "sandbox/linux/services/proc_util.h"
+#include "sandbox/linux/services/resource_limits.h"
+#include "sandbox/linux/services/thread_helpers.h"
+#include "sandbox/linux/syscall_broker/broker_command.h"
+#include "sandbox/linux/syscall_broker/broker_process.h"
+#include "sandbox/policy/sandbox.h"
+#include "sandbox/policy/sandbox_type.h"
+#include "sandbox/policy/mojom/sandbox.mojom.h"
+#include "sandbox/policy/switches.h"
+#include "sandbox/sandbox_buildflags.h"
+
+#if BUILDFLAG(USING_SANITIZER)
+#include <sanitizer/common_interface_defs.h>
+#endif
+
+#if BUILDFLAG(USE_NSS_CERTS)
+#include "crypto/nss_util.h"
+#endif
+
+#include "third_party/boringssl/src/include/openssl/crypto.h"
+
+#include "ui/gfx/font_util.h"
+
+namespace sandbox {
+namespace policy {
+
+SandboxLinux::SandboxLinux()
+    : sandbox_status_flags_(kInvalid),
+      pre_initialized_(false),
+      initialize_sandbox_ran_(false),
+      broker_process_(nullptr) {
+}
+
+SandboxLinux::~SandboxLinux() {
+  if (pre_initialized_) {
+    CHECK(initialize_sandbox_ran_);
+  }
+}
+
+SandboxLinux* SandboxLinux::GetInstance() {
+  SandboxLinux* instance = base::Singleton<SandboxLinux>::get();
+  CHECK(instance);
+  return instance;
+}
+
+void SandboxLinux::StopThread(base::Thread* thread) {
+  DCHECK(thread);
+  thread->Stop();
+}
+
+void SandboxLinux::PreinitializeSandbox(sandbox::mojom::Sandbox sandbox_type) {
+  CHECK(!pre_initialized_);
+#if BUILDFLAG(USING_SANITIZER)
+  // Sanitizers need to open some resources before the sandbox is enabled.
+  // This should not fork, not launch threads, not open a directory.
+  __sanitizer_sandbox_on_notify(sanitizer_args());
+  sanitizer_args_.reset();
+#endif
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  const std::string process_type =
+      command_line->GetSwitchValueASCII(switches::kProcessType);
+
+  base::SysInfo::AmountOfPhysicalMemory();
+  base::SysInfo::NumberOfProcessors();
+  base::SysInfo::CPUModelName();
+
+  switch (sandbox_type) {
+    case sandbox::mojom::Sandbox::kNoSandbox:
+    {
+#if BUILDFLAG(USE_NSS_CERTS)
+      // The main process has to initialize the ~/.pki dir which won't work
+      // after unveil(2).
+      crypto::EnsureNSSInit();
+#endif
+      CRYPTO_pre_sandbox_init();
+
+      base::FilePath cache_directory, local_directory;
+
+      base::PathService::Get(base::DIR_CACHE, &cache_directory);
+      base::PathService::Get(base::DIR_HOME, &local_directory);
+
+      cache_directory = cache_directory.AppendASCII("chromium");
+      local_directory = local_directory.AppendASCII(".local").AppendASCII("share").AppendASCII("applications");
+
+      if (!base::CreateDirectory(cache_directory)) {
+        LOG(ERROR) << "Failed to create " << cache_directory.value() << " directory.";
+      }
+
+      if (!base::CreateDirectory(local_directory)) {
+        LOG(ERROR) << "Failed to create " << local_directory.value() << " directory.";
+      }
+
+      break;
+    }
+    case sandbox::mojom::Sandbox::kRenderer:
+      gfx::InitializeFonts();
+      break;
+    default:
+      break;
+  }
+
+  pre_initialized_ = true;
+}
+
+bool SandboxLinux::InitializeSandbox(sandbox::mojom::Sandbox sandbox_type,
+                                     SandboxLinux::PreSandboxHook hook,
+                                     const Options& options) {
+  DCHECK(!initialize_sandbox_ran_);
+  initialize_sandbox_ran_ = true;
+
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  const std::string process_type =
+      command_line->GetSwitchValueASCII(switches::kProcessType);
+
+  if (command_line->HasSwitch(switches::kNoSandbox))
+    return true;
+
+  VLOG(1) << "SandboxLinux::InitializeSandbox: process_type="
+      << process_type << " sandbox_type=" << sandbox_type;
+
+  // Only one thread is running, pre-initialize if not already done.
+  if (!pre_initialized_)
+    PreinitializeSandbox(sandbox_type);
+
+  // Attempt to limit the future size of the address space of the process.
+  int error = 0;
+  const bool limited_as = LimitAddressSpace(&error);
+  if (error) {
+    // Restore errno. Internally to |LimitAddressSpace|, the errno due to
+    // setrlimit may be lost.
+    errno = error;
+    PCHECK(limited_as);
+  }
+
+  if (hook)
+    CHECK(std::move(hook).Run(options));
+
+  return true;
+}
+
+bool SandboxLinux::LimitAddressSpace(int* error) {
+#if !defined(ADDRESS_SANITIZER) && !defined(MEMORY_SANITIZER) && \
+    !defined(THREAD_SANITIZER) && !defined(LEAK_SANITIZER)
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (SandboxTypeFromCommandLine(*command_line) == sandbox::mojom::Sandbox::kNoSandbox) {
+    return false;
+  }
+
+  // Unfortunately, it does not appear possible to set RLIMIT_AS such that it
+  // will both (a) be high enough to support V8's and WebAssembly's address
+  // space requirements while also (b) being low enough to mitigate exploits
+  // using integer overflows that require large allocations, heap spray, or
+  // other memory-hungry attack modes.
+
+  *error = sandbox::ResourceLimits::Lower(
+      RLIMIT_DATA, static_cast<rlim_t>(sandbox::kDataSizeLimit));
+
+  // Cache the resource limit before turning on the sandbox.
+  base::SysInfo::AmountOfVirtualMemory();
+  base::SysInfo::MaxSharedMemorySize();
+
+  return *error == 0;
+#else
+  base::SysInfo::AmountOfVirtualMemory();
+  return false;
+#endif  // !defined(ADDRESS_SANITIZER) && !defined(MEMORY_SANITIZER) &&
+        // !defined(THREAD_SANITIZER) && !defined(LEAK_SANITIZER)
+}
+
+}  // namespace policy
+}  // namespace sandbox
diff --git a/sandbox/policy/netbsd/sandbox_netbsd.h b/sandbox/policy/netbsd/sandbox_netbsd.h
new file mode 100644
index 0000000000..d61153c7e5
--- /dev/null
+++ b/sandbox/policy/netbsd/sandbox_netbsd.h
@@ -0,0 +1,276 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+#ifndef SANDBOX_POLICY_LINUX_SANDBOX_OPENBSD_H_
+#define SANDBOX_POLICY_LINUX_SANDBOX_OPENBSD_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/logging.h"
+#include "base/posix/global_descriptors.h"
+#include "sandbox/policy/export.h"
+#include "sandbox/policy/linux/sandbox_seccomp_bpf_linux.h"
+#include "sandbox/policy/mojom/sandbox.mojom.h"
+#include "base/sanitizer_buildflags.h"
+
+#if BUILDFLAG(USING_SANITIZER)
+#include <sanitizer/common_interface_defs.h>
+#endif
+
+namespace base {
+template <typename T>
+struct DefaultSingletonTraits;
+class Thread;
+}  // namespace base
+
+namespace sandbox {
+namespace syscall_broker {
+class BrokerProcess;
+}  // namespace syscall_broker
+}  // namespace sandbox
+
+namespace sandbox {
+namespace policy {
+
+// A singleton class to represent and change our sandboxing state for the
+// three main Linux sandboxes.
+// The sandboxing model allows using two layers of sandboxing. The first layer
+// can be implemented either with unprivileged namespaces or with the setuid
+// sandbox. This class provides a way to engage the namespace sandbox, but does
+// not deal with the legacy setuid sandbox directly.
+// The second layer is mainly based on seccomp-bpf and is engaged with
+// InitializeSandbox(). InitializeSandbox() is also responsible for "sealing"
+// the first layer of sandboxing. That is, InitializeSandbox must always be
+// called to have any meaningful sandboxing at all.
+class SANDBOX_POLICY_EXPORT SandboxLinux {
+ public:
+  // This is a list of sandbox IPC methods which the renderer may send to the
+  // sandbox host. See
+  // https://chromium.googlesource.com/chromium/src/+/master/docs/linux_sandbox_ipc.md
+  // This isn't the full list, values < 32 are reserved for methods called from
+  // Skia, and values < 64 are reserved for libc_interceptor.cc.
+  enum LinuxSandboxIPCMethods {
+    DEPRECATED_METHOD_GET_FALLBACK_FONT_FOR_CHAR = 64,
+    DEPRECATED_METHOD_GET_CHILD_WITH_INODE,
+    DEPRECATED_METHOD_GET_STYLE_FOR_STRIKE,
+    METHOD_MAKE_SHARED_MEMORY_SEGMENT,
+    DEPRECATED_METHOD_MATCH_WITH_FALLBACK,
+  };
+
+  // These form a bitmask which describes the conditions of the Linux sandbox.
+  // Note: this doesn't strictly give you the current status, it states
+  // what will be enabled when the relevant processes are initialized.
+  enum Status {
+    // SUID sandbox active.
+    kSUID = 1 << 0,
+
+    // Sandbox is using a new PID namespace.
+    kPIDNS = 1 << 1,
+
+    // Sandbox is using a new network namespace.
+    kNetNS = 1 << 2,
+
+    // seccomp-bpf sandbox active.
+    kSeccompBPF = 1 << 3,
+
+    // The Yama LSM module is present and enforcing.
+    kYama = 1 << 4,
+
+    // seccomp-bpf sandbox is active and the kernel supports TSYNC.
+    kSeccompTSYNC = 1 << 5,
+
+    // User namespace sandbox active.
+    kUserNS = 1 << 6,
+
+    // A flag that denotes an invalid sandbox status.
+    kInvalid = 1 << 31,
+  };
+
+  // SandboxLinux Options are a superset of SandboxSecompBPF Options.
+  struct Options : public SandboxSeccompBPF::Options {
+    // When running with a zygote, the namespace sandbox will have already
+    // been engaged prior to initializing SandboxLinux itself, and need not
+    // be done so again. Set to true to indicate that there isn't a zygote
+    // for this process and the step is to be performed here explicitly.
+    bool engage_namespace_sandbox = false;
+
+    // Allow starting the sandbox with multiple threads already running. This
+    // will enable TSYNC for seccomp-BPF, which syncs the seccomp-BPF policy
+    // across all running threads.
+    bool allow_threads_during_sandbox_init = false;
+
+    // Enables the CHECK for open directories. The open directory check is only
+    // useful for the chroot jail (from the semantic layer of the sandbox), and
+    // can safely be disabled if we are only enabling the seccomp-BPF layer.
+    bool check_for_open_directories = true;
+  };
+
+  // Callers can provide this hook to run code right before the policy
+  // is passed to the BPF compiler and the sandbox is engaged. If
+  // pre_sandbox_hook() returns true, the sandbox will be engaged
+  // afterwards, otherwise the process is terminated.
+  using PreSandboxHook = base::OnceCallback<bool(Options)>;
+
+  // Get our singleton instance.
+  static SandboxLinux* GetInstance();
+
+  SandboxLinux(const SandboxLinux&) = delete;
+  SandboxLinux& operator=(const SandboxLinux&) = delete;
+
+  bool SetPledge(const char *pstring, const char *ppath);
+  bool SetUnveil(const std::string process_type, sandbox::mojom::Sandbox sandbox_type);
+
+  // Do some initialization that can only be done before any of the sandboxes
+  // are enabled. If using the setuid sandbox, this should be called manually
+  // before the setuid sandbox is engaged.
+  // Security: When this runs, it is imperative that either InitializeSandbox()
+  // runs as well or that all file descriptors returned in
+  // GetFileDescriptorsToClose() get closed.
+  // Otherwise file descriptors that bypass the security of the setuid sandbox
+  // would be kept open. One must be particularly careful if a process performs
+  // a fork().
+  void PreinitializeSandbox(sandbox::mojom::Sandbox sandbox_type);
+
+  // Check that the current process is the init process of a new PID
+  // namespace and then proceed to drop access to the file system by using
+  // a new unprivileged namespace. This is a layer-1 sandbox.
+  // In order for this sandbox to be effective, it must be "sealed" by calling
+  // InitializeSandbox().
+  void EngageNamespaceSandbox(bool from_zygote);
+
+  // Return a list of file descriptors to close if PreinitializeSandbox() ran
+  // but InitializeSandbox() won't. Avoid using.
+  // TODO(jln): get rid of this hack.
+  std::vector<int> GetFileDescriptorsToClose();
+
+  // Seal an eventual layer-1 sandbox and initialize the layer-2 sandbox with
+  // an adequate policy depending on the process type and command line
+  // arguments.
+  // Currently the layer-2 sandbox is composed of seccomp-bpf and address space
+  // limitations.
+  // This function should only be called without any thread running.
+  bool InitializeSandbox(sandbox::mojom::Sandbox sandbox_type,
+                         PreSandboxHook hook,
+                         const Options& options);
+
+  // Stop |thread| in a way that can be trusted by the sandbox.
+  void StopThread(base::Thread* thread);
+
+  // Returns the status of the renderer, worker and ppapi sandbox. Can only
+  // be queried after going through PreinitializeSandbox(). This is a bitmask
+  // and uses the constants defined in "enum Status" above. Since the
+  // status needs to be provided before the sandboxes are actually started,
+  // this returns what will actually happen once InitializeSandbox()
+  // is called from inside these processes.
+  int GetStatus();
+
+  // Returns true if the current process is single-threaded or if the number
+  // of threads cannot be determined.
+  bool IsSingleThreaded() const;
+
+  // Returns true if we started Seccomp BPF.
+  bool seccomp_bpf_started() const;
+
+  // Check the policy and eventually start the seccomp-bpf sandbox. This should
+  // never be called with threads started. If we detect that threads have
+  // started we will crash.
+  bool StartSeccompBPF(sandbox::mojom::Sandbox sandbox_type,
+                       PreSandboxHook hook,
+                       const Options& options);
+
+  // Limit the address space of the current process (and its children) to make
+  // some vulnerabilities harder to exploit. Writes the errno due to setrlimit
+  // (including 0 if no error) into |error|.
+  bool LimitAddressSpace(int* error);
+
+  // Returns a file descriptor to proc. The file descriptor is no longer valid
+  // after the sandbox has been sealed.
+  int proc_fd() const {
+    DCHECK_NE(-1, proc_fd_);
+    return proc_fd_;
+  }
+
+#if BUILDFLAG(USING_SANITIZER)
+  __sanitizer_sandbox_arguments* sanitizer_args() const {
+    return sanitizer_args_.get();
+  };
+#endif
+
+  // A BrokerProcess is a helper that is started before the sandbox is engaged,
+  // typically from a pre-sandbox hook, that will serve requests to access
+  // files over an IPC channel. The client  of this runs from a SIGSYS handler
+  // triggered by the seccomp-bpf sandbox.
+  // |client_sandbox_policy| is the policy being run by the client, and is
+  // used to derive the equivalent broker-side policy.
+  // |broker_side_hook| is an alternate pre-sandbox hook to be run before the
+  // broker itself gets sandboxed, to which the broker side policy and
+  // |options| are passed.
+  // Crashes the process if the broker can not be started since continuation
+  // is impossible (and presumably unsafe).
+  // This should never be destroyed, as after the sandbox is started it is
+  // vital to the process.
+#if 0
+  void StartBrokerProcess(
+      const sandbox::syscall_broker::BrokerCommandSet& allowed_command_set,
+      std::vector<sandbox::syscall_broker::BrokerFilePermission> permissions,
+      PreSandboxHook broker_side_hook,
+      const Options& options);
+
+  sandbox::syscall_broker::BrokerProcess* broker_process() const {
+    return broker_process_;
+  }
+#endif
+
+ private:
+  friend struct base::DefaultSingletonTraits<SandboxLinux>;
+
+  SandboxLinux();
+  ~SandboxLinux();
+
+  // We must have been pre_initialized_ before using these.
+  bool seccomp_bpf_supported() const;
+  bool seccomp_bpf_with_tsync_supported() const;
+
+  // Returns true if it can be determined that the current process has open
+  // directories that are not managed by the SandboxLinux class. This would
+  // be a vulnerability as it would allow to bypass the setuid sandbox.
+  bool HasOpenDirectories() const;
+
+  // The last part of the initialization is to make sure any temporary "hole"
+  // in the sandbox is closed. For now, this consists of closing proc_fd_.
+  void SealSandbox();
+
+  // GetStatus() makes promises as to how the sandbox will behave. This
+  // checks that no promises have been broken.
+  void CheckForBrokenPromises(sandbox::mojom::Sandbox sandbox_type);
+
+  // Stop |thread| and make sure it does not appear in /proc/self/tasks/
+  // anymore.
+  void StopThreadAndEnsureNotCounted(base::Thread* thread) const;
+
+  // A file descriptor to /proc. It's dangerous to have it around as it could
+  // allow for sandbox bypasses. It needs to be closed before we consider
+  // ourselves sandboxed.
+  int proc_fd_;
+
+  bool seccomp_bpf_started_;
+  // The value returned by GetStatus(). Gets computed once and then cached.
+  int sandbox_status_flags_;
+  // Did PreinitializeSandbox() run?
+  bool pre_initialized_;
+  bool seccomp_bpf_supported_;             // Accurate if pre_initialized_.
+  bool seccomp_bpf_with_tsync_supported_;  // Accurate if pre_initialized_.
+  bool yama_is_enforcing_;                 // Accurate if pre_initialized_.
+  bool initialize_sandbox_ran_;            // InitializeSandbox() was called.
+#if BUILDFLAG(USING_SANITIZER)
+  std::unique_ptr<__sanitizer_sandbox_arguments> sanitizer_args_;
+#endif
+  sandbox::syscall_broker::BrokerProcess* broker_process_;  // Leaked as global.
+};
+
+}  // namespace policy
+}  // namespace sandbox
+
+#endif  // SANDBOX_POLICY_LINUX_SANDBOX_OPENBSD_H_
diff --git a/sandbox/policy/openbsd/sandbox_openbsd.cc b/sandbox/policy/openbsd/sandbox_openbsd.cc
index a499665f50..a40a980418 100644
--- a/sandbox/policy/openbsd/sandbox_openbsd.cc
+++ b/sandbox/policy/openbsd/sandbox_openbsd.cc
@@ -65,11 +65,11 @@
 
 #define MAXTOKENS	3
 
-#define _UNVEIL_MAIN		"/etc/chromium/unveil.main";
-#define _UNVEIL_GPU		"/etc/chromium/unveil.gpu";
-#define _UNVEIL_UTILITY_NETWORK	"/etc/chromium/unveil.utility_network";
-#define _UNVEIL_UTILITY_AUDIO	"/etc/chromium/unveil.utility_audio";
-#define _UNVEIL_UTILITY_VIDEO	"/etc/chromium/unveil.utility_video";
+#define _UNVEIL_MAIN		"@PKG_SYSCONFBASE@/chromium/unveil.main";
+#define _UNVEIL_GPU		"@PKG_SYSCONFBASE@/chromium/unveil.gpu";
+#define _UNVEIL_UTILITY_NETWORK	"@PKG_SYSCONFBASE@/chromium/unveil.utility_network";
+#define _UNVEIL_UTILITY_AUDIO	"@PKG_SYSCONFBASE@/chromium/unveil.utility_audio";
+#define _UNVEIL_UTILITY_VIDEO	"@PKG_SYSCONFBASE@/chromium/unveil.utility_video";
 
 namespace sandbox {
 namespace policy {
@@ -331,7 +331,7 @@ bool SandboxLinux::InitializeSandbox(sandbox::mojom::Sandbox sandbox_type,
 
   switch(sandbox_type) {
     case sandbox::mojom::Sandbox::kNoSandbox:
-      SetPledge(NULL, "/etc/chromium/pledge.main");
+      SetPledge(NULL, "@PKG_SYSCONFBASE@/chromium/pledge.main");
       break;
     case sandbox::mojom::Sandbox::kRenderer:
       // prot_exec needed by v8
@@ -343,13 +343,13 @@ bool SandboxLinux::InitializeSandbox(sandbox::mojom::Sandbox sandbox_type,
       SetPledge("stdio drm inet rpath flock cpath wpath prot_exec recvfd sendfd tmppath unix", NULL);
       break;
     case sandbox::mojom::Sandbox::kAudio:
-      SetPledge(NULL, "/etc/chromium/pledge.utility_audio");
+      SetPledge(NULL, "@PKG_SYSCONFBASE@/chromium/pledge.utility_audio");
       break;
     case sandbox::mojom::Sandbox::kNetwork:
-      SetPledge(NULL, "/etc/chromium/pledge.utility_network");
+      SetPledge(NULL, "@PKG_SYSCONFBASE@/chromium/pledge.utility_network");
       break;
     case sandbox::mojom::Sandbox::kVideoCapture:
-      SetPledge(NULL, "/etc/chromium/pledge.utility_video");
+      SetPledge(NULL, "@PKG_SYSCONFBASE@/chromium/pledge.utility_video");
       break;
     case sandbox::mojom::Sandbox::kUtility:
     case sandbox::mojom::Sandbox::kService:
diff --git a/sandbox/policy/sandbox.h b/sandbox/policy/sandbox.h
index 44f331a70f..4a27162638 100644
--- a/sandbox/policy/sandbox.h
+++ b/sandbox/policy/sandbox.h
@@ -14,6 +14,8 @@
 
 #if BUILDFLAG(IS_OPENBSD)
 #include "sandbox/policy/openbsd/sandbox_openbsd.h"
+#elif BUILDFLAG(IS_NETBSD)
+#include "sandbox/policy/netbsd/sandbox_netbsd.h"
 #elif BUILDFLAG(IS_FREEBSD)
 #include "sandbox/policy/freebsd/sandbox_freebsd.h"
 #endif
diff --git a/services/device/hid/BUILD.gn b/services/device/hid/BUILD.gn
index 0eb19e2487..9e19a413de 100644
--- a/services/device/hid/BUILD.gn
+++ b/services/device/hid/BUILD.gn
@@ -53,6 +53,13 @@ source_set("hid") {
     ]
   }
 
+  if (is_netbsd) {
+    sources += [
+      "hid_service_netbsd.cc",
+      "hid_service_netbsd.h",
+    ]
+  }
+
   if ((is_linux || is_chromeos) && !is_bsd && use_udev) {
     sources += [
       "hid_connection_linux.cc",
diff --git a/services/device/hid/hid_service.cc b/services/device/hid/hid_service.cc
index 0eda048353..e0ee0c8837 100644
--- a/services/device/hid/hid_service.cc
+++ b/services/device/hid/hid_service.cc
@@ -30,6 +30,8 @@
 #include "services/device/hid/hid_service_win.h"
 #elif BUILDFLAG(IS_FUCHSIA)
 #include "services/device/hid/hid_service_fuchsia.h"
+#elif BUILDFLAG(IS_NETBSD)
+#include "services/device/hid/hid_service_netbsd.h"
 #endif
 
 namespace device {
@@ -82,6 +84,8 @@ std::unique_ptr<HidService> HidService::Create() {
   return std::make_unique<HidServiceWin>();
 #elif BUILDFLAG(IS_FUCHSIA)
   return std::make_unique<HidServiceFuchsia>();
+#elif BUILDFLAG(IS_NETBSD)
+  return std::make_unique<HidServiceNetBSD>();
 #else
   return nullptr;
 #endif
diff --git a/services/device/hid/hid_service_freebsd.cc b/services/device/hid/hid_service_freebsd.cc
index 8ddb074bfc..3104e367cf 100644
--- a/services/device/hid/hid_service_freebsd.cc
+++ b/services/device/hid/hid_service_freebsd.cc
@@ -228,7 +228,7 @@ class HidServiceFreeBSD::BlockingTaskRunnerHelper {
     struct sockaddr_un sa;
 
     sa.sun_family = AF_UNIX;
-    strlcpy(sa.sun_path, "/var/run/devd.seqpacket.pipe", sizeof(sa.sun_path));
+    strlcpy(sa.sun_path, "@VARBASE@/run/devd.seqpacket.pipe", sizeof(sa.sun_path));
     if (connect(devd_fd, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
       close(devd_fd);
       return;
diff --git a/services/device/hid/hid_service_netbsd.cc b/services/device/hid/hid_service_netbsd.cc
new file mode 100644
index 0000000000..2f79bdca05
--- /dev/null
+++ b/services/device/hid/hid_service_netbsd.cc
@@ -0,0 +1,27 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/device/hid/hid_service_netbsd.h"
+
+#include "base/notimplemented.h"
+#include "services/device/hid/hid_connection.h"
+
+namespace device {
+
+HidServiceNetBSD::HidServiceNetBSD() = default;
+HidServiceNetBSD::~HidServiceNetBSD() = default;
+
+void HidServiceNetBSD::Connect(const std::string& device_id,
+                                bool allow_protected_reports,
+                                bool allow_fido_reports,
+                                ConnectCallback callback) {
+  NOTIMPLEMENTED_LOG_ONCE();
+  std::move(callback).Run(nullptr);
+}
+
+base::WeakPtr<HidService> HidServiceNetBSD::GetWeakPtr() {
+  return weak_factory_.GetWeakPtr();
+}
+
+}  // namespace device
diff --git a/services/device/hid/hid_service_netbsd.h b/services/device/hid/hid_service_netbsd.h
new file mode 100644
index 0000000000..37599f80c0
--- /dev/null
+++ b/services/device/hid/hid_service_netbsd.h
@@ -0,0 +1,33 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_DEVICE_HID_HID_SERVICE_NETBSD_H_
+#define SERVICES_DEVICE_HID_HID_SERVICE_NETBSD_H_
+
+#include "services/device/hid/hid_service.h"
+
+namespace device {
+
+class HidServiceNetBSD : public HidService {
+ public:
+  HidServiceNetBSD();
+  ~HidServiceNetBSD() override;
+
+  HidServiceNetBSD(const HidServiceNetBSD&) = delete;
+  HidServiceNetBSD& operator=(const HidServiceNetBSD&) = delete;
+
+ private:
+  // HidService implementation.
+  void Connect(const std::string& device_id,
+               bool allow_protected_reports,
+               bool allow_fido_reports,
+               ConnectCallback callback) override;
+  base::WeakPtr<HidService> GetWeakPtr() override;
+
+  base::WeakPtrFactory<HidServiceNetBSD> weak_factory_{this};
+};
+
+}  // namespace device
+
+#endif  // SERVICES_DEVICE_HID_HID_SERVICE_NETBSD_H_
diff --git a/services/device/time_zone_monitor/time_zone_monitor_linux.cc b/services/device/time_zone_monitor/time_zone_monitor_linux.cc
index b09f8b219a..aedb6d52f9 100644
--- a/services/device/time_zone_monitor/time_zone_monitor_linux.cc
+++ b/services/device/time_zone_monitor/time_zone_monitor_linux.cc
@@ -132,7 +132,7 @@ class TimeZoneMonitorLinuxImpl
     // reasonable.
     const auto kFilesToWatch = std::to_array<const char*>({
 #if BUILDFLAG(IS_BSD)
-        "/etc/localtime",
+        "@PKG_SYSCONFBASE@/localtime",
 #else
         "/etc/timezone",
         "/etc/TZ",
diff --git a/services/device/usb/BUILD.gn b/services/device/usb/BUILD.gn
index 0d90e163ab..8dc3dc06a4 100644
--- a/services/device/usb/BUILD.gn
+++ b/services/device/usb/BUILD.gn
@@ -113,7 +113,7 @@ static_library("usb") {
     deps += [ "//third_party/libusb" ]
   }
 
-  if (is_freebsd) {
+  if (is_freebsd || is_netbsd) {
     sources += [
       "usb_service_fake.cc",
       "usb_service_fake.h",
diff --git a/services/device/usb/usb_service.cc b/services/device/usb/usb_service.cc
index bed6dce666..50cda5f07b 100644
--- a/services/device/usb/usb_service.cc
+++ b/services/device/usb/usb_service.cc
@@ -28,7 +28,7 @@
 #include "services/device/usb/usb_service_win.h"
 #elif BUILDFLAG(IS_OPENBSD)
 #include "services/device/usb/usb_service_impl.h"
-#elif BUILDFLAG(IS_FREEBSD)
+#elif BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
 #include "services/device/usb/usb_service_fake.h"
 #endif
 
diff --git a/services/network/network_sandbox_hook_linux.h b/services/network/network_sandbox_hook_linux.h
index 9d39bb72c6..20ff2dfaea 100644
--- a/services/network/network_sandbox_hook_linux.h
+++ b/services/network/network_sandbox_hook_linux.h
@@ -6,7 +6,7 @@
 #define SERVICES_NETWORK_NETWORK_SANDBOX_HOOK_LINUX_H_
 
 #include "base/component_export.h"
-#if defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #include "sandbox/policy/sandbox.h"
 #else
 #include "sandbox/policy/linux/sandbox_linux.h"
diff --git a/services/network/public/cpp/BUILD.gn b/services/network/public/cpp/BUILD.gn
index d596593d5f..b24d2405c5 100644
--- a/services/network/public/cpp/BUILD.gn
+++ b/services/network/public/cpp/BUILD.gn
@@ -850,7 +850,7 @@ source_set("tests") {
     "x_frame_options_parser_unittest.cc",
   ]
 
-  if (is_linux) {
+  if ((is_linux) && !is_bsd) {
     sources += [ "network_interface_change_listener_mojom_traits_unittest.cc" ]
   }
 
diff --git a/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_bsd.cc b/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_bsd.cc
index 85dcc45c8e..4534b7343b 100644
--- a/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_bsd.cc
+++ b/services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_bsd.cc
@@ -14,7 +14,7 @@
 
 #include <vector>
 
-#if BUILDFLAG(IS_OPENBSD)
+#if BUILDFLAG(IS_OPENBSD) || BUILDFLAG(IS_NETBSD)
 #define vm_rssize info.p_vm_rssize
 #elif BUILDFLAG(IS_FREEBSD)
 #include <sys/user.h>
@@ -31,13 +31,21 @@ bool OSMetrics::FillOSMemoryDump(base::ProcessId pid,
                               ? base::Process::Current()
                               : base::Process::Open(pid);
   const size_t kPageSize = base::GetPageSize();
+#if BUILDFLAG(IS_NETBSD)
+  struct kinfo_proc2 info;
+  size_t length = sizeof(struct kinfo_proc2);
+#else
   struct kinfo_proc info;
   size_t length = sizeof(struct kinfo_proc);
+#endif
 #if BUILDFLAG(IS_OPENBSD)
   int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, process.Handle(),
                 static_cast<int>(length), 1 };
 #elif BUILDFLAG(IS_FREEBSD)
   int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, process.Handle() };
+#elif BUILDFLAG(IS_NETBSD)
+  int mib[] = { CTL_KERN, KERN_PROC2, KERN_PROC_PID, process.Handle(),
+                sizeof(struct kinfo_proc2), 1 };
 #endif
 
   if (sysctl(mib, std::size(mib), &info, &length, NULL, 0) < 0)
diff --git a/third_party/abseil-cpp/absl/base/config.h b/third_party/abseil-cpp/absl/base/config.h
index 1f415501c6..f94d7da503 100644
--- a/third_party/abseil-cpp/absl/base/config.h
+++ b/third_party/abseil-cpp/absl/base/config.h
@@ -412,7 +412,8 @@ static_assert(ABSL_INTERNAL_INLINE_NAMESPACE_STR[0] != 'h' ||
 #ifdef ABSL_HAVE_SCHED_YIELD
 #error ABSL_HAVE_SCHED_YIELD cannot be directly set
 #elif defined(__linux__) || defined(__ros__) || defined(__native_client__) || \
-    defined(__VXWORKS__) || defined(__OpenBSD__) || defined(__FreeBSD__)
+    defined(__VXWORKS__) || defined(__OpenBSD__) || defined(__FreeBSD__) || \
+    defined(__NetBSD__)
 #define ABSL_HAVE_SCHED_YIELD 1
 #endif
 
@@ -428,7 +429,7 @@ static_assert(ABSL_INTERNAL_INLINE_NAMESPACE_STR[0] != 'h' ||
 #ifdef ABSL_HAVE_SEMAPHORE_H
 #error ABSL_HAVE_SEMAPHORE_H cannot be directly set
 #elif defined(__linux__) || defined(__ros__) || defined(__VXWORKS__) || \
-    defined(__OpenBSD__) || defined(__FreeBSD__)
+    defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #define ABSL_HAVE_SEMAPHORE_H 1
 #endif
 
diff --git a/third_party/abseil-cpp/absl/base/internal/raw_logging.cc b/third_party/abseil-cpp/absl/base/internal/raw_logging.cc
index 8537f3ec52..c47fdb4545 100644
--- a/third_party/abseil-cpp/absl/base/internal/raw_logging.cc
+++ b/third_party/abseil-cpp/absl/base/internal/raw_logging.cc
@@ -43,7 +43,7 @@
 // this, consider moving both to config.h instead.
 #if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) ||     \
     defined(__hexagon__) || defined(__Fuchsia__) || defined(__OpenBSD__) || \
-    defined(__EMSCRIPTEN__) || defined(__ASYLO__)
+    defined(__EMSCRIPTEN__) || defined(__ASYLO__) || defined(__NetBSD__)
 
 #include <unistd.h>
 
diff --git a/third_party/abseil-cpp/absl/base/internal/sysinfo.cc b/third_party/abseil-cpp/absl/base/internal/sysinfo.cc
index f5379da834..35ed8c1807 100644
--- a/third_party/abseil-cpp/absl/base/internal/sysinfo.cc
+++ b/third_party/abseil-cpp/absl/base/internal/sysinfo.cc
@@ -198,7 +198,7 @@ static double GetNominalCPUFrequency() {
 
 #else
 
-#if !defined(__OpenBSD__) && !defined(__FreeBSD__)
+#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__NetBSD__)
 // Helper function for reading a long from a file. Returns true if successful
 // and the memory location pointed to by value is set to the value read.
 static bool ReadLongFromFile(const char *file, long *value) {
@@ -331,7 +331,7 @@ static double GetNominalCPUFrequency() {
   // a new mode (turbo mode). Essentially, those frequencies cannot
   // always be relied upon. The same reasons apply to /proc/cpuinfo as
   // well.
-#if !defined(__OpenBSD__) && !defined(__FreeBSD__) // pledge violation
+#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__NetBSD__) // pledge violation
   if (ReadLongFromFile("/sys/devices/system/cpu/cpu0/tsc_freq_khz", &freq)) {
     return freq * 1e3;  // Value is kHz.
   }
@@ -354,7 +354,7 @@ static double GetNominalCPUFrequency() {
   // If CPU scaling is in effect, we want to use the *maximum*
   // frequency, not whatever CPU speed some random processor happens
   // to be using now.
-#if !defined(__OpenBSD__) && !defined(__FreeBSD__) // pledge violation
+#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__NetBSD__) // pledge violation
   if (ReadLongFromFile("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq",
                        &freq)) {
     return freq * 1e3;  // Value is kHz.
diff --git a/third_party/abseil-cpp/absl/debugging/internal/elf_mem_image.h b/third_party/abseil-cpp/absl/debugging/internal/elf_mem_image.h
index becef794d2..e0c7784491 100644
--- a/third_party/abseil-cpp/absl/debugging/internal/elf_mem_image.h
+++ b/third_party/abseil-cpp/absl/debugging/internal/elf_mem_image.h
@@ -35,7 +35,7 @@
 #if defined(__ELF__) && !defined(__OpenBSD__) && !defined(__QNX__) &&    \
     !defined(__asmjs__) && !defined(__wasm__) && !defined(__HAIKU__) &&  \
     !defined(__sun) && !defined(__VXWORKS__) && !defined(__hexagon__) && \
-    !defined(__XTENSA__) && !defined(__FreeBSD__)
+    !defined(__XTENSA__) && !defined(__FreeBSD__) && !defined(__NetBSD__)
 #define ABSL_HAVE_ELF_MEM_IMAGE 1
 #endif
 
diff --git a/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_format.cc b/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_format.cc
index f739e026e3..f2ddab3f82 100644
--- a/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_format.cc
+++ b/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_format.cc
@@ -19,7 +19,8 @@
 #endif
 
 #if defined(HAS_STRPTIME) && HAS_STRPTIME
-#if !defined(_XOPEN_SOURCE) && !defined(__FreeBSD__) && !defined(__OpenBSD__)
+#if !defined(_XOPEN_SOURCE) && !defined(__FreeBSD__) && !defined(__OpenBSD__) && \
+    !defined(__NetBSD__)
 #define _XOPEN_SOURCE 500  // Exposes definitions for SUSv2 (UNIX 98).
 #endif
 #endif
diff --git a/third_party/afl/src/afl-fuzz.c b/third_party/afl/src/afl-fuzz.c
index a787f9a685..30f0d59f73 100644
--- a/third_party/afl/src/afl-fuzz.c
+++ b/third_party/afl/src/afl-fuzz.c
@@ -58,7 +58,8 @@
 #include <sys/ioctl.h>
 #include <sys/file.h>
 
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__) || \
+    defined (__NetBSD__)
 #  include <sys/sysctl.h>
 #endif /* __APPLE__ || __FreeBSD__ || __OpenBSD__ */
 
@@ -3531,7 +3532,8 @@ static double get_runnable_processes(void) {
 
   static double res;
 
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__) || \
+    defined (__NetBSD__)
 
   /* I don't see any portable sysctl or so that would quickly give us the
      number of runnable processes; the 1-minute load average can be a
@@ -7347,7 +7349,8 @@ static void get_core_count(void) {
 
   u32 cur_runnable = 0;
 
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__) || \
+    defined (__NetBSD__)
 
   size_t s = sizeof(cpu_core_count);
 
@@ -7392,7 +7395,8 @@ static void get_core_count(void) {
 
     cur_runnable = (u32)get_runnable_processes();
 
-#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__) || \
+    defined (__NetBSD__)
 
     /* Add ourselves, since the 1-minute average doesn't include that yet. */
 
diff --git a/third_party/angle/src/common/platform.h b/third_party/angle/src/common/platform.h
index c0d7eb1845..630a92ad54 100644
--- a/third_party/angle/src/common/platform.h
+++ b/third_party/angle/src/common/platform.h
@@ -27,12 +27,15 @@
 #    define ANGLE_PLATFORM_OPENBSD 1
 #    define ANGLE_PLATFORM_POSIX 1
 #    define ANGLE_PLATFORM_BSD 1
+#elif defined(__NetBSD__)
+#    define ANGLE_PLATFORM_NETBSD 1
+#    define ANGLE_PLATFORM_POSIX 1
+#    define ANGLE_PLATFORM_BSD 1
 #elif defined(__FreeBSD__)
 #    define ANGLE_PLATFORM_FREEBSD 1
 #    define ANGLE_PLATFORM_POSIX 1
 #    define ANGLE_PLATFORM_BSD 1
-#elif defined(__NetBSD__) ||              \
-    defined(__DragonFly__) || defined(__sun) || defined(__GLIBC__) || defined(__GNU__) || \
+#elif defined(__DragonFly__) || defined(__sun) || defined(__GLIBC__) || defined(__GNU__) || \
     defined(__QNX__) || defined(__Fuchsia__) || defined(__HAIKU__)
 #    define ANGLE_PLATFORM_POSIX 1
 #else
diff --git a/third_party/angle/src/common/system_utils_linux.cpp b/third_party/angle/src/common/system_utils_linux.cpp
index a272cb3c54..4f69c7f39c 100644
--- a/third_party/angle/src/common/system_utils_linux.cpp
+++ b/third_party/angle/src/common/system_utils_linux.cpp
@@ -21,6 +21,8 @@
 
 #if ANGLE_PLATFORM_OPENBSD
 #include <pthread_np.h>
+#elif ANGLE_PLATFORM_NETBSD
+#include <pthread.h>
 #endif
 
 #include <array>
@@ -71,6 +73,8 @@ void SetCurrentThreadName(const char *name)
     ASSERT(strlen(name) < 16);
 #if ANGLE_PLATFORM_OPENBSD
     pthread_set_name_np(pthread_self(), name);
+#elif ANGLE_PLATFORM_NETBSD
+    pthread_setname_np(pthread_self(), "%s", (void *)name);
 #else
     pthread_setname_np(pthread_self(), name);
 #endif
diff --git a/third_party/angle/src/gpu_info_util/SystemInfo_internal.h b/third_party/angle/src/gpu_info_util/SystemInfo_internal.h
index 8f64a678a6..cb3f966cc0 100644
--- a/third_party/angle/src/gpu_info_util/SystemInfo_internal.h
+++ b/third_party/angle/src/gpu_info_util/SystemInfo_internal.h
@@ -15,7 +15,7 @@
 namespace angle
 {
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 bool CollectMesaCardInfo(std::vector<GPUDeviceInfo> *devices);                
 #if defined(__FreeBSD__)
 bool GetPCIDevicesFreeBSD(std::vector<GPUDeviceInfo> *devices);
diff --git a/third_party/angle/src/gpu_info_util/SystemInfo_linux.cpp b/third_party/angle/src/gpu_info_util/SystemInfo_linux.cpp
index 3593b70adf..90c7e53789 100644
--- a/third_party/angle/src/gpu_info_util/SystemInfo_linux.cpp
+++ b/third_party/angle/src/gpu_info_util/SystemInfo_linux.cpp
@@ -71,7 +71,7 @@ bool GetPCIDevicesWithLibPCI(std::vector<GPUDeviceInfo> *devices)
 
 bool GetSystemInfo(SystemInfo *info)
 {
-#if defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
     if (!CollectMesaCardInfo(&(info->gpus)))
     {
 #if defined(__FreeBSD__)
diff --git a/third_party/angle/src/gpu_info_util/SystemInfo_x11.cpp b/third_party/angle/src/gpu_info_util/SystemInfo_x11.cpp
index 9f028cf086..f1bdca8eba 100644
--- a/third_party/angle/src/gpu_info_util/SystemInfo_x11.cpp
+++ b/third_party/angle/src/gpu_info_util/SystemInfo_x11.cpp
@@ -8,7 +8,7 @@
 
 #include "gpu_info_util/SystemInfo_internal.h"
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #include <GL/glx.h>
 #include <GL/glxext.h>
 #endif
@@ -22,7 +22,7 @@
 #    error SystemInfo_x11.cpp compiled without GPU_INFO_USE_X11
 #endif
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #define GLX_RENDERER_VENDOR_ID_MESA	0x8183
 #define GLX_RENDERER_DEVICE_ID_MESA	0x8184
 #endif
@@ -30,7 +30,7 @@
 namespace angle
 {
 
-#if defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 bool CollectMesaCardInfo(std::vector<GPUDeviceInfo> *devices)
 {
     unsigned int vid[3], did[3];
diff --git a/third_party/blink/renderer/bindings/scripts/bind_gen/style_format.py b/third_party/blink/renderer/bindings/scripts/bind_gen/style_format.py
index cdbf6cb89a..bb75cb06f5 100644
--- a/third_party/blink/renderer/bindings/scripts/bind_gen/style_format.py
+++ b/third_party/blink/renderer/bindings/scripts/bind_gen/style_format.py
@@ -30,7 +30,7 @@ def init(root_src_dir, enable_style_format=True):
 
     # Determine //buildtools/<platform>/ directory
     new_path_platform_suffix = ""
-    if sys.platform.startswith(("linux","openbsd","freebsd")):
+    if sys.platform.startswith(("linux","openbsd","freebsd","netbsd")):
         platform = "linux64"
         exe_suffix = ""
     elif sys.platform.startswith("darwin"):
diff --git a/third_party/blink/renderer/build/scripts/gperf.py b/third_party/blink/renderer/build/scripts/gperf.py
index bc9cc70faa..d909aee519 100644
--- a/third_party/blink/renderer/build/scripts/gperf.py
+++ b/third_party/blink/renderer/build/scripts/gperf.py
@@ -28,27 +28,6 @@ def generate_gperf(gperf_path, gperf_input, gperf_args):
             stdout=subprocess.PIPE,
             universal_newlines=True)
         gperf_output = gperf.communicate(gperf_input)[0]
-        # Massage gperf output to be more palatable for modern compilers.
-        # TODO(thakis): Upstream these to gperf so we don't need massaging.
-        # `register` is deprecated in C++11 and removed in C++17, so remove
-        # it from gperf's output.
-        # https://savannah.gnu.org/bugs/index.php?53028
-        gperf_output = re.sub(r'\bregister ', '', gperf_output)
-        # -Wimplicit-fallthrough needs an explicit fallthrough statement,
-        # so replace gperf 3.1's /*FALLTHROUGH*/ comment with the statement.
-        # https://savannah.gnu.org/bugs/index.php?53029 (fixed in 3.2)
-        if re.search(
-                r'/\* C\+\+ code produced by gperf version 3\.[01](\.\d+)? \*/',
-                gperf_output):
-            gperf_output = gperf_output.replace('/*FALLTHROUGH*/',
-                                                '  [[fallthrough]];')
-        # -Wpointer-to-int-cast warns about casting pointers to smaller ints
-        # Replace {(int)(long)&(foo), bar} with
-        # {static_cast<int>(reinterpret_cast<uintptr_t>(&(foo)), bar}
-        gperf_output = re.sub(
-            r'\(int\)\(long\)(.*?),',
-            r'static_cast<int>(reinterpret_cast<uintptr_t>(\1)),',
-            gperf_output)
         script = 'third_party/blink/renderer/build/scripts/gperf.py'
         return '// Generated by %s\n' % script + gperf_output
     except OSError:
diff --git a/third_party/blink/renderer/build/scripts/run_with_pythonpath.py b/third_party/blink/renderer/build/scripts/run_with_pythonpath.py
index 703e54a7b8..b24d91923d 100755
--- a/third_party/blink/renderer/build/scripts/run_with_pythonpath.py
+++ b/third_party/blink/renderer/build/scripts/run_with_pythonpath.py
@@ -22,7 +22,7 @@ def main():
         existing_pp = (
             os.pathsep + env['PYTHONPATH']) if 'PYTHONPATH' in env else ''
         env['PYTHONPATH'] = os.pathsep.join(python_paths) + existing_pp
-    env['LD_LIBRARY_PATH'] = "${WRKSRC}/out/Release"
+    env['LD_LIBRARY_PATH'] = "@WRKSRC@/out/Release"
     sys.exit(subprocess.call([sys.executable] + args, env=env))
 
 
diff --git a/third_party/blink/renderer/platform/runtime_enabled_features.json5 b/third_party/blink/renderer/platform/runtime_enabled_features.json5
index d2774893f3..778c442b52 100644
--- a/third_party/blink/renderer/platform/runtime_enabled_features.json5
+++ b/third_party/blink/renderer/platform/runtime_enabled_features.json5
@@ -348,7 +348,7 @@
         "default": "",
       },
       origin_trial_feature_name: "AIPromptAPIMultimodalInput",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       origin_trial_allows_third_party: true,
       implied_by: ["AIPromptAPIMultimodalInput"],
     },
@@ -378,7 +378,7 @@
         "default": "",
       },
       origin_trial_feature_name: "AIPromptAPIMultimodalInput",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       origin_trial_allows_third_party: true,
       base_feature_status: "enabled",
       copied_from_base_feature_if: "overridden",
@@ -399,7 +399,7 @@
         "default": "",
       },
       origin_trial_feature_name: "AIProofreaderAPI",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       origin_trial_allows_third_party: true,
       base_feature_status: "enabled",
       copied_from_base_feature_if: "overridden",
@@ -414,7 +414,7 @@
         "default": "",
       },
       origin_trial_feature_name: "AIRewriterAPI",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       origin_trial_allows_third_party: true,
       base_feature_status: "enabled",
       copied_from_base_feature_if: "overridden",
@@ -447,7 +447,7 @@
         "default": "",
       },
       origin_trial_feature_name: "AIWriterAPI",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       origin_trial_allows_third_party: true,
       base_feature_status: "enabled",
       copied_from_base_feature_if: "overridden",
@@ -576,7 +576,7 @@
       name: "AppTitle",
       status: "experimental",
       origin_trial_feature_name: "AppTitle",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       base_feature: "WebAppEnableAppTitle",
     },
     {
@@ -1257,7 +1257,7 @@
       name: "CSPHashesV1",
       base_feature: "none",
       origin_trial_feature_name: "CSPExtendedScriptSrcHashes",
-      origin_trial_os: ["win", "linux", "mac", "android", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "linux", "mac", "android", "chromeos", "openbsd", "freebsd", "netbsd"],
       status: "experimental",
       public: true,
     },
@@ -1838,7 +1838,7 @@
     {
       name: "DeviceBoundSessionCredentials",
       origin_trial_feature_name: "DeviceBoundSessionCredentials",
-      origin_trial_os: ["win", "linux", "mac", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "linux", "mac", "openbsd", "freebsd", "netbsd"],
       status: "experimental",
       // Killswitch is net::features::kDeviceBoundSessions
       base_feature: "none",
@@ -1846,7 +1846,7 @@
     {
       name: "DeviceBoundSessionCredentials2",
       origin_trial_feature_name: "DeviceBoundSessionCredentials2",
-      origin_trial_os: ["win", "linux", "mac", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "linux", "mac", "openbsd", "freebsd", "netbsd"],
       status: "experimental",
       // Killswitch is net::features::kDeviceBoundSessions
       base_feature: "none",
@@ -1982,7 +1982,7 @@
       name: "DocumentIsolationPolicy",
       status: "experimental",
       origin_trial_feature_name: "DocumentIsolationPolicy",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       base_feature: "none",
     },
     {
@@ -2254,7 +2254,7 @@
       base_feature: "none",
       public: true,
       origin_trial_feature_name: "FedCmMultipleIdentityProviders",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       origin_trial_allows_third_party: true,
     },
     {
@@ -3761,7 +3761,7 @@
       // Tracking bug for the implementation: https://crbug.com/1462930
       name: "PermissionElement",
       origin_trial_feature_name: "PermissionElement",
-      origin_trial_os: ["win", "mac", "linux", "fuchsia", "chromeos", "android", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "fuchsia", "chromeos", "android", "openbsd", "freebsd", "netbsd"],
       status: "experimental",
       public: true,
       base_feature_status: "enabled",
@@ -5299,7 +5299,7 @@
       name: "UnrestrictedSharedArrayBuffer",
       base_feature: "none",
       origin_trial_feature_name: "UnrestrictedSharedArrayBuffer",
-      origin_trial_os: ["win", "mac", "linux", "fuchsia", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "fuchsia", "chromeos", "openbsd", "freebsd", "netbsd"],
     },
     // Enables using policy-controlled feature "usb-unrestricted" to allow
     // isolated context to access protected USB interface classes and to
@@ -5481,7 +5481,7 @@
       name: "WebAppInstallation",
       status: {"Android": "", "default": "test"},
       origin_trial_feature_name: "WebAppInstallation",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       base_feature_status: "enabled",
       copied_from_base_feature_if: "overridden",
     },
@@ -5493,7 +5493,7 @@
     {
       name: "WebAppScopeExtensions",
       origin_trial_feature_name: "WebAppScopeExtensions",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       status: "experimental",
       base_feature: "none",
     },
@@ -5601,7 +5601,7 @@
     {
       name: "WebAuthenticationImmediateGet",
       origin_trial_feature_name: "WebAuthenticationImmediateGet",
-      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd"],
+      origin_trial_os: ["win", "mac", "linux", "chromeos", "openbsd", "freebsd", "netbsd"],
       base_feature: "none",
       public: true,
     },
diff --git a/third_party/blink/renderer/platform/wtf/stack_util.cc b/third_party/blink/renderer/platform/wtf/stack_util.cc
index b83acfab59..cef856b78f 100644
--- a/third_party/blink/renderer/platform/wtf/stack_util.cc
+++ b/third_party/blink/renderer/platform/wtf/stack_util.cc
@@ -24,8 +24,12 @@ extern "C" void* __libc_stack_end;  // NOLINT
 
 #if BUILDFLAG(IS_BSD)
 #include <sys/signal.h>
+#if BUILDFLAG(IS_NETBSD)
+#include <pthread.h>
+#else
 #include <pthread_np.h>
 #endif
+#endif
 
 namespace blink {
 
@@ -39,7 +43,8 @@ size_t GetUnderestimatedStackSize() {
 // correctly for the main thread.
 
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || \
-    BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_FUCHSIA)
+    BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_FUCHSIA) || \
+    BUILDFLAG(IS_NETBSD)
   // pthread_getattr_np() can fail if the thread is not invoked by
   // pthread_create() (e.g., the main thread of blink_unittests).
   // If so, a conservative size estimate is returned.
@@ -60,7 +65,7 @@ size_t GetUnderestimatedStackSize() {
     pthread_attr_destroy(&attr);
     return size;
   }
-#if BUILDFLAG(IS_FREEBSD)
+#if BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
   pthread_attr_destroy(&attr);
 #endif
 
@@ -114,7 +119,7 @@ thread_local void* thread_stack_start = nullptr;
 
 void* GetStackStartImpl() {
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID) || \
-    BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_FUCHSIA)
+    BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_FUCHSIA) || BUILDFLAG(IS_NETBSD)
   pthread_attr_t attr;
   int error;
 #if BUILDFLAG(IS_FREEBSD)
@@ -131,7 +136,7 @@ void* GetStackStartImpl() {
     pthread_attr_destroy(&attr);
     return UNSAFE_TODO(reinterpret_cast<uint8_t*>(base) + size);
   }
-#if BUILDFLAG(IS_FREEBSD)
+#if BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
   pthread_attr_destroy(&attr);
 #endif
 #if defined(__GLIBC__)
diff --git a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
index 420fe059fd..742616f562 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
@@ -163,6 +163,8 @@ std::string MinidumpMiscInfoDebugBuildString() {
   static constexpr char kOS[] = "openbsd";
 #elif defined(OS_FREEBSD)
   static constexpr char kOS[] = "freebsd";
+#elif defined(OS_NETBSD)
+  static constexpr char kOS[] = "netbsd";
 #else
 #error define kOS for this operating system
 #endif
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context.h b/third_party/crashpad/crashpad/util/misc/capture_context.h
index 18afb80053..9af9d03f7c 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context.h
+++ b/third_party/crashpad/crashpad/util/misc/capture_context.h
@@ -22,7 +22,7 @@
 #elif BUILDFLAG(IS_WIN)
 #include <windows.h>
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID) || \
-      BUILDFLAG(IS_FREEBSD)
+      BUILDFLAG(IS_FREEBSD) || BUILDFLAG(IS_NETBSD)
 #include <ucontext.h>
 #elif BUILDFLAG(IS_OPENBSD)
 #include <sys/signal.h>
diff --git a/third_party/dawn/include/dawn/native/VulkanBackend.h b/third_party/dawn/include/dawn/native/VulkanBackend.h
index 3221ad2e37..8b987ab197 100644
--- a/third_party/dawn/include/dawn/native/VulkanBackend.h
+++ b/third_party/dawn/include/dawn/native/VulkanBackend.h
@@ -83,7 +83,8 @@ struct ExternalImageExportInfoVk : ExternalImageExportInfo {
 };
 
 // Can't use DAWN_PLATFORM_IS(LINUX) since header included in both Dawn and Chrome
-#if defined(__linux__) || defined(__Fuchsia__) || defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__linux__) || defined(__Fuchsia__) || defined(__OpenBSD__) || defined(__FreeBSD__) || \
+    defined(__NetBSD__)
 
 // Common properties of external images represented by FDs. On successful import the file
 // descriptor's ownership is transferred to the Dawn implementation and they shouldn't be
diff --git a/third_party/dawn/src/dawn/common/Platform.h b/third_party/dawn/src/dawn/common/Platform.h
index cbc5c7b8b5..2d263ed95d 100644
--- a/third_party/dawn/src/dawn/common/Platform.h
+++ b/third_party/dawn/src/dawn/common/Platform.h
@@ -60,7 +60,7 @@
 #error "Unsupported Windows platform."
 #endif
 
-#elif defined(__OpenBSD__) || defined(__FreeBSD__)
+#elif defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #define DAWN_PLATFORM_IS_LINUX 1
 #define DAWN_PLATFORM_IS_BSD 1
 #define DAWN_PLATFORM_IS_POSIX 1
diff --git a/third_party/ffmpeg/configure b/third_party/ffmpeg/configure
index b95975bd3c..ffa2c027a9 100755
--- a/third_party/ffmpeg/configure
+++ b/third_party/ffmpeg/configure
@@ -6972,8 +6972,8 @@ if ! disabled pthreads && ! enabled w32threads && ! enabled os2threads; then
         if enabled pthread_np_h; then
             hdrs="$hdrs pthread_np.h"
         fi
-        check_lib pthread_set_name_np pthread_np.h pthread_set_name_np -lpthread
-        check_lib pthread_setname_np pthread_np.h pthread_setname_np -lpthread
+        check_lib pthread_set_name_np "$hdrs" pthread_set_name_np -lpthread
+        check_lib pthread_setname_np "$hdrs" pthread_setname_np -lpthread
     fi
 fi
 
diff --git a/third_party/ffmpeg/libavutil/random_seed.c b/third_party/ffmpeg/libavutil/random_seed.c
index dbe55d59f7..7553f29e79 100644
--- a/third_party/ffmpeg/libavutil/random_seed.c
+++ b/third_party/ffmpeg/libavutil/random_seed.c
@@ -20,6 +20,10 @@
 
 #include "config.h"
 
+#if defined(__NetBSD__)
+#define _NETBSD_SOURCE 1
+#endif
+
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
diff --git a/third_party/fontconfig/include/meson-config.h b/third_party/fontconfig/include/meson-config.h
index e94772e170..11219de39c 100644
--- a/third_party/fontconfig/include/meson-config.h
+++ b/third_party/fontconfig/include/meson-config.h
@@ -17,7 +17,7 @@
 
 #define FC_CACHEDIR "/var/cache/fontconfig"
 
-#define FC_DEFAULT_FONTS "\t<dir>/usr/X11R6/lib/X11/fonts</dir>\n"
+#define FC_DEFAULT_FONTS "\t<dir>@X11BASE@/lib/X11/fonts</dir>\n"
 
 #define FC_FONTPATH ""
 
diff --git a/third_party/libc++/src/include/__locale_dir/locale_base_api.h b/third_party/libc++/src/include/__locale_dir/locale_base_api.h
index 9f3ce02a3a..6c512acb17 100644
--- a/third_party/libc++/src/include/__locale_dir/locale_base_api.h
+++ b/third_party/libc++/src/include/__locale_dir/locale_base_api.h
@@ -113,7 +113,7 @@
 
 #  if defined(__APPLE__)
 #    include <__locale_dir/support/apple.h>
-#  elif defined(__FreeBSD__)
+#  elif defined(__FreeBSD__) || defined(__NetBSD__)
 #    include <__locale_dir/support/freebsd.h>
 #  elif defined(_LIBCPP_MSVCRT_LIKE)
 #    include <__locale_dir/support/windows.h>
diff --git a/third_party/libc++/src/include/__locale_dir/support/bsd_like.h b/third_party/libc++/src/include/__locale_dir/support/bsd_like.h
index ac40292470..82492de9e0 100644
--- a/third_party/libc++/src/include/__locale_dir/support/bsd_like.h
+++ b/third_party/libc++/src/include/__locale_dir/support/bsd_like.h
@@ -24,7 +24,11 @@
 #  include <wctype.h>
 #endif
 
+#if defined(__NetBSD__)
+#include <locale.h>
+#else
 #include <xlocale.h>
+#endif
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #  pragma GCC system_header
diff --git a/third_party/libc++/src/src/chrono.cpp b/third_party/libc++/src/src/chrono.cpp
index 2c747c263e..e754ac5016 100644
--- a/third_party/libc++/src/src/chrono.cpp
+++ b/third_party/libc++/src/src/chrono.cpp
@@ -38,7 +38,7 @@
 // OpenBSD and GPU do not have a fully conformant suite of POSIX timers, but
 // it does have clock_gettime and CLOCK_MONOTONIC which is all we need.
 #if defined(__APPLE__) || defined(__gnu_hurd__) || defined(__OpenBSD__) || defined(__AMDGPU__) ||                      \
-    defined(__NVPTX__) || (defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0) || defined(__FreeBSD__)
+    defined(__NVPTX__) || (defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0) || defined(__FreeBSD__) || defined(__NetBSD__)
 #  define _LIBCPP_HAS_CLOCK_GETTIME
 #endif
 
diff --git a/third_party/libc++/src/src/filesystem/filesystem_clock.cpp b/third_party/libc++/src/src/filesystem/filesystem_clock.cpp
index 8bfcdd8e54..1f47f4a2dc 100644
--- a/third_party/libc++/src/src/filesystem/filesystem_clock.cpp
+++ b/third_party/libc++/src/src/filesystem/filesystem_clock.cpp
@@ -37,7 +37,7 @@
 #endif
 
 #if defined(__APPLE__) || defined(__gnu_hurd__) || defined(__AMDGPU__) || defined(__NVPTX__) ||                        \
-    (defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0) || defined(__OpenBSD__) || defined(__FreeBSD__)
+    (defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #  define _LIBCPP_HAS_CLOCK_GETTIME
 #endif
 
diff --git a/third_party/libc++abi/src/src/cxa_guard_impl.h b/third_party/libc++abi/src/src/cxa_guard_impl.h
index 191a589176..89c76a34dc 100644
--- a/third_party/libc++abi/src/src/cxa_guard_impl.h
+++ b/third_party/libc++abi/src/src/cxa_guard_impl.h
@@ -425,6 +425,17 @@ void PlatformFutexWake(int* addr) {
   __tsan_release(addr);
   futex(reinterpret_cast<volatile uint32_t*>(addr), WAKE, INT_MAX, NULL, NULL);
 }
+/*#elif defined(__NetBSD__)
+void PlatformFutexWait(int* addr, int expect) {
+  constexpr int WAIT = 0;
+  syscall(SYS___futex, addr, WAIT, expect, NULL, NULL, 0, 0);
+  __tsan_acquire(addr);
+}
+void PlatformFutexWake(int* addr) {
+  constexpr int WAKE = 1;
+  __tsan_release(addr);
+  syscall(SYS___futex, addr, WAKE, INT_MAX, NULL, NULL, 0, 0);
+}*/
 #elif defined(SYS_futex)
 void PlatformFutexWait(int* addr, int expect) {
   constexpr int WAIT = 0;
diff --git a/third_party/libdrm/src/xf86drmMode.c b/third_party/libdrm/src/xf86drmMode.c
index a4873a0fa0..258259a94d 100644
--- a/third_party/libdrm/src/xf86drmMode.c
+++ b/third_party/libdrm/src/xf86drmMode.c
@@ -976,7 +976,7 @@ drm_public int drmCheckModesettingSupported(const char *busid)
 	}
 #elif defined(__DragonFly__)
 	return 0;
-#elif defined(__OpenBSD__)
+#elif defined(__OpenBSD__) || defined(__NetBSD__)
 	int	fd;
 	struct drm_mode_card_res res;
 	drmModeResPtr r = 0;
@@ -1129,7 +1129,11 @@ drm_public int drmModePageFlipTarget(int fd, uint32_t crtc_id, uint32_t fb_id,
 
 drm_public int drmModeSetPlane(int fd, uint32_t plane_id, uint32_t crtc_id,
 		    uint32_t fb_id, uint32_t flags,
+#if defined(__NetBSD__)
+			uint32_t crtc_x, uint32_t crtc_y,
+#else
 		    int32_t crtc_x, int32_t crtc_y,
+#endif
 		    uint32_t crtc_w, uint32_t crtc_h,
 		    uint32_t src_x, uint32_t src_y,
 		    uint32_t src_w, uint32_t src_h)
diff --git a/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/memory/singleton.h b/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/memory/singleton.h
index f01375cc9d..1f85287d46 100644
--- a/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/memory/singleton.h
+++ b/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/memory/singleton.h
@@ -22,7 +22,8 @@
 #elif (__cplusplus >= 201103L) && defined(I18N_PHONENUMBERS_USE_STDMUTEX)
 // C++11 Lock implementation based on std::mutex.
 #include "phonenumbers/base/memory/singleton_stdmutex.h"
-#elif defined(__linux__) || defined(__APPLE__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(I18N_PHONENUMBERS_HAVE_POSIX_THREAD)
+#elif defined(__linux__) || defined(__APPLE__) || defined(__OpenBSD__) || defined(__FreeBSD__) || \
+    defined(__NetBSD__) || defined(I18N_PHONENUMBERS_HAVE_POSIX_THREAD)
 #include "phonenumbers/base/memory/singleton_posix.h"
 #elif defined(WIN32)
 #include "phonenumbers/base/memory/singleton_win32.h"
diff --git a/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/synchronization/lock.h b/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/synchronization/lock.h
index fa7f9d8c37..30d53c3de2 100644
--- a/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/synchronization/lock.h
+++ b/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/synchronization/lock.h
@@ -22,7 +22,8 @@
 #elif (__cplusplus >= 201103L) && defined(I18N_PHONENUMBERS_USE_STDMUTEX)
 // C++11 Lock implementation based on std::mutex.
 #include "phonenumbers/base/synchronization/lock_stdmutex.h"
-#elif defined(__linux__) || defined(__APPLE__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(I18N_PHONENUMBERS_HAVE_POSIX_THREAD)
+#elif defined(__linux__) || defined(__APPLE__) || defined(__OpenBSD__) || defined(__FreeBSD__) || \
+  defined(__NetBSD__) || defined(I18N_PHONENUMBERS_HAVE_POSIX_THREAD)
 #include "phonenumbers/base/synchronization/lock_posix.h"
 #elif defined(WIN32)
 #include "phonenumbers/base/synchronization/lock_win32.h"
diff --git a/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/thread_checker.h b/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/thread_checker.h
index ba5b99435d..848ae59278 100644
--- a/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/thread_checker.h
+++ b/third_party/libphonenumber/dist/cpp/src/phonenumbers/base/thread_checker.h
@@ -23,7 +23,7 @@
 // user of the library know that it can't be used in a thread-safe manner when
 // it is not depending on Boost.
 #if !defined(__linux__) && !defined(__APPLE__) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(I18N_PHONENUMBERS_HAVE_POSIX_THREAD) && \
-    !defined(I18N_PHONENUMBERS_NO_THREAD_SAFETY) && \
+    !defined(__NetBSD__) && !defined(I18N_PHONENUMBERS_NO_THREAD_SAFETY) && \
 	!((__cplusplus >= 201103L) && defined(I18N_PHONENUMBERS_USE_STDMUTEX)) && \
 	!defined(WIN32)
 #error Building without Boost, please provide \
@@ -33,7 +33,8 @@
 #endif
 
 #if !defined(NDEBUG) && !defined(I18N_PHONENUMBERS_USE_BOOST) && \
-    (defined(__linux__) || defined(__APPLE__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(I18N_PHONENUMBERS_HAVE_POSIX_THREAD))
+    (defined(__linux__) || defined(__APPLE__) || defined(__OpenBSD__) || defined(__FreeBSD__) || \
+    defined(__NetBSD__) || defined(I18N_PHONENUMBERS_HAVE_POSIX_THREAD))
 
 #include <pthread.h>
 
diff --git a/third_party/node/node.py b/third_party/node/node.py
index a7912ad390..3398eb3714 100755
--- a/third_party/node/node.py
+++ b/third_party/node/node.py
@@ -22,6 +22,7 @@ def GetBinaryPath():
     'Linux': ('linux', 'node-linux-x64', 'bin', 'node'),
     'OpenBSD': ('openbsd', 'node-openbsd', 'bin', 'node'),
     'FreeBSD': ('freebsd', 'node-freebsd', 'bin', 'node'),
+    'NetBSD': ('netbsd', 'node-netbsd', 'bin', 'node'),
     'Windows': ('win', 'node.exe'),
   }[platform.system()])
 
diff --git a/third_party/pdfium/core/fxge/linux/fx_linux_impl.cpp b/third_party/pdfium/core/fxge/linux/fx_linux_impl.cpp
index 9765a67c53..15aa9d04c4 100644
--- a/third_party/pdfium/core/fxge/linux/fx_linux_impl.cpp
+++ b/third_party/pdfium/core/fxge/linux/fx_linux_impl.cpp
@@ -179,9 +179,9 @@ class CLinuxPlatform : public CFX_GEModule::PlatformIface {
   std::unique_ptr<SystemFontInfoIface> CreateDefaultSystemFontInfo() override {
     auto pInfo = std::make_unique<CFX_LinuxFontInfo>();
     if (!pInfo->ParseFontCfg(CFX_GEModule::Get()->GetUserFontPaths())) {
-      pInfo->AddPath("/usr/X11R6/lib/X11/fonts/Type1");
-      pInfo->AddPath("/usr/X11R6/lib/X11/fonts/TTF");
-      pInfo->AddPath("/usr/local/share/fonts");
+      pInfo->AddPath("@X11BASE@/lib/X11/fonts/Type1");
+      pInfo->AddPath("@X11BASE@/lib/X11/fonts/TTF");
+      pInfo->AddPath("@PREFIX@/share/fonts");
     }
     return pInfo;
   }
diff --git a/third_party/perfetto/include/perfetto/base/build_config.h b/third_party/perfetto/include/perfetto/base/build_config.h
index aabcc8f159..00fc80f003 100644
--- a/third_party/perfetto/include/perfetto/base/build_config.h
+++ b/third_party/perfetto/include/perfetto/base/build_config.h
@@ -64,7 +64,7 @@
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_IOS() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_APPLE_TVOS() 0
 #endif
-#elif defined(__linux__) || defined(__OpenBSD__) || defined(__FreeBSD__)
+#elif defined(__linux__) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_BSD() 1
diff --git a/third_party/perfetto/include/perfetto/base/time.h b/third_party/perfetto/include/perfetto/base/time.h
index ba7537af40..35b15d94c7 100644
--- a/third_party/perfetto/include/perfetto/base/time.h
+++ b/third_party/perfetto/include/perfetto/base/time.h
@@ -228,7 +228,7 @@ inline TimeNanos GetTimeInternalNs(clockid_t clk_id) {
 // Return ns from boot. Conversely to GetWallTimeNs, this clock counts also time
 // during suspend (when supported).
 inline TimeNanos GetBootTimeNs() {
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__NetBSD__)
   return GetTimeInternalNs(kWallTimeClockSource);
 #else
   // Determine if CLOCK_BOOTTIME is available on the first call.
@@ -246,7 +246,7 @@ inline TimeNanos GetWallTimeNs() {
 }
 
 inline TimeNanos GetWallTimeRawNs() {
-#if defined(__OpenBSD__)
+#if defined(__OpenBSD__) || defined(__NetBSD__)
   return GetTimeInternalNs(CLOCK_MONOTONIC);
 #elif defined(__FreeBSD__)
   return GetTimeInternalNs(CLOCK_MONOTONIC_FAST);
diff --git a/third_party/perfetto/src/base/unix_socket.cc b/third_party/perfetto/src/base/unix_socket.cc
index b3062eddb6..81f4b0b6fd 100644
--- a/third_party/perfetto/src/base/unix_socket.cc
+++ b/third_party/perfetto/src/base/unix_socket.cc
@@ -45,7 +45,7 @@
 #include <unistd.h>
 #endif
 
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE) || defined(__FreeBSD__)
+#if PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE) || defined(__FreeBSD__) || defined(__NetBSD__)
 #include <sys/ucred.h>
 #endif
 
@@ -1031,7 +1031,7 @@ void UnixSocket::ReadPeerCredentialsPosix() {
   int res = getpeereid(fd, &peer_uid_, nullptr);
   PERFETTO_CHECK(res == 0);
   // There is no pid when obtaining peer credentials for QNX
-#elif !defined(__FreeBSD__) && PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
+#elif !defined(__FreeBSD__) && !defined(__NetBSD__) && PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
 #if PERFETTO_BUILDFLAG(PERFETTO_OS_BSD)
   struct sockpeercred user_cred;
@@ -1044,6 +1044,14 @@ void UnixSocket::ReadPeerCredentialsPosix() {
   PERFETTO_CHECK(res == 0);
   peer_uid_ = user_cred.uid;
   peer_pid_ = user_cred.pid;
+#elif defined(__NetBSD__)
+  struct unpcbid user_cred;
+  socklen_t len = sizeof(user_cred);
+  int fd = sock_raw_.fd();
+  int res = getsockopt(fd, 0, LOCAL_PEEREID, &user_cred, &len);
+  PERFETTO_CHECK(res == 0);
+  peer_uid_ = user_cred.unp_euid;
+  peer_pid_ = user_cred.unp_pid;
 #elif PERFETTO_BUILDFLAG(PERFETTO_OS_APPLE)
   struct xucred user_cred;
   socklen_t len = sizeof(user_cred);
diff --git a/third_party/perfetto/src/base/utils.cc b/third_party/perfetto/src/base/utils.cc
index 6d641ea087..7e7d45f8f6 100644
--- a/third_party/perfetto/src/base/utils.cc
+++ b/third_party/perfetto/src/base/utils.cc
@@ -297,7 +297,7 @@ std::string GetCurExecutablePath() {
   self_path = std::string(buf, static_cast<size_t>(size));
 #elif PERFETTO_BUILDFLAG(PERFETTO_OS_BSD)
   char *buf;
-  const char *cpath = "/usr/local/chrome/chrome";
+  const char *cpath = "@PREFIX@/lib/chromium/chrome";
   if ((buf = getenv("CHROME_EXE_PATH")) != NULL)
     self_path = std::string(buf);
   else
diff --git a/third_party/protobuf/proto_library.gni b/third_party/protobuf/proto_library.gni
index 21c324fbbe..676deb20e2 100644
--- a/third_party/protobuf/proto_library.gni
+++ b/third_party/protobuf/proto_library.gni
@@ -268,6 +268,10 @@ if (is_freebsd) {
   _protoc_gen_ts_runtime_deps +=
       [ "//third_party/node/freebsd/node-freebsd/bin/node" ]
 }
+if (is_netbsd) {
+  _protoc_gen_ts_runtime_deps +=
+      [ "//third_party/node/netbsd/node-netbsd/bin/node" ]
+}
 if (!is_bsd && (is_linux || is_chromeos || use_remoteexec)) {
   _protoc_gen_ts_runtime_deps +=
       [ "//third_party/node/linux/node-linux-x64/bin/node" ]
diff --git a/third_party/skia/src/gpu/ganesh/GrAutoLocaleSetter.h b/third_party/skia/src/gpu/ganesh/GrAutoLocaleSetter.h
index 13a2ab37f9..96968f6779 100644
--- a/third_party/skia/src/gpu/ganesh/GrAutoLocaleSetter.h
+++ b/third_party/skia/src/gpu/ganesh/GrAutoLocaleSetter.h
@@ -27,7 +27,7 @@
 #define HAVE_XLOCALE 0
 #endif
 
-#if defined(SK_BUILD_FOR_ANDROID) || defined(__UCLIBC__) || defined(_NEWLIB_VERSION)
+#if defined(SK_BUILD_FOR_ANDROID) || defined(__UCLIBC__) || defined(_NEWLIB_VERSION) || defined(__NetBSD__)
 #define HAVE_LOCALE_T 0
 #else
 #define HAVE_LOCALE_T 1
diff --git a/third_party/skia/src/ports/SkMemory_malloc.cpp b/third_party/skia/src/ports/SkMemory_malloc.cpp
index df1eee3ff9..564e572e23 100644
--- a/third_party/skia/src/ports/SkMemory_malloc.cpp
+++ b/third_party/skia/src/ports/SkMemory_malloc.cpp
@@ -15,7 +15,8 @@
 
 #if defined(SK_BUILD_FOR_MAC) || defined(SK_BUILD_FOR_IOS)
 #include <malloc/malloc.h>
-#elif defined(SK_BUILD_FOR_ANDROID) || defined(SK_BUILD_FOR_UNIX) && !defined(__OpenBSD__)
+#elif defined(SK_BUILD_FOR_ANDROID) || defined(SK_BUILD_FOR_UNIX) && !defined(__OpenBSD__) && \
+    !defined(__NetBSD__)
 #include <malloc.h>
 #elif defined(SK_BUILD_FOR_WIN)
 #include <malloc.h>
@@ -126,7 +127,7 @@ size_t sk_malloc_size(void* addr, size_t size) {
     #elif defined(SK_BUILD_FOR_ANDROID) && __ANDROID_API__ >= 17
         completeSize = malloc_usable_size(addr);
         SkASSERT(completeSize >= size);
-    #elif defined(SK_BUILD_FOR_UNIX) && !defined(__OpenBSD__)
+    #elif defined(SK_BUILD_FOR_UNIX) && !defined(__OpenBSD__) && !defined(__NetBSD__)
         completeSize = malloc_usable_size(addr);
         SkASSERT(completeSize >= size);
     #elif defined(SK_BUILD_FOR_WIN)
diff --git a/third_party/speech-dispatcher/libspeechd_version.h b/third_party/speech-dispatcher/libspeechd_version.h
index c455a1ffa5..4520c3f56f 100644
--- a/third_party/speech-dispatcher/libspeechd_version.h
+++ b/third_party/speech-dispatcher/libspeechd_version.h
@@ -16,7 +16,7 @@
  * You should have received a copy of the GNU Lesser General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
- * $Id: patch-third_party_speech-dispatcher_libspeechd_version_h,v 1.4 2024/03/22 13:10:56 robert Exp $
+ * Id: patch-third_party_speech-dispatcher_libspeechd_version_h,v 1.4 2024/03/22 13:10:56 robert
  */
 
 #ifndef _LIBSPEECHD_VERSION_H
diff --git a/third_party/sqlite/src/amalgamation/sqlite3.c b/third_party/sqlite/src/amalgamation/sqlite3.c
index 8f416f35df..60239c44f8 100644
--- a/third_party/sqlite/src/amalgamation/sqlite3.c
+++ b/third_party/sqlite/src/amalgamation/sqlite3.c
@@ -21097,6 +21097,9 @@ SQLITE_PRIVATE int sqlite3HeapNearlyFull(void);
 ** The alloca() routine never returns NULL.  This will cause code paths
 ** that deal with sqlite3StackAlloc() failures to be unreachable.
 */
+#if defined(__NetBSD__)
+# undef SQLITE_USE_ALLOCA
+#endif
 #ifdef SQLITE_USE_ALLOCA
 # define sqlite3StackAllocRaw(D,N)   alloca(N)
 # define sqlite3StackAllocRawNN(D,N) alloca(N)
diff --git a/third_party/sqlite/src/amalgamation_dev/sqlite3.c b/third_party/sqlite/src/amalgamation_dev/sqlite3.c
index 5ab2e37070..fa7e79af3a 100644
--- a/third_party/sqlite/src/amalgamation_dev/sqlite3.c
+++ b/third_party/sqlite/src/amalgamation_dev/sqlite3.c
@@ -21110,6 +21110,9 @@ SQLITE_PRIVATE int sqlite3HeapNearlyFull(void);
 ** The alloca() routine never returns NULL.  This will cause code paths
 ** that deal with sqlite3StackAlloc() failures to be unreachable.
 */
+#if defined(__NetBSD__)
+# undef SQLITE_USE_ALLOCA
+#endif
 #ifdef SQLITE_USE_ALLOCA
 # define sqlite3StackAllocRaw(D,N)   alloca(N)
 # define sqlite3StackAllocRawNN(D,N) alloca(N)
diff --git a/third_party/swiftshader/src/Reactor/Debug.cpp b/third_party/swiftshader/src/Reactor/Debug.cpp
index 96695d65c7..3fc8049988 100644
--- a/third_party/swiftshader/src/Reactor/Debug.cpp
+++ b/third_party/swiftshader/src/Reactor/Debug.cpp
@@ -46,7 +46,8 @@ namespace {
 
 bool IsUnderDebugger()
 {
-#if defined(PTRACE) && !defined(__APPLE__) && !defined(__MACH__) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
+#if defined(PTRACE) && !defined(__APPLE__) && !defined(__MACH__) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && \
+	!defined(__NetBSD__)
 	static bool checked = false;
 	static bool res = false;
 
diff --git a/third_party/swiftshader/src/System/Configurator.cpp b/third_party/swiftshader/src/System/Configurator.cpp
index 62a9b7eef3..3853d05686 100644
--- a/third_party/swiftshader/src/System/Configurator.cpp
+++ b/third_party/swiftshader/src/System/Configurator.cpp
@@ -38,7 +38,7 @@ namespace sw {
 
 Configurator::Configurator(const std::string &filePath)
 {
-#if defined(__OpenBSD__) || defined(__FreeBSD__)
+#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 	return;
 #endif
 	std::fstream file(filePath, std::ios::in);
diff --git a/third_party/swiftshader/src/System/Linux/MemFd.cpp b/third_party/swiftshader/src/System/Linux/MemFd.cpp
index 7b5a091b18..77eb5a3243 100644
--- a/third_party/swiftshader/src/System/Linux/MemFd.cpp
+++ b/third_party/swiftshader/src/System/Linux/MemFd.cpp
@@ -25,7 +25,7 @@
 #	define MFD_CLOEXEC 0x0001U
 #endif
 
-#if !defined(__OpenBSD__) && !defined(__FreeBSD__)
+#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__NetBSD__)
 #if __aarch64__
 #	define __NR_memfd_create 279
 #elif __arm__
@@ -71,7 +71,7 @@ bool LinuxMemFd::allocate(const char *name, size_t size)
 #else
 	// In the event of no system call this returns -1 with errno set
 	// as ENOSYS.
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) ||  defined(__NetBSD__)
 	fd_ = memfd_create(name, MFD_CLOEXEC);
 #else
 	fd_ = syscall(__NR_memfd_create, name, MFD_CLOEXEC);
diff --git a/third_party/swiftshader/third_party/marl/src/memory.cpp b/third_party/swiftshader/third_party/marl/src/memory.cpp
index abecf15baf..3b8e460c9b 100644
--- a/third_party/swiftshader/third_party/marl/src/memory.cpp
+++ b/third_party/swiftshader/third_party/marl/src/memory.cpp
@@ -19,7 +19,8 @@
 
 #include <cstring>
 
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)
+#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__) || \
+      defined(__NetBSD__)
 #include <sys/mman.h>
 #include <unistd.h>
 namespace {
diff --git a/third_party/swiftshader/third_party/marl/src/thread.cpp b/third_party/swiftshader/third_party/marl/src/thread.cpp
index b87ab0b41b..9609843664 100644
--- a/third_party/swiftshader/third_party/marl/src/thread.cpp
+++ b/third_party/swiftshader/third_party/marl/src/thread.cpp
@@ -46,6 +46,9 @@
 #include <unistd.h>
 #include <thread>
 #endif
+#if defined(__NetBSD__)
+#include <stdarg.h>
+#endif
 
 namespace {
 
@@ -444,6 +447,8 @@ void Thread::setName(const char* fmt, ...) {
   pthread_setname_np(name);
 #elif defined(__FreeBSD__)
   pthread_set_name_np(pthread_self(), name);
+#elif defined(__NetBSD__)
+  pthread_setname_np(pthread_self(), "%s", (void *)name);
 #elif !defined(__Fuchsia__) && !defined(__EMSCRIPTEN__) && !defined(__OpenBSD__) && !defined(__FreeBSD__)
   pthread_setname_np(pthread_self(), name);
 #endif
diff --git a/third_party/test_fonts/fontconfig/generate_fontconfig_caches.cc b/third_party/test_fonts/fontconfig/generate_fontconfig_caches.cc
index 47b5b51412..68d65ed278 100644
--- a/third_party/test_fonts/fontconfig/generate_fontconfig_caches.cc
+++ b/third_party/test_fonts/fontconfig/generate_fontconfig_caches.cc
@@ -28,7 +28,7 @@ int main() {
   // fontconfig cache.
   //     $ echo -n /test_fonts | md5sum
   //     fb5c91b2895aa445d23aebf7f9e2189c  -
-  static const char kCacheKey[] = "fb5c91b2895aa445d23aebf7f9e2189c";
+  static const char kCacheKey[] = "cd4b5bc7-6cfc-41dc-8982-f2db624179ba";
 
   // fontconfig writes the mtime of the test_fonts directory into the cache. It
   // presumably checks this later to ensure that the cache is still up to date.
@@ -56,7 +56,7 @@ int main() {
   FcFini();
 
   // Check existence of intended fontconfig cache file.
-  auto cache = fontconfig_caches + "/" + kCacheKey + "-le64.cache-" + FC_CACHE_VERSION;
+  auto cache = fontconfig_caches + "/" + kCacheKey + "-x86_64.cache-" + FC_CACHE_VERSION;
   bool cache_exists = access(cache.c_str(), F_OK) == 0;
   return !cache_exists;
 }
diff --git a/third_party/vulkan-validation-layers/src/layers/external/vma/vk_mem_alloc.h b/third_party/vulkan-validation-layers/src/layers/external/vma/vk_mem_alloc.h
index eb86c3c3ed..f444ad6e7e 100644
--- a/third_party/vulkan-validation-layers/src/layers/external/vma/vk_mem_alloc.h
+++ b/third_party/vulkan-validation-layers/src/layers/external/vma/vk_mem_alloc.h
@@ -2971,7 +2971,7 @@ static void* vma_aligned_alloc(size_t alignment, size_t size)
 
     return memalign(alignment, size);
 }
-#elif defined(__APPLE__) || defined(__ANDROID__) || (defined(__linux__) && defined(__GLIBCXX__) && !defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)) || defined(__OpenBSD__) || defined(__FreeBSD__)
+#elif defined(__APPLE__) || defined(__ANDROID__) || (defined(__linux__) && defined(__GLIBCXX__) && !defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)) || defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__)
 #include <cstdlib>
 
 #if defined(__APPLE__)
diff --git a/third_party/vulkan-validation-layers/src/layers/vulkan/generated/vk_function_pointers.cpp b/third_party/vulkan-validation-layers/src/layers/vulkan/generated/vk_function_pointers.cpp
index 763bc361bf..29695819c1 100644
--- a/third_party/vulkan-validation-layers/src/layers/vulkan/generated/vk_function_pointers.cpp
+++ b/third_party/vulkan-validation-layers/src/layers/vulkan/generated/vk_function_pointers.cpp
@@ -53,7 +53,8 @@ static void *get_proc_address(dl_handle library, const char *name) {
     assert(name);
     return (void *)GetProcAddress(library, name);
 }
-#elif defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__QNX__) || defined(__GNU__)
+#elif defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__QNX__) || \
+         defined(__GNU__) ||  defined(__NetBSD__)
 
 #include <dlfcn.h>
 
diff --git a/third_party/wayland/BUILD.gn b/third_party/wayland/BUILD.gn
index 19ada87e4f..77370afe1e 100644
--- a/third_party/wayland/BUILD.gn
+++ b/third_party/wayland/BUILD.gn
@@ -25,7 +25,7 @@ if (!use_system_libwayland) {
     ]
 
     if (is_bsd) {
-      include_dirs += [ "/usr/local/include/libepoll-shim" ]
+      include_dirs += [ "@PREFIX@/include/libepoll-shim" ]
       libs = [ "epoll-shim" ]
     }   
 
diff --git a/third_party/widevine/cdm/widevine.gni b/third_party/widevine/cdm/widevine.gni
index d45e09a446..de204df3bc 100644
--- a/third_party/widevine/cdm/widevine.gni
+++ b/third_party/widevine/cdm/widevine.gni
@@ -30,6 +30,7 @@ library_widevine_cdm_available =
     (target_os == "linux" && target_cpu == "x64") ||
     (target_os == "openbsd" && target_cpu == "x64") ||
     (target_os == "freebsd" && target_cpu == "x64") ||
+    (target_os == "netbsd" && target_cpu == "x64") ||
     (target_os == "mac" && (target_cpu == "x64" || target_cpu == "arm64")) ||
     (target_os == "win" &&
      (target_cpu == "x86" || target_cpu == "x64" || target_cpu == "arm64"))
diff --git a/tools/code_cache_generator/BUILD.gn b/tools/code_cache_generator/BUILD.gn
index 88eef351c9..efda6834fa 100644
--- a/tools/code_cache_generator/BUILD.gn
+++ b/tools/code_cache_generator/BUILD.gn
@@ -15,8 +15,34 @@ if (is_android) {
   import("//build/config/android/rules.gni")
 }
 
-executable("code_cache_generator") {
+group("code_cache_generator") {
+    deps = [ ":code_cache_generator_executable" ]
+    if (target_os == "netbsd") {
+      deps+= [ ":run_paxctl_code_cache_generator" ]
+    }
+}
+
+action("run_paxctl_code_cache_generator") {
+  deps = [ ":code_cache_generator_executable" ]
+
+  script = "//v8/tools/run-paxctl.py"
+  stamp = "$target_gen_dir/paxctl_stamp"
+  outputs = [ stamp ]
+
+  sources = []
+  data = []
+
+  args = [
+    rebase_path(stamp, root_build_dir),
+    "/usr/sbin/paxctl", "+m",
+    "./" + rebase_path(get_label_info(":code_cache_generator_executable", "root_out_dir") + "/code_cache_generator",
+    root_build_dir),
+  ]
+}
+
+executable("code_cache_generator_executable") {
   sources = [ "code_cache_generator.cc" ]
+  output_name = "code_cache_generator"
 
   deps = [
     "//gin",
diff --git a/tools/json_schema_compiler/feature_compiler.py b/tools/json_schema_compiler/feature_compiler.py
index 9f7467bcf7..18c1f48dd6 100644
--- a/tools/json_schema_compiler/feature_compiler.py
+++ b/tools/json_schema_compiler/feature_compiler.py
@@ -291,6 +291,7 @@ FEATURE_GRAMMAR = ({
                 'win': 'Feature::WIN_PLATFORM',
                 'openbsd': 'Feature::LINUX_PLATFORM',
                 'freebsd': 'Feature::LINUX_PLATFORM',
+                'netbsd': 'Feature::LINUX_PLATFORM',
             }
         }
     },
diff --git a/tools/protoc_wrapper/protoc_wrapper.py b/tools/protoc_wrapper/protoc_wrapper.py
index 5bf0a5b97a..62bde086df 100755
--- a/tools/protoc_wrapper/protoc_wrapper.py
+++ b/tools/protoc_wrapper/protoc_wrapper.py
@@ -228,8 +228,8 @@ def main(argv):
       protoc_cmd += ["--include_imports"]
 
   nenv = os.environ.copy()
-  nenv["PATH"] = "${WRKOBJDIR}/bin:" + nenv["PATH"]
-  nenv["LD_LIBRARY_PATH"] = "${WRKSRC}/out/Release"
+#  nenv["PATH"] = "${WRKOBJDIR}/bin:" + nenv["PATH"]
+  nenv["LD_LIBRARY_PATH"] = "@WRKSRC@/out/Release"
 
   dependency_file_data = None
   if options.descriptor_set_out and options.descriptor_set_dependency_file:
diff --git a/tools/v8_context_snapshot/BUILD.gn b/tools/v8_context_snapshot/BUILD.gn
index 8a265c5497..d5cfdddb4d 100644
--- a/tools/v8_context_snapshot/BUILD.gn
+++ b/tools/v8_context_snapshot/BUILD.gn
@@ -36,6 +36,24 @@ buildflag_header("buildflags") {
   ]
 }
 
+action("run_paxctl_v8_context_snapshot_generator") {
+  deps = [ ":v8_context_snapshot_generator($v8_snapshot_toolchain)" ]
+
+  script = "//v8/tools/run-paxctl.py"
+  stamp = "$target_gen_dir/paxctl_stamp"
+  outputs = [ stamp ]
+
+  sources = []
+  data = []
+
+  args = [
+    rebase_path(stamp, root_build_dir),
+    "/usr/sbin/paxctl", "+m",
+    "./" + rebase_path(get_label_info(":v8_context_snapshot_generator", "root_out_dir") + "/v8_context_snapshot_generator",
+    root_build_dir),
+  ]
+}
+
 if (use_v8_context_snapshot) {
   action("generate_v8_context_snapshot") {
     script = "//build/gn_run_binary.py"
@@ -63,6 +81,9 @@ if (use_v8_context_snapshot) {
       ":v8_context_snapshot_generator($v8_snapshot_toolchain)",
       "//v8:run_mksnapshot_default",
     ]
+      if (target_os == "netbsd") {
+        deps += [ ":run_paxctl_v8_context_snapshot_generator" ]
+      }
 
     # TODO(sky): figure out why this doesn't work on android cross compile.
     # In the case of compiling for the snapshot `shlib_extension` is ".so"
diff --git a/tools/variations/fieldtrial_to_struct.py b/tools/variations/fieldtrial_to_struct.py
index 6c29521da5..7b83bbaf67 100755
--- a/tools/variations/fieldtrial_to_struct.py
+++ b/tools/variations/fieldtrial_to_struct.py
@@ -43,6 +43,7 @@ _platforms = [
     'windows',
     'openbsd',
     'freebsd',
+    'netbsd',
 ]
 
 _form_factors = [
diff --git a/ui/qt/moc_wrapper.py b/ui/qt/moc_wrapper.py
index ffbe56813c..6e5d2a93c0 100755
--- a/ui/qt/moc_wrapper.py
+++ b/ui/qt/moc_wrapper.py
@@ -20,4 +20,4 @@ args = parser.parse_args()
 if args.path is None:
     subprocess.check_call(["moc", args.input, "-o", args.output])
 else:
-    subprocess.check_call([args.path, args.input, "-o", args.output])
+    subprocess.check_call([args.path + "/moc", args.input, "-o", args.output])
diff --git a/v8/BUILD.gn b/v8/BUILD.gn
index ac1ac6abb5..77f106f4d8 100644
--- a/v8/BUILD.gn
+++ b/v8/BUILD.gn
@@ -992,6 +992,7 @@ external_v8_defines = [
   "V8_TARGET_OS_CHROMEOS",
   "V8_TARGET_OS_OPENBSD",
   "V8_TARGET_OS_FREEBSD",
+  "V8_TARGET_OS_NETBSD",
 ]
 
 enabled_external_v8_defines = [
@@ -1072,6 +1073,9 @@ if (target_os == "android") {
 } else if (target_os == "freebsd") {
   enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
   enabled_external_v8_defines += [ "V8_TARGET_OS_FREEBSD" ]
+} else if (target_os == "netbsd") {
+  enabled_external_v8_defines += [ "V8_HAVE_TARGET_OS" ]
+  enabled_external_v8_defines += [ "V8_TARGET_OS_NETBSD" ]
 }
 
 disabled_external_v8_defines = external_v8_defines - enabled_external_v8_defines
@@ -2484,6 +2488,23 @@ action("generate_bytecode_builtins_list") {
   ]
 }
 
+action("run_paxctl_mksnapshot") {
+    deps = [ ":mksnapshot($v8_snapshot_toolchain)" ]
+
+    script = "tools/run-paxctl.py"
+    stamp = "$target_gen_dir/paxctl_stamp"
+    outputs = [ stamp ]
+
+    sources = []
+    data = []
+
+    args = [
+      rebase_path(stamp, root_build_dir), "/usr/sbin/paxctl", "+m", "./" + rebase_path(get_label_info(":mksnapshot($v8_snapshot_toolchain)",
+                                        "root_out_dir") + "/mksnapshot",
+                         root_build_dir),
+    ]
+}
+
 # Template to generate different V8 snapshots based on different runtime flags.
 # Can be invoked with run_mksnapshot(<name>). The target will resolve to
 # run_mksnapshot_<name>. If <name> is "default", no file suffixes will be used.
@@ -2502,7 +2523,11 @@ template("run_mksnapshot") {
     suffix = "_$name"
   }
   action("run_mksnapshot_" + name) {
-    deps = [ ":mksnapshot($v8_snapshot_toolchain)" ]
+    if (target_os == "netbsd") {
+      deps = [ ":mksnapshot($v8_snapshot_toolchain)", ":run_paxctl_mksnapshot" ]
+    } else {
+      deps = [ ":mksnapshot($v8_snapshot_toolchain)" ]
+    }
     if (v8_verify_deterministic_mksnapshot) {
       # We archive the snapshot executable when verifying snapshot
       # determinism to ease debugging.
@@ -4810,7 +4835,7 @@ v8_header_set("v8_internal_headers") {
       # iOS Xcode simulator builds run on an x64 target. iOS and macOS are both
       # based on Darwin and thus POSIX-compliant to a similar degree.
       if (is_linux || is_chromeos || is_mac || is_ios ||
-          target_os == "freebsd") {
+          target_os == "freebsd" || target_os == "netbsd") {
         sources += [ "src/trap-handler/handler-inside-posix.h" ]
       } else if (is_win) {
         sources += [ "src/trap-handler/handler-inside-win.h" ]
@@ -6225,7 +6250,7 @@ v8_source_set("v8_base_without_compiler") {
       # iOS Xcode simulator builds run on an x64 target. iOS and macOS are both
       # based on Darwin and thus POSIX-compliant to a similar degree.
       if (is_linux || is_chromeos || is_mac || is_ios ||
-          target_os == "freebsd") {
+          target_os == "freebsd" || target_os == "netbsd") {
         sources += [
           "src/trap-handler/handler-inside-posix.cc",
           "src/trap-handler/handler-outside-posix.cc",
@@ -6909,6 +6934,15 @@ v8_component("v8_libbase") {
       "src/base/platform/platform-openbsd.cc",
     ]
     libs = [ "execinfo" ]
+  } else if (is_netbsd) {
+    sources += [
+      "src/base/debug/stack_trace_posix.cc",
+      "src/base/platform/platform-openbsd.cc",
+    ]
+    libs = [
+      "rt",
+      "execinfo",
+    ]
   } else if (is_freebsd) {
     sources += [
       "src/base/debug/stack_trace_posix.cc",
diff --git a/v8/include/v8config.h b/v8/include/v8config.h
index c77e257d22..327d03a436 100644
--- a/v8/include/v8config.h
+++ b/v8/include/v8config.h
@@ -209,6 +209,7 @@ path. Add it with -I<path> to the command line
   && !defined(V8_TARGET_OS_LINUX) \
   && !defined(V8_TARGET_OS_OPENBSD) \
   && !defined(V8_TARGET_OS_FREEBSD) \
+  && !defined(V8_TARGET_OS_NETBSD) \
   && !defined(V8_TARGET_OS_MACOS) \
   && !defined(V8_TARGET_OS_WIN) \
   && !defined(V8_TARGET_OS_CHROMEOS)
@@ -224,6 +225,7 @@ path. Add it with -I<path> to the command line
   || defined(V8_TARGET_OS_LINUX) \
   || defined(V8_TARGET_OS_OPENBSD) \
   || defined(V8_TARGET_OS_FREEBSD) \
+  || defined(V8_TARGET_OS_NETBSD) \
   || defined(V8_TARGET_OS_MACOS) \
   || defined(V8_TARGET_OS_WIN) \
   || defined(V8_TARGET_OS_CHROMEOS)
@@ -261,6 +263,12 @@ path. Add it with -I<path> to the command line
 # define V8_TARGET_OS_BSD
 #endif
 
+#ifdef V8_OS_NETBSD
+# define V8_TARGET_OS_OPENBSD
+# define V8_TARGET_OS_NETBSD
+# define V8_TARGET_OS_BSD
+#endif
+
 #ifdef V8_OS_MACOS
 # define V8_TARGET_OS_MACOS
 #endif
@@ -409,6 +417,7 @@ path. Add it with -I<path> to the command line
      || ((defined(__AARCH64EL__) || defined(_M_ARM64)) /* arm64, but ... */    \
          && !defined(_WIN32)))                         /* not on windows */    \
      && !defined(__OpenBSD__)                          /* not on OpenBSD */    \
+     && !defined(__NetBSD__)                           /* not on NetBSD */     \
      && !defined(COMPONENT_BUILD)                      /* no component build */\
      && __clang_major__ >= 17                          /* clang >= 17 */
 # define V8_HAS_ATTRIBUTE_PRESERVE_MOST (__has_attribute(preserve_most))
diff --git a/v8/src/api/api.cc b/v8/src/api/api.cc
index b8d51609ce..3a81546060 100644
--- a/v8/src/api/api.cc
+++ b/v8/src/api/api.cc
@@ -159,7 +159,7 @@
 #include "src/objects/intl-objects.h"
 #endif  // V8_INTL_SUPPORT
 
-#if V8_OS_LINUX || V8_OS_DARWIN || V8_OS_FREEBSD || V8_OS_OPENBSD
+#if V8_OS_LINUX || V8_OS_DARWIN || V8_OS_FREEBSD || V8_OS_OPENBSD || V8_OS_NETBSD
 #include <signal.h>
 #include <unistd.h>
 
@@ -6273,7 +6273,7 @@ bool v8::V8::Initialize(const int build_config) {
   return true;
 }
 
-#if V8_OS_LINUX || V8_OS_DARWIN || V8_OS_FREEBSD || V8_OS_OPENBSD
+#if V8_OS_LINUX || V8_OS_DARWIN || V8_OS_FREEBSD || V8_OS_OPENBSD|| V8_OS_NETBSD
 bool TryHandleWebAssemblyTrapPosix(int sig_code, siginfo_t* info,
                                    void* context) {
 #if V8_ENABLE_WEBASSEMBLY && V8_TRAP_HANDLER_SUPPORTED
diff --git a/v8/src/base/platform/platform-openbsd.cc b/v8/src/base/platform/platform-openbsd.cc
index 8ade6f9b37..81b2cd86c9 100644
--- a/v8/src/base/platform/platform-openbsd.cc
+++ b/v8/src/base/platform/platform-openbsd.cc
@@ -6,7 +6,9 @@
 // POSIX-compatible parts, the implementation is in platform-posix.cc.
 
 #include <pthread.h>
+#if !defined(__NetBSD__)
 #include <pthread_np.h>
+#endif
 #include <semaphore.h>
 #include <signal.h>
 #include <stdlib.h>
@@ -125,6 +127,22 @@ void OS::AdjustSchedulingParams() {}
 
 // static
 Stack::StackSlot Stack::ObtainCurrentThreadStackStart() {
+#if defined(__NetBSD__)
+  pthread_attr_t attr;
+  int error;
+  pthread_attr_init(&attr);
+  error = pthread_attr_get_np(pthread_self(), &attr);
+  if (!error) {
+    void* base;
+    size_t size;
+    error = pthread_attr_getstack(&attr, &base, &size);
+    CHECK(!error);
+    pthread_attr_destroy(&attr);
+    return reinterpret_cast<uint8_t*>(base) + size;
+  }
+  pthread_attr_destroy(&attr);
+  return nullptr;
+#else
   stack_t ss;
   void *base;
   if (pthread_stackseg_np(pthread_self(), &ss) != 0)
@@ -132,6 +150,7 @@ Stack::StackSlot Stack::ObtainCurrentThreadStackStart() {
 
   base = (void*)((size_t) ss.ss_sp - ss.ss_size);
   return reinterpret_cast<uint8_t*>(base) + ss.ss_size;
+#endif
 }
 
 std::optional<OS::MemoryRange> OS::GetFirstFreeMemoryRangeWithin(
diff --git a/v8/src/base/platform/platform-posix.cc b/v8/src/base/platform/platform-posix.cc
index 1e027883ce..f89bb06f57 100644
--- a/v8/src/base/platform/platform-posix.cc
+++ b/v8/src/base/platform/platform-posix.cc
@@ -79,8 +79,10 @@
 #endif
 
 #if V8_OS_FREEBSD || V8_OS_DARWIN || V8_OS_BSD || V8_OS_SOLARIS
+#ifndef MAP_ANONYMOUS
 #define MAP_ANONYMOUS MAP_ANON
 #endif
+#endif
 
 #if defined(V8_OS_SOLARIS)
 #if (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE > 2) || defined(__EXTENSIONS__)
@@ -362,7 +364,7 @@ void OS::SetRandomMmapSeed(int64_t seed) {
 }
 
 #if V8_OS_OPENBSD
-// Allow OpenBSD's mmap to select a random address on OpenBSD 
+// Allow OpenBSD's mmap to select a random address on OpenBSD
 // static
 void* OS::GetRandomMmapAddr() {
   return nullptr;
@@ -1223,7 +1225,11 @@ Thread::Thread(const Options& options)
       stack_size_(options.stack_size()),
       priority_(options.priority()),
       start_semaphore_(nullptr) {
+#if !defined(V8_OS_NETBSD)
   const int min_stack_size = static_cast<int>(PTHREAD_STACK_MIN);
+#else
+  const int min_stack_size = static_cast<int>(sysconf(_SC_THREAD_STACK_MIN));
+#endif
   if (stack_size_ > 0) stack_size_ = std::max(stack_size_, min_stack_size);
   set_name(options.name());
 }
@@ -1238,7 +1244,7 @@ static void SetThreadName(const char* name) {
   pthread_set_name_np(pthread_self(), name);
 #elif V8_OS_NETBSD
   static_assert(Thread::kMaxThreadNameLength <= PTHREAD_MAX_NAMELEN_NP);
-  pthread_setname_np(pthread_self(), "%s", name);
+  pthread_setname_np(pthread_self(), "%s", (void *)name);
 #elif V8_OS_DARWIN
   // pthread_setname_np is only available in 10.6 or later, so test
   // for it at runtime.
@@ -1417,7 +1423,7 @@ void Thread::SetThreadLocal(LocalStorageKey key, void* value) {
 // keep this version in POSIX as most Linux-compatible derivatives will
 // support it. MacOS and FreeBSD are different here.
 #if !defined(V8_OS_FREEBSD) && !defined(V8_OS_DARWIN) && !defined(_AIX) && \
-    !defined(V8_OS_SOLARIS) && !defined(V8_OS_OPENBSD)
+    !defined(V8_OS_SOLARIS) && !defined(V8_OS_OPENBSD) && !defined(V8_OS_NETBSD)
 
 namespace {
 #if DEBUG
diff --git a/v8/src/base/strings.h b/v8/src/base/strings.h
index c3015e72c8..6f8fee9d52 100644
--- a/v8/src/base/strings.h
+++ b/v8/src/base/strings.h
@@ -8,6 +8,9 @@
 #include "src/base/base-export.h"
 #include "src/base/macros.h"
 #include "src/base/vector.h"
+#if defined(__NetBSD__)
+#include <stdarg.h>
+#endif
 
 namespace v8 {
 namespace base {
diff --git a/v8/src/base/sys-info.cc b/v8/src/base/sys-info.cc
index 708c341c5e..39640f503a 100644
--- a/v8/src/base/sys-info.cc
+++ b/v8/src/base/sys-info.cc
@@ -35,8 +35,12 @@ namespace base {
 
 // static
 int SysInfo::NumberOfProcessors() {
+#if V8_OS_OPENBSD || V8_OS_NETBSD
 #if V8_OS_OPENBSD
   int mib[2] = {CTL_HW, HW_NCPUONLINE};
+#else
+  int mib[2] = {CTL_HW, HW_NCPU};
+#endif
   int ncpu = 0;
   size_t len = sizeof(ncpu);
   if (sysctl(mib, arraysize(mib), &ncpu, &len, nullptr, 0) != 0) {
diff --git a/v8/src/base/utils/random-number-generator.cc b/v8/src/base/utils/random-number-generator.cc
index 91b7c6fc66..465edf438b 100644
--- a/v8/src/base/utils/random-number-generator.cc
+++ b/v8/src/base/utils/random-number-generator.cc
@@ -56,7 +56,7 @@ RandomNumberGenerator::RandomNumberGenerator() {
   DCHECK_EQ(0, result);
   USE(result);
   SetSeed((static_cast<int64_t>(first_half) << 32) + second_half);
-#elif V8_OS_DARWIN || V8_OS_FREEBSD || V8_OS_OPENBSD
+#elif V8_OS_DARWIN || V8_OS_FREEBSD || V8_OS_OPENBSD || V8_OS_NETBSD
   // Despite its prefix suggests it is not RC4 algorithm anymore.
   // It always succeeds while having decent performance and
   // no file descriptor involved.
diff --git a/v8/src/trap-handler/handler-inside-posix.cc b/v8/src/trap-handler/handler-inside-posix.cc
index 884c7df192..54528a3433 100644
--- a/v8/src/trap-handler/handler-inside-posix.cc
+++ b/v8/src/trap-handler/handler-inside-posix.cc
@@ -28,7 +28,7 @@
 
 #include <signal.h>
 
-#if defined(V8_OS_LINUX) || defined(V8_OS_FREEBSD)
+#if defined(V8_OS_LINUX) || defined(V8_OS_FREEBSD) || defined(V8_OS_NETBSD)
 #include <ucontext.h>
 #elif V8_OS_DARWIN
 #include <sys/ucontext.h>
@@ -64,6 +64,8 @@ namespace trap_handler {
 #define CONTEXT_REG(reg, REG) &uc->uc_mcontext.mc_##reg
 #elif V8_OS_OPENBSD
 #define CONTEXT_REG(reg, REG) &uc->sc_##reg
+#elif V8_OS_NETBSD
+#define CONTEXT_REG(reg, REG) &uc->uc_mcontext.__gregs[_REG_##REG]
 #else
 #error "Unsupported platform."
 #endif
diff --git a/v8/src/trap-handler/handler-inside-posix.h b/v8/src/trap-handler/handler-inside-posix.h
index ef2f4ee84d..d17ee7b539 100644
--- a/v8/src/trap-handler/handler-inside-posix.h
+++ b/v8/src/trap-handler/handler-inside-posix.h
@@ -13,7 +13,7 @@ namespace v8 {
 namespace internal {
 namespace trap_handler {
 
-#if V8_OS_LINUX || V8_OS_FREEBSD || V8_OS_OPENBSD
+#if V8_OS_LINUX || V8_OS_FREEBSD || V8_OS_OPENBSD || V8_OS_NETBSD
 constexpr int kOobSignal = SIGSEGV;
 #elif V8_OS_DARWIN
 constexpr int kOobSignal = SIGBUS;
diff --git a/v8/src/trap-handler/trap-handler.h b/v8/src/trap-handler/trap-handler.h
index 82b6e72582..c0f6016aa4 100644
--- a/v8/src/trap-handler/trap-handler.h
+++ b/v8/src/trap-handler/trap-handler.h
@@ -18,7 +18,7 @@ namespace v8::internal::trap_handler {
 // X64 on Linux, Windows, MacOS, FreeBSD.
 #if V8_HOST_ARCH_X64 && V8_TARGET_ARCH_X64 &&                        \
     ((V8_OS_LINUX && !V8_OS_ANDROID) || V8_OS_WIN || V8_OS_DARWIN || \
-     V8_OS_FREEBSD || V8_OS_OPENBSD)
+     V8_OS_FREEBSD || V8_OS_OPENBSD || V8_OS_NETBSD)
 #define V8_TRAP_HANDLER_SUPPORTED true
 // Arm64 native on Linux, Windows, MacOS.
 #elif V8_TARGET_ARCH_ARM64 && V8_HOST_ARCH_ARM64 && \
diff --git a/v8/tools/run-paxctl.py b/v8/tools/run-paxctl.py
new file mode 100644
index 0000000000..7cffa35b09
--- /dev/null
+++ b/v8/tools/run-paxctl.py
@@ -0,0 +1,16 @@
+#!@PYTHONBIN@
+# Copyright 2014 the V8 project authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+"""This program wraps an arbitrary command since gn currently can only execute
+scripts."""
+
+import subprocess
+import sys
+import os
+
+with open(sys.argv[1], 'w'):
+  os.utime(sys.argv[1], None)
+
+sys.exit(subprocess.call(sys.argv[2:]))
diff --git a/v8/tools/run.py b/v8/tools/run.py
index f8ec94c6bc..8879702b77 100755
--- a/v8/tools/run.py
+++ b/v8/tools/run.py
@@ -21,7 +21,7 @@ if cmd and cmd[0] == '--redirect-stdout':
   kwargs = dict(stdout=subprocess.PIPE)
   cmd = cmd[2:]
 
-process = subprocess.Popen(cmd, env={"LD_LIBRARY_PATH":"${WRKSRC}/out/Release"}, **kwargs)
+process = subprocess.Popen(cmd, env={"LD_LIBRARY_PATH":"@WRKSRC@/out/Release"}, **kwargs)
 stdout, _ = process.communicate()
 if stdout_file:
   with stdout_file.open('w') as f:
